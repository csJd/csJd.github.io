<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>给本地项目添加 Github Repo</title>
    <url>/posts/add-to-github-repo/</url>
    <content><![CDATA[<p>将本地项目添加 Github repo 后可以方便的在其它设备继续进行项目的开发，也可以方便的与其他人分享自己的项目，我这里记录一下给本地项目添加 Github repo 的方法。</p>
<span id="more"></span>

<p>首先要保证本地电脑安装了 Git，且本地电脑的 ssh 公钥添加到了你的<a href="https://github.com/settings/keys">Github 账号的 SSH keys</a>，添加公钥方法可见<a href="https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/">GitHub 给的说明</a>。然后在 Github 上新建一个 Repo，这个新建的 Repo 就是用来做本地项目 Github repo 的，接下来就是把本地项目 push 到 Github repo 了。</p>
<h2 id="方法一：Clone"><a href="#方法一：Clone" class="headerlink" title="方法一：Clone"></a>方法一：Clone</h2><p>若项目本来不属于一个本地 Git repo，直接执行以下命令克隆刚新建的 Github repo，再将项目文件移入就行了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># username为用户名，gitRepo为刚新建的Repo名称</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:username/gitRepo.git</span><br></pre></td></tr></table></figure>
<p>然后就能 add，commit，push 了。</p>
<h2 id="方法二：手动添加-remote"><a href="#方法二：手动添加-remote" class="headerlink" title="方法二：手动添加 remote"></a>方法二：手动添加 remote</h2><p>项目本身就属于一个本地 Git repo 时，手动添加 remote 比较好，在项目目录执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给本地Git repo添加remote repo</span></span><br><span class="line">git remote add origin git@github.com:username/gitRepo.git </span><br><span class="line"><span class="comment"># 设置push的upstream</span></span><br><span class="line">git push -u origin master</span><br><span class="line"><span class="comment"># 将项目push到GitHub repo</span></span><br><span class="line">git push -f</span><br></pre></td></tr></table></figure>
<p>这样就完成本地项目和 GitHub repo 的关联了。</p>
]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>小米 2s Magisk 框架实现 Systemless Root</title>
    <url>/posts/aries-systemless-root/</url>
    <content><![CDATA[<p>听说最近出了个 Magisk 框架，可以在不修改 &#x2F;system 下实现 root 和 xposed ，这样理论上装了 xposed 框架还能 OTA ，听起来真不错。就拿出了我的 2s 折腾了下，发现真的可以，这里分享一下过程。<br>我是卡刷官方倒数第二个稳定版（<a href="http://bigota.d.miui.com/V8.1.2.0.LXACNDI/miui_MI2_V8.1.2.0.LXACNDI_95e24f367d_5.0.zip">V8.1.2.0.LXACNDI</a>），清空全部数据再进行以下操作的，不保证其他情况不会出现问题，请自行尝试。</p>
<span id="more"></span>

<h1 id="1-刷入-TWRP-Recovery"><a href="#1-刷入-TWRP-Recovery" class="headerlink" title="1. 刷入 TWRP Recovery"></a>1. 刷入 TWRP Recovery</h1><p>在<a href="https://dl.twrp.me/aries/">TWRP 官网</a>下载小米 2s 最新的 TWRP Recovery ,使用 fastboot 刷入并重启进入 recovery，命令如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastboot flash recovery twrp-3.1.0-0-aries.img</span><br><span class="line">fastboot reboot</span><br></pre></td></tr></table></figure>
<p>不会的可以参考<a href="http://bbs.xiaomi.cn/t-10498119">此贴</a></p>
<h1 id="2-下载相关文件并复制到手机"><a href="#2-下载相关文件并复制到手机" class="headerlink" title="2. 下载相关文件并复制到手机"></a>2. 下载相关文件并复制到手机</h1><p>下载以下文件并复制到手机，TWRP Recovery 是支持 MTP 连接电脑的， 可以不进入系统直接在 Recovery 模式下连接电脑将相关文件复制到手机， </p>
<ul>
<li>最新版 <a href="http://tiny.cc/latestmagisk">Magisk - zip</a></li>
<li>最新版 <a href="http://tiny.cc/latestuninstaller">Magisk Uninstaller - zip</a> </li>
<li>最新版 <a href="http://tiny.cc/latestmanager">Magisk Manager - apk</a><br>这里也给出 Magisk 的<a href="https://forum.xda-developers.com/apps/magisk/official-magisk-v7-universal-systemless-t3473445">xda 发布链接</a>。</li>
<li>Magisk Xposed for MIUI by SolarWarez - zip，<a href="https://forum.xda-developers.com/attachment.php?attachmentid=3950449&d=1480267001">下载链接</a>，<a href="https://forum.xda-developers.com/xposed/unofficial-xposed-miui-t3367634">xda 发布链接</a></li>
<li>Material Design Xposed Installer - apk，<a href="https://forum.xda-developers.com/xposed/material-design-xposed-installer-t3137758">xda 发布链接</a></li>
</ul>
<h1 id="3-刷入-Magisk"><a href="#3-刷入-Magisk" class="headerlink" title="3. 刷入 Magisk"></a>3. 刷入 Magisk</h1><p>在 TWRP Recovery 刷入 <strong>Magisk-v12.0.zip</strong> ，重启进入系统，第一次重启会很慢，是正常的。进入系统后安装 <strong>MagiskManager-v4.3.3.apk</strong>。以上文件名中的版本均为我安装时的最新版。<br>打开 Magisk Manager 类似下图就是安装成功了：<br><img src="https://raw.githubusercontent.com/csJd/csJd.github.io/res/aries-systemless-root-0.png"><br>Magisk 是自带 root 的，不修改 &#x2F;system 的 root 。</p>
<h1 id="4-安装-xposed-模块"><a href="#4-安装-xposed-模块" class="headerlink" title="4. 安装 xposed 模块"></a>4. 安装 xposed 模块</h1><p>在上图 Magisk Manager 主界面左划点击模块，添加模块，选择刚下载的 <strong>xposed-v87-sdk21-Magisk-MIUI-edition-by-SolarWarez-20161127.zip</strong> 就行了。<br>左划点击下载也能安装更多自己想要的 Magisk 模块。<br>然后重启，也很慢，安装 <strong>XposedInstaller_by_dvdandroid_29_04_17.apk</strong> ，xposed 也 ok 了，如下图：<br><img src="https://raw.githubusercontent.com/csJd/csJd.github.io/res/aries-systemless-root-1.png"></p>
<h1 id="5-尝试-OTA"><a href="#5-尝试-OTA" class="headerlink" title="5. 尝试 OTA"></a>5. 尝试 OTA</h1><p>都安装好了后，我试了下 OTA ，系统果然是会推送 OTA 的：<br><img src="https://raw.githubusercontent.com/csJd/csJd.github.io/res/aries-systemless-root-2.png"><br>但要先刷入 <strong>Magisk-uninstaller-20170320.zip</strong>，卸载了 Magisk 才能安装 OTA。不急，安装完 OTA 重启后，再重新刷一下 <strong>Magisk-v12.0.zip</strong> 就行，之前安装的 Magisk 模块不用再重新装了。</p>
]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>Phone</tag>
      </tags>
  </entry>
  <entry>
    <title>Something about Attention</title>
    <url>/posts/attention/</url>
    <content><![CDATA[<p>A summarization of Attention mechanism. Supporsing that we have hidden state representations $H \in \mathbb{R}^{n*d}$, where $n$ is the length of sequence, $d$ is the dimension of hidden layer representation of each token.</p>
<span id="more"></span>
<!--Supporsing that we have hidden state representations $H \in \mathbb{R}^{n*d}$, where $n$ is the length of sequence, $d$ is the dimension of hidden layer representation of each token.
-->

<h2 id="In-Seq2Seq"><a href="#In-Seq2Seq" class="headerlink" title="In Seq2Seq"></a>In Seq2Seq</h2><p><a href="https://arxiv.org/abs/1409.0473">Bahdanau, D., Cho, K., &amp; Bengio, Y. (2014). Neural machine translation by jointly learning to align and translate. ICLR 2015</a></p>
<p>$$<br>  \begin{aligned}<br>    c_i &amp;&#x3D; \sum_{j&#x3D;1}^{T_x}\alpha_{ij}h_j \<br>    \alpha_{ij} &amp;&#x3D; \frac{\exp{(e_{ij})}} {\sum_{k&#x3D;1}^{T_x} \exp(e_{ik})} \<br>    e_{ij} &amp;&#x3D; a(s_{i-1},h_j)<br>  \end{aligned}<br>$$</p>
<p><a href="https://aclweb.org/anthology/D15-1166">Luong, M. T., Pham, H., &amp; Manning, C. D. (2015). Effective approaches to attention-based neural machine translation. EMNLP 2015</a></p>
<p>$$<br>\begin{aligned}<br>  &amp; a_t(s) &#x3D; align(h_t, h_s) &#x3D; \frac{\exp(score(h_t, h_s))}{\sum_{s’}\exp(score(h_t, h_{s’}))}\<br>  &amp;score(h_t, h_s)&#x3D;<br>    \begin{cases}<br>      {h_t}^Th_s    &amp; \quad \text{dot}\<br>      {h_t}^TW_ah_s &amp; \quad \text{general}\<br>      W_a[h_t;h_s]  &amp; \quad \text{concat}<br>    \end{cases}<br>  \end{aligned}<br>$$</p>
<p><a href="https://jalammar.github.io/visualizing-neural-machine-translation-mechanics-of-seq2seq-models-with-attention/">More details here.</a></p>
<h2 id="In-Relation-Classification"><a href="#In-Relation-Classification" class="headerlink" title="In Relation Classification"></a>In Relation Classification</h2><p><a href="https://www.aclweb.org/anthology/P16-2034">Zhou, P., Shi, W., Tian, J., Qi, Z., Li, B., Hao, H., &amp; Xu, B. (2016). Attention-based bidirectional long short-term memory networks for relation classification. ACL 2016</a></p>
<p>$$<br>  \begin{aligned}<br>    M &amp;&#x3D; \tanh(H^T)\<br>    \alpha &amp;&#x3D; softmax(w^TM)\<br>    r &amp;&#x3D; H\alpha^T<br>  \end{aligned}<br>  \quad<br>  \implies<br>  \quad<br>  \begin{aligned}<br>  A &amp;&#x3D; \tanh(H) \quad &amp; (A \in \mathbb{R}^{n\times d})\<br>  \alpha &amp;&#x3D; softmax(Aw) \quad &amp; (w \in \mathbb{R}^{d}, \alpha \in \mathbb{R}^{n})\<br>  r &amp;&#x3D; \alpha^TH \quad &amp; (r \in \mathbb{R}^{d})<br>  \end{aligned}<br>$$</p>
<ul>
<li>input: $H \in \mathbb{R}^{n\times d}$</li>
<li>parameters to train: $w \in \mathbb{R}^{d}$</li>
<li>output: sentence representation $r \in \mathbb{R}^d$</li>
</ul>
<h2 id="HAN-in-Text-Classification"><a href="#HAN-in-Text-Classification" class="headerlink" title="HAN in Text Classification"></a>HAN in Text Classification</h2><p><a href="https://www.aclweb.org/anthology/N16-1174">Yang, Z., Yang, D., Dyer, C., He, X., Smola, A., &amp; Hovy, E. (2016). Hierarchical attention networks for document classification. NAACL 2016</a></p>
<p>$$<br>  \begin{aligned}<br>    u_{it} &amp;&#x3D; \tanh(W_wh_{it} + b_w)\<br>    \alpha_{it} &amp;&#x3D; \frac{\exp({u_{it}}^Tu_w)} {\sum_t \exp({u_{it}}^Tu_w)}\<br>    s_i &amp;&#x3D; \sum_t \alpha_{it}h_{it}<br>  \end{aligned}<br>  \quad<br>  \implies<br>  \quad<br>  \begin{aligned}<br>  A &amp;&#x3D; \tanh(HW+b) \quad &amp; (A \in \mathbb{R}^{n\times d_w})\<br>  \alpha &amp;&#x3D; softmax(Au) \quad &amp; (u \in \mathbb{R}^{d_w}, \alpha \in \mathbb{R}^{n})\<br>  r &amp;&#x3D; \alpha^TH \quad &amp; (r \in \mathbb{R}^{d})<br>  \end{aligned}<br>$$</p>
<ul>
<li>input: $H \in \mathbb{R}^{n\times d}$</li>
<li>parameters to train: $W \in \mathbb{R}^{d\times d_w}$, $u \in \mathbb{R}^{d_w}$</li>
<li>output: sentence representation $r \in \mathbb{R}^d$</li>
</ul>
<h2 id="Self-Attention-in-Transformer"><a href="#Self-Attention-in-Transformer" class="headerlink" title="Self-Attention in Transformer"></a>Self-Attention in Transformer</h2><p><a href="http://papers.nips.cc/paper/7181-attention-is-all-you-need">Vaswani, A., Shazeer, N., Parmar, N., Uszkoreit, J., Jones, L., Gomez, A. N., … &amp; Polosukhin, I. (2017). Attention is all you need. NIPS 2017</a></p>
<p>$$<br>  \begin{aligned}<br>    Q &amp;&#x3D; HW_Q \<br>    K &amp;&#x3D; HW_K \<br>    V &amp;&#x3D; HW_V \<br>    H’&amp;&#x3D; softmax(\frac{QK^T}{\sqrt{d_k}}) V<br>  \end{aligned}<br>$$</p>
<ul>
<li>input: $H \in \mathbb{R}^{n\times d}$</li>
<li>parameters to train: $W_Q, W_K, W_V \in \mathbb{R}^{d\times d_k}$</li>
<li>output: next hidden layer representation $H’ \in \mathbb{R}^{n\times d_k}$</li>
</ul>
<p><a href="http://jalammar.github.io/illustrated-transformer/">More details here.</a></p>
]]></content>
      <categories>
        <category>Review</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>AWS Educate &amp; Amazon Lightsail</title>
    <url>/posts/aws-educate/</url>
    <content><![CDATA[<p>之前申请的 DigitalOcean 的云主机最近到期了，偶然看到学校已经在 <a href="https://aws.amazon.com/cn/education/awseducate/">AWS Educate</a> 的 <a href="https://s3.amazonaws.com/awseducate-list/AWS_Educate_Institutions.pdf">会员院校列表</a> 里了，注册 AWS Educate 后可以得到 $100&#x2F;年 的服务抵扣金额（Credits），配合 AWS 的 <a href="https://lightsail.aws.amazon.com/ls/webapp/home/instances">Amazon Lightsail</a> 实例可以使用一年多，趁着还是学生，决定折腾一个，这里记录一下过程。</p>
<span id="more"></span>

<h1 id="注册-AWS-Educate"><a href="#注册-AWS-Educate" class="headerlink" title="注册 AWS Educate"></a>注册 AWS Educate</h1><p>在 <a href="https://aws.amazon.com/cn/education/awseducate">AWS Educate 主页</a> 点击 「加入 AWS Educate」 ，身份选择 「Student」，下一步，电子邮件需要填学校的邮箱，收到邮件点击链接就可以完成注册。有信用卡（别人的没用过的也行）的话就继续注册 AWS 账户，没有就直接使用 AWS Educate Starter 账户，但是会有 <a href="https://aws.amazon.com/cn/premiumsupport/knowledge-center/educate-starter-account/">一些限制</a>，送的抵扣金额也少一些。我注册的是 AWS 账户，以下步骤也是针对 AWS 账户，AWS Educate Starter 账户可能会有所不同。</p>
<h1 id="注册-AWS-账户（需信用卡）"><a href="#注册-AWS-账户（需信用卡）" class="headerlink" title="注册 AWS 账户（需信用卡）"></a>注册 AWS 账户（需信用卡）</h1><p>注册 AWS 账户需要信用卡，银联的信用卡也是可以的。在 AWS <a href="https://portal.aws.amazon.com/billing/signup#/start">账户注册站点</a> 按步骤即可完成注册。注册完成后再 “我的账户” 可以看到账户 ID（12 位数字），复制账户 ID，再登录 <a href="https://www.awseducate.com/signin/SiteLogin">AWS Educate</a> 输入 AWS 账户 ID 就可以得到 $100 的服务抵扣金额的优惠代码，可在 <a href="https://www.awseducate.com/student/s/awssite">此处</a> 查看。<br>复制该优惠代码，在 <a href="https://console.aws.amazon.com/billing/home#/credits">AWS 账单 | 服务抵扣金额</a> 处粘贴即可绑定该 $100 到 AWS 账户。</p>
<p><img src="https://raw.githubusercontent.com/csJd/res/master/pic/image.png" alt="image"></p>
<h1 id="使用-Amazon-Lightsail"><a href="#使用-Amazon-Lightsail" class="headerlink" title="使用 Amazon Lightsail"></a>使用 Amazon Lightsail</h1><p><a href="https://lightsail.aws.amazon.com/ls/webapp/home/instances">Amazon Lightsail</a> 类似于 DigitalOcean 之类的 VPS 服务商家，比起之前用过的 EC2 实例要实惠多了，而且可以使用 AWS Credits，每月有 1T 的流量，最低配置只需要 $3.5&#x2F;月，用户体验极棒。</p>
<h2 id="新建实例"><a href="#新建实例" class="headerlink" title="新建实例"></a>新建实例</h2><p>在 <a href="https://lightsail.aws.amazon.com/ls/webapp/home/instances">新建实例</a> 的地方点击 「Create Instance」 按步骤即可完成实例的新建，记得区域一定选东京（Tokyo），系统选 Ubuntu 18.04，具体如下图：</p>
<p><img src="https://raw.githubusercontent.com/csJd/res/master/pic/image.se1sl2h6eqp.png" alt="image"></p>
<p>Plan 选择最低的 $3.5&#x2F;月 就够用了，点击最下方 「Create instalce」 就可以完成实例的创建，然后就拥有一个在 Tokyo 的云主机啦。</p>
<h2 id="绑定静态-IP"><a href="#绑定静态-IP" class="headerlink" title="绑定静态 IP"></a>绑定静态 IP</h2><p>Amazon Lightsail 默认是动态 IP，可以手动绑定静态 IP，在 <a href="https://lightsail.aws.amazon.com/ls/webapp/create/static-ip?region=ap-northeast-1">创建静态 IP</a>  的页面即可绑定，绑定之后的静态 IP 是免费的，如下图：</p>
<p><img src="https://raw.githubusercontent.com/csJd/res/master/pic/image.ajgxeezmehm.png" alt="image"></p>
<p>点击最下方的 「Create」 即可完成静态 IP 的创建和绑定，就可以使用 SSH 通过该静态 IP 来访问刚新建的 LightSail 实例了。</p>
<h2 id="SSH-连接"><a href="#SSH-连接" class="headerlink" title="SSH 连接"></a>SSH 连接</h2><p>Lightsail 默认只能使用 SSH key 来连接，可以在 <a href="https://lightsail.aws.amazon.com/ls/webapp/account/keys">这里下载</a> 用于连接的 SSH key，进入刚创建的 Lightsail 实例的 <a href="https://lightsail.aws.amazon.com/ls/webapp/ap-northeast-1/instances/Ubuntu-1/connect">详情界面</a>，复制实例的 IP，通过该 IP 和刚下载的 SSH key，就可以连接该实例了.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需要修改 SSH key 的权限为 400，仅第一次需要修改</span></span><br><span class="line"><span class="built_in">chmod</span> 400 LightsailDefaultKey-ap-northeast-1.pem</span><br><span class="line"><span class="comment"># ssh 连接</span></span><br><span class="line">ssh -i LightsailDefaultKey-ap-northeast-1.pem ubuntu@[your_ip_address]</span><br></pre></td></tr></table></figure>
<p>成功连接：</p>
<p><img src="https://raw.githubusercontent.com/csJd/res/master/pic/image.w5465qhk2r.png" alt="image"></p>
<h2 id="端口开放"><a href="#端口开放" class="headerlink" title="端口开放"></a>端口开放</h2><p>新建的 Lightsail 实例默认只开启了用于 SSH 连接的 22 端口，如需使用其他端口可在实例详情界面的 「Networking」 的 「Firewall」 手动开启相关端口，不清楚具体开启什么端口可以在 「Application」处选择「All TCP + UDP」开启所有端口。</p>
<hr>
<p>然后就可以使用啦~</p>
]]></content>
      <categories>
        <category>Practice</category>
      </categories>
      <tags>
        <tag>Practice</tag>
      </tags>
  </entry>
  <entry>
    <title>绑定 Github Pages 到自己的域名</title>
    <url>/posts/bind-domian/</url>
    <content><![CDATA[<p>Github 提供了 GitHub pages 绑定到域名的方法，刚好之前申请了一个 <a href="http://www.freenom.com/zh/index.html?lang=zh">freenom</a> 的免费域名，用自己的域名有时候会方便一些，下面是方法。</p>
<h2 id="1-Ping"><a href="#1-Ping" class="headerlink" title="1. Ping"></a>1. Ping</h2><p><code>ping</code> 你的 Github Pages 对应的服务器 IP</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping csJd.github.io</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="2-添加域名-DNS-记录"><a href="#2-添加域名-DNS-记录" class="headerlink" title="2. 添加域名 DNS 记录"></a>2. 添加域名 DNS 记录</h2><p>以下两方法选一种即可</p>
<ul>
<li>进入你的域名管理界面，添加一个 A 记录到你刚 <code>ping</code> 得的 IP，如我添加 <code>deng.cf</code> 到 <code>151.101.100.133</code></li>
<li>喜欢用二级域名的话，可以添加一个<em>CNAME</em>记录到你的 Github pages 地址，如添加 <code>blog.deng.cf</code> 到 <code>csJd.github.io</code>，如下图<br><img src="https://github.com/csJd/csJd.github.io/raw/res/Bind-github-pages-with-your-domain2.png"></li>
</ul>
<h2 id="3-设置-CNAME"><a href="#3-设置-CNAME" class="headerlink" title="3. 设置 CNAME"></a>3. 设置 CNAME</h2><p>在你的 <code>yourusername.github.io</code> 项目点 Settings，在 Custom domain 处填上你刚添加的记录，如 <code>blog.deng.cf</code> ，这样就完成了域名的绑定，如下图<br><img src="https://github.com/csJd/csJd.github.io/raw/res/Bind-github-pages-with-your-domain.png"><br>若是使用 Hexo 搭建，还需在 <code>source</code> 文件夹下新建 <code>CNAME</code> 文件，无后缀，内容为你上面填的域名，如 <code>blog.deng.cf</code>，然后执行 <code>hexo g -d</code> 部署即可生效</p>
]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Domain</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>双系统安装指北</title>
    <url>/posts/dual-boot/</url>
    <content><![CDATA[<h1 id="双系统（Windows-Ubuntu）安装指北"><a href="#双系统（Windows-Ubuntu）安装指北" class="headerlink" title="双系统（Windows + Ubuntu）安装指北"></a>双系统（Windows + Ubuntu）安装指北</h1><blockquote>
<p>以下操作会清空所有磁盘的所有数据，请提前备份需要的数据。<strong>所有未提及到的选项请都保持默认选项</strong></p>
</blockquote>
<span id="more"></span>


<h2 id="0-准备材料"><a href="#0-准备材料" class="headerlink" title="0 准备材料"></a>0 准备材料</h2><ul>
<li><a href="https://item.jd.com/5723649.html">U 盘（8G↑)</a></li>
<li><a href="https://www.microsoft.com/zh-cn/software-download/windows10ISO">Windows 10 ISO</a>(需要使用非 Windows 系统才能获取下载链接，如手机）</li>
<li><a href="https://www.ubuntu.com/download/desktop">Ubuntu Desktop LTS 版 ISO</a></li>
<li><a href="https://rufus.ie/zh_CN.html">Rufus Portable 版</a></li>
<li><a href="http://www.wepe.com.cn/download.html">WEPE Win10PE 64 位版</a></li>
</ul>
<h2 id="1-在-U-盘安装-WEPE"><a href="#1-在-U-盘安装-WEPE" class="headerlink" title="1 在 U 盘安装 WEPE"></a>1 在 U 盘安装 WEPE</h2><ul>
<li>运行「WEPE」，选择安装到 U 盘，选项默认</li>
<li>将下载的 ISO 文件和 rufus 复制到 U 盘</li>
</ul>
<h2 id="2-磁盘分区"><a href="#2-磁盘分区" class="headerlink" title="2 磁盘分区"></a>2 磁盘分区</h2><ul>
<li><p>重启按 <strong>F12</strong> 键，选择带 「UEFI」的 U 盘启动项</p>
</li>
<li><p>打开桌面上的「分区助手」，点击上方「快速分区」，磁盘类型<strong>一定选择 GPT</strong> ，上方分区数目建议不超过 3 ，其中用于 Windows 系统的 C 盘的分区卷标设置为「<strong>OS</strong>」；用于 Ubuntu 系统的安装的分区卷标设置为「<strong>Ubuntu</strong>」；用于 Windows 系统的普通分区卷标设置建议为「Data」、「Apps」之类，自己开心就好</p>
<p>   建议分区方案（SSD 表示固态硬盘，HDD 表示机械硬盘，REST 表示该磁盘剩余空间）:</p>
<table>
<thead>
<tr>
<th>硬盘类型</th>
<th>OS</th>
<th>Apps</th>
<th>Data</th>
<th>Ubuntu</th>
<th>分区数目</th>
</tr>
</thead>
<tbody><tr>
<td>仅 HDD</td>
<td>100G</td>
<td>&#x2F;</td>
<td>REST</td>
<td>200G</td>
<td>3</td>
</tr>
<tr>
<td>仅 SSD(256G↑)</td>
<td>80G</td>
<td>&#x2F;</td>
<td>REST</td>
<td>80G</td>
<td>3</td>
</tr>
<tr>
<td>SSD(128G) + HDD</td>
<td>80G(SSD)</td>
<td>REST(SSD)</td>
<td>REST(HDD)</td>
<td>200G(HDD)</td>
<td>4</td>
</tr>
<tr>
<td>SSD(256G↑) + HDD</td>
<td>100G(SSD)</td>
<td>REST(SSD)</td>
<td>REST(HDD)</td>
<td>50G(SSD) + 200G(HDD)</td>
<td>5</td>
</tr>
</tbody></table>
</li>
<li><p>完成分区后，鼠标右键点击卷标为「Ubuntu」的分区，点击<strong>删除分区</strong>，保持其空间为「未分配」，这些空间将用于 Ubuntu 的安装</p>
</li>
</ul>
<h2 id="3-安装-Windows-10"><a href="#3-安装-Windows-10" class="headerlink" title="3 安装 Windows 10"></a>3 安装 Windows 10</h2><ul>
<li>将 U 盘中的 Windows 10 ISO 文件和 rufus 复制到硬盘中卷标<strong>不为 OS</strong>的分区，弹出并<strong>拔掉</strong> U 盘</li>
<li>打开桌面上的 「Windows 安装器」，Windows 安装文件的文件夹选择刚复制的 ISO 文件，安装磁盘的位置选择卷标为「OS」的分区，引导驱动器选择处<strong>保持默认</strong>，版本选择「Windows 10 专业版」</li>
<li>点击开始安装，进度条走完后手动重启，按提示完成 Windows 安装步骤</li>
<li>进入系统后，桌面空白处点击鼠标右键，选择「个性化 | 主题 | 桌面图标设置」可添加「计算机」图标到桌面</li>
</ul>
<h2 id="4-安装-Ubuntu"><a href="#4-安装-Ubuntu" class="headerlink" title="4 安装 Ubuntu"></a>4 安装 Ubuntu</h2><ul>
<li>在 Windows 系统中运行之前复制到硬盘的 「rufus」，「设备」处选择 U 盘，点击「选择」处，选择 Ubuntu 的 ISO 文件，其余选项默认，点击「开始」将 Ubuntu ISO 文件写入 U 盘</li>
<li>重启按 <strong>F12</strong> 键，选择带 「UEFI」的 U 盘启动项，选择 「安装 Ubuntu」</li>
<li>「安装类型」处选择「其他选项」</li>
<li>选中空闲设备，点击下方加号依次创建 <code>swap</code>[8G]，<code>/</code>[50G(此处优先使用 SSD 空闲空间)]，<code>/home</code>[REST]</li>
<li>点击下方「现在安装」，按提示完成 Ubuntu 安装步骤</li>
</ul>
]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>Practice</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Filebrowser 分享文件</title>
    <url>/posts/filebrowser/</url>
    <content><![CDATA[<p><a href="https://github.com/filebrowser/filebrowser">Filebrowser</a> 是一个开源的服务器文件管理和分享工具<br>可以较方便的实现服务器上文件的分享，这里记录下个人的使用经验</p>
<span id="more"></span>

<h2 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h2><p>一行代码就可以完成安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https://filebrowser.org/installation</span></span><br><span class="line">curl -fsSL https://raw.githubusercontent.com/filebrowser/get/master/get.sh | bash</span><br></pre></td></tr></table></figure>

<p>初始化配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化配置并保存至当前目录的 `filebrowser.db`</span></span><br><span class="line">filebrowser config init \</span><br><span class="line">  --address 0.0.0.0 \</span><br><span class="line">  --port 443 \</span><br><span class="line">  --root ~/downloads/</span><br><span class="line">  --cert ~/ssl/domain_cert.cer \</span><br><span class="line">  --key ~/ssl/domain_key.key \</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明：https://filebrowser.org/cli/filebrowser-config-init</span></span><br><span class="line"><span class="comment"># --address, --port 监听地址与端口</span></span><br><span class="line"><span class="comment"># --root 待分享文件的根目录</span></span><br><span class="line"><span class="comment"># --cert, --key TLS 证书和 key, 用于启用 https 访问，不配置则为 http 访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加用户</span></span><br><span class="line">filebrowser <span class="built_in">users</span> add &#123;username&#125; &#123;password&#125;</span><br></pre></td></tr></table></figure>

<p>然后启动程序，就可以通过浏览器访问 filebrowser (<a href="https://your_domain.com/">https://your_domain.com</a>)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">filebrowser -d filebrowser.db</span><br></pre></td></tr></table></figure>

<h2 id="创建-systemd-服务"><a href="#创建-systemd-服务" class="headerlink" title="创建 systemd 服务"></a>创建 systemd 服务</h2><p>filebrowser 自身没有作为 daemon 运行的选项，可以自己创建一个 <a href="https://www.freedesktop.org/software/systemd/man/systemd.service.html">systemd 服务</a>，<br>从而方便开机启动和服务重启等</p>
<p>创建用户级的 systemd 服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># vim ~/.config/systemd/user/filebrowser.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=Filebrowser</span><br><span class="line">After=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/local/bin/filebrowser -d /home/ubuntu/filebrowser.db</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line"># Here must be `default.target`, the service otherwise won&#x27;t start on boot</span><br><span class="line">WantedBy=default.target</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># systemd reload 以识别刚新建的服务</span></span><br><span class="line">systemctl --user daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">systemctl --user start filebrowser  </span><br><span class="line">systemctl --user status filebrowser</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机自动启动服务</span></span><br><span class="line">systemctl --user <span class="built_in">enable</span> filebrowser</span><br></pre></td></tr></table></figure>

<p><a href="https://linuxhandbook.com/create-systemd-services">systemd service handbook</a></p>
]]></content>
      <categories>
        <category>Practice</category>
      </categories>
      <tags>
        <tag>Practice</tag>
      </tags>
  </entry>
  <entry>
    <title>FlexGet 自动 PT 下载设置</title>
    <url>/posts/flexget/</url>
    <content><![CDATA[<p>家里网络可连接性较差，挂的 PT 一直没有上传，就尝试在 VPS 上配置远程 PT 下载，这里记录下在 Ubuntu 18.04 VPS 上使用 FlexGet 自动下载 PT 站资源的设置。</p>
<span id="more"></span>

<h2 id="前置软件包安装"><a href="#前置软件包安装" class="headerlink" title="前置软件包安装"></a>前置软件包安装</h2><h3 id="安装-PT-下载客户端"><a href="#安装-PT-下载客户端" class="headerlink" title="安装 PT 下载客户端"></a>安装 PT 下载客户端</h3><p>PT 下载客户端推荐使用 <a href="https://transmissionbt.com/">Transmission</a> 或 <a href="https://www.qbittorrent.org/download.php">qBittorrent</a>，据说 Transmission 更适合保种，qBittorrent 适合下载新&#x2F;热种赚上传。</p>
<h4 id="Transmisson"><a href="#Transmisson" class="headerlink" title="Transmisson"></a>Transmisson</h4><p>Transmisson 使用以下命令安装：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install transmission-daemon</span><br></pre></td></tr></table></figure>

<p>安装后配置文件位于：<code>/etc/transmission-daemon/settings.json</code>，其详细配置信息可见 <a href="https://github.com/transmission/transmission/wiki/Editing-Configuration-Files">官方 Wiki</a>，编辑该配置文件，主要需要修改的项目如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;rpc-authentication-required&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;rpc-password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;transmission&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;rpc-username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;transmission&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;rpc-whitelist-enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后执行 <code>service transmission-daemon start</code> 就可以开启 Transmission 后台服务，其 Web 管理服务的默认端口为 <code>9091</code>，浏览器输入 <code>http://&lt;yourVpsIP&gt;:9091</code> 就可以通过 Web 管理界面远程控制 VPS 上的 Transmission，默认提供的 Transmission RPC 界面较简陋，可以额外安装第三方开源的 <a href="https://github.com/ronggang/transmission-web-control">Transmission Web Control (TWC)</a> 作为替换。进入 Web 管理界面后可自行修改其他设置选项。</p>
<h4 id="qBittorrent"><a href="#qBittorrent" class="headerlink" title="qBittorrent"></a>qBittorrent</h4><p>Ubuntu 官方源提供的 qBittorent 版本较旧，部分 PT 站点不支持使用旧版本，可以使用 qBittorrent 官方 PPA 安装最新的稳定版本:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:qbittorrent-team/qbittorrent-stable</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install qbittorrent-nox</span><br></pre></td></tr></table></figure>

<p>运行 <code>qbittorrent-nox -d</code> 即在后台运行 qBittorrent，其 Web 管理服务默认端口为 <code>8080</code>，默认用户名为 <code>admin</code>，默认密码为 <code>adminadmin</code>，浏览器输入 <code>http://&lt;yourVpsIP&gt;:8080</code> 进入 Web 管理界面后可以修改这些内容及其他设置。</p>
<h2 id="FlexGet-设置"><a href="#FlexGet-设置" class="headerlink" title="FlexGet 设置"></a>FlexGet 设置</h2><p>下载 PT 站点较新的内容可以较快获得上传量，但每次都手动添加也较麻烦，使用 <a href="https://flexget.com/InstallWizard/Linux">FlexGet</a> 可以利用 PT 站点提供的 RSS 订阅实现自动下载最新的资源以及删除旧的内容。</p>
<h3 id="FlexGet-安装"><a href="#FlexGet-安装" class="headerlink" title="FlexGet 安装"></a>FlexGet 安装</h3><p>FlexGet 基于 Python 实现，执行以下命令安装：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt install python3 python3-pip</span><br><span class="line">pip3 install flexget</span><br></pre></td></tr></table></figure>

<p>使用 Transmission 还需要安装 <code>transmission-rpc</code> 用于 FlexGet 和 Transmission 的交互：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip3 install transmission-rpc</span><br></pre></td></tr></table></figure>

<h3 id="FlexGet-配置"><a href="#FlexGet-配置" class="headerlink" title="FlexGet 配置"></a>FlexGet 配置</h3><p>FelxGet 的配置文件位于 <code>~/.config/flexget/config.yml</code>。先看官方的 <a href="https://flexget.com/Configuration">配置指南</a>，我的配置文件如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里关闭 schedules 功能，后续使用 crontab 来实现定时执行</span></span><br><span class="line"><span class="attr">schedules:</span> <span class="literal">no</span></span><br><span class="line"></span><br><span class="line"><span class="attr">templates:</span></span><br><span class="line">  <span class="attr">disklimit:</span></span><br><span class="line">    <span class="comment"># 使用 free_space 插件，指定位置空余空间大于 space (单位为 MB) 时才执行任务</span></span><br><span class="line">    <span class="comment"># https://flexget.com/Plugins/free_space</span></span><br><span class="line">    <span class="attr">free_space:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/home/ubuntu/rss/</span></span><br><span class="line">      <span class="attr">space:</span> <span class="number">10240</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用 content_size 插件，只接受内容大小在 min 到 max (单位为 MB) 之间的 torrent</span></span><br><span class="line">    <span class="comment"># https://flexget.com/Plugins/content_size</span></span><br><span class="line">    <span class="attr">content_size:</span></span><br><span class="line">      <span class="attr">min:</span> <span class="number">1024</span></span><br><span class="line">      <span class="attr">max:</span> <span class="number">30720</span></span><br><span class="line">      <span class="attr">strict:</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">qb:</span></span><br><span class="line">    <span class="comment"># qBittorent 插件配置模板</span></span><br><span class="line">    <span class="comment"># https://flexget.com/Plugins/qbittorrent</span></span><br><span class="line">    <span class="attr">qbittorrent:</span></span><br><span class="line">      <span class="comment"># 下载保存路径</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/home/ubuntu/rss/</span></span><br><span class="line">      <span class="comment"># 设置下载分类</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">rss</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">      <span class="comment"># 设置单种最大下载/上传速度</span></span><br><span class="line">      <span class="attr">maxdownspeed:</span> <span class="number">30000</span></span><br><span class="line">      <span class="attr">maxupspeed:</span> <span class="number">10000</span></span><br><span class="line">      <span class="comment"># 若在 WebUI 的设置界面勾选了「对本地主机上的客户端跳过身份验证」，可省略用户名和密码</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">adminadmin</span></span><br><span class="line">  <span class="attr">tr:</span></span><br><span class="line">    <span class="comment"># Transmission 插件配置模板</span></span><br><span class="line">    <span class="comment"># https://flexget.com/Plugins/transmission</span></span><br><span class="line">    <span class="attr">transmission:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/home/ubuntu/rss/</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">9091</span></span><br><span class="line">      <span class="attr">max_up_speed:</span> <span class="number">10000</span></span><br><span class="line">      <span class="attr">max_down_speed:</span> <span class="number">30000</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">transmission</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">transmission</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想只下载优惠内容可安装 nexusphp 插件</span></span><br><span class="line"><span class="comment"># https://github.com/Juszoe/flexget-nexusphp#site</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 任务设置</span></span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line">  <span class="comment"># 任务名称</span></span><br><span class="line">  <span class="attr">frds:</span></span><br><span class="line">    <span class="comment"># - - - - - - - - - input - - - - - - - - - - - - -</span></span><br><span class="line">    <span class="comment"># PT 站 RSS 地址，需要包含自己的 passkey</span></span><br><span class="line">    <span class="attr">rss:</span> <span class="string">https://pt.keepfrds.com/torrentrss.php?rows=20&amp;passkey=jxxx</span></span><br><span class="line">    <span class="comment"># url 作为标记访问过的条件</span></span><br><span class="line">    <span class="attr">seen:</span></span><br><span class="line">      <span class="attr">fields:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">url</span></span><br><span class="line">    <span class="comment"># - - - - - - - - - filter - - - - - - - - - - - - -</span></span><br><span class="line">    <span class="comment"># 正则表达式过滤规则</span></span><br><span class="line">    <span class="attr">regexp:</span></span><br><span class="line">      <span class="attr">accept:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment"># - - - - - - - - - output - - - - - - - - - - - - -</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">disklimit</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">tr</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">tju:</span></span><br><span class="line">    <span class="attr">rss:</span> <span class="string">https://www.tjupt.org/torrentrss.php?rows=10&amp;passkey=xxx</span></span><br><span class="line">    <span class="attr">seen:</span></span><br><span class="line">      <span class="attr">fields:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">url</span></span><br><span class="line">    <span class="comment"># 接受全部输入</span></span><br><span class="line">    <span class="comment"># https://flexget.com/Plugins/accept_all</span></span><br><span class="line">    <span class="attr">accept_all:</span> <span class="literal">yes</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">disklimit</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">qb</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 自动清理 Transmission 旧种子和数据</span></span><br><span class="line">  <span class="comment"># https://flexget.com/Cookbook/TorrentCleanup</span></span><br><span class="line">  <span class="attr">clean:</span></span><br><span class="line">    <span class="attr">from_transmission:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">9091</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">transmission</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">transmission</span></span><br><span class="line">    <span class="attr">disable:</span> [<span class="string">seen</span>, <span class="string">seen_info_hash</span>]</span><br><span class="line">    <span class="attr">if:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">transmission_progress</span> <span class="string">==</span> <span class="attr">100:</span> <span class="string">accept</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">transmission_secondsSeeding</span> <span class="string">&lt;</span> <span class="attr">86400:</span> <span class="string">reject</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">transmission_ratio</span> <span class="string">&lt;</span> <span class="attr">0.5:</span> <span class="string">reject</span></span><br><span class="line">    <span class="attr">transmission:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">9091</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">transmission</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">transmission</span></span><br><span class="line">      <span class="attr">action:</span> <span class="string">purge</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="FlexGet-测试执行"><a href="#FlexGet-测试执行" class="headerlink" title="FlexGet 测试执行"></a>FlexGet 测试执行</h3><p>防止配置文件错误导致的错误执行，可以使用 <code>--test</code> <a href="https://flexget.com/CLI">选项参数</a>来测试执行，通过其输出可以判断是不是想要执行的。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">flexget --<span class="built_in">test</span> execute --tasks frds</span><br></pre></td></tr></table></figure>

<p>防止 FlexGet 第一次下载时下载 rss 列表中的全部种子，对 <code>execute</code> 命令使用 <code>--learn</code> <a href="https://flexget.com/CLI/execute">命令选项参数</a> 将当前 rss 列表的种子标记为 <code>seen</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">flexget execute --learn --tasks frds</span><br></pre></td></tr></table></figure>

<h2 id="自动清理-qBittorrent-的种子和数据"><a href="#自动清理-qBittorrent-的种子和数据" class="headerlink" title="自动清理 qBittorrent 的种子和数据"></a>自动清理 qBittorrent 的种子和数据</h2><p>FlexGet 目前还没有读取 qBittorrent 种子列表的插件，所以无法直接清理种子和下载的文件，若有此需要，可以使用 <a href="https://github.com/jerrymakesjelly/autoremove-torrents.git"><code>autoremove-torrents</code></a> 工具来实现，具体详见其 <a href="https://autoremove-torrents.readthedocs.io/zh_CN/latest/index.html">官方文档</a>。我使用 qBittorrent 时配置的 config 如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ~/.config/autoremove-torrents/config.yml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 任务名称</span></span><br><span class="line"><span class="attr">qbtask:</span></span><br><span class="line">  <span class="attr">client:</span> <span class="string">qbittorrent</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">http://127.0.0.1:8080</span></span><br><span class="line">  <span class="comment"># 若在 WebUI 的设置界面勾选了「对本地主机上的客户端跳过身份验证」，可省略用户名和密码</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">adminadmin</span></span><br><span class="line">  <span class="attr">strategies:</span></span><br><span class="line">    <span class="comment"># 删除策略名称</span></span><br><span class="line">    <span class="attr">rm_old:</span></span><br><span class="line">      <span class="attr">categories:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">rss</span></span><br><span class="line">      <span class="attr">remove:</span> <span class="string">create_time</span> <span class="string">&gt;</span> <span class="number">86400</span> <span class="string">or</span> <span class="string">(seeding_time</span> <span class="string">&gt;</span> <span class="number">28800</span> <span class="string">and</span> <span class="string">connected_leecher</span> <span class="string">&lt;</span> <span class="number">5</span><span class="string">)</span></span><br><span class="line">    <span class="attr">rm_dead:</span></span><br><span class="line">      <span class="attr">categories:</span> <span class="string">rss</span></span><br><span class="line">      <span class="attr">remove:</span> <span class="string">create_time</span> <span class="string">&gt;</span> <span class="number">1000 </span><span class="string">and</span> <span class="string">average_downloadspeed</span> <span class="string">&lt;</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">rm_stalled:</span></span><br><span class="line">      <span class="attr">categories:</span> <span class="string">rss</span></span><br><span class="line">      <span class="attr">status:</span> <span class="string">StalledDownload</span></span><br><span class="line">      <span class="attr">remove:</span> <span class="string">progress</span> <span class="string">&lt;</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">delete_data:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>在该配置文件所在目录执行 <code>autoremove-torrents --view</code> 可以测试执行而不真正删除种子及数据。</p>
<h2 id="定时执行任务"><a href="#定时执行任务" class="headerlink" title="定时执行任务"></a>定时执行任务</h2><p>运行 <code>flexget execute --task frds</code> 即立刻执行一次 <code>frds</code> 任务，要实现定时自动执行相关任务，可使用 <code>cron</code> 来实现。</p>
<p>运行 <code>crontab -e</code> 来编辑 crontab 实现 <a href="https://flexget.com/InstallWizard/Partial/Crontab">定时执行任务</a>，我编辑的内容如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开机自启 qBittorrent</span></span><br><span class="line">@reboot /usr/bin/qbittorrent-nox -d</span><br><span class="line"><span class="comment"># 每半小时执行一次 autoremove-torrents 工具，--conf 指定文件 --log 指定保存 log 文件夹</span></span><br><span class="line">*/30  *  *  *  *  /home/ubuntu/.local/bin/autoremove-torrents --conf=/home/ubuntu/.config/autoremove-torrents/config.yml --<span class="built_in">log</span>=/home/ubuntu/.config/autoremove-torrents</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每十分钟执行一次 clean 和 frds 任务</span></span><br><span class="line">*/10  *  *  *  *  /home/ubuntu/.local/bin/flexget --cron execute --tasks clean frds</span><br></pre></td></tr></table></figure>

<hr>
<p>关于 FlexGet 更多详细用法可见 <a href="https://flexget.com/Cookbook">官方 Cookbook</a>。</p>
]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>Practice</tag>
      </tags>
  </entry>
  <entry>
    <title>FRP 内网穿透应用 - SSH</title>
    <url>/posts/frp/</url>
    <content><![CDATA[<p>学校 PC 没有独立公网 IP， 这样在学校外部网络就无法 SSH 连接。如果有某台服务器（比如用来搭建博客的服务器，阿里云等）是有公网 IP 的，就可以利用 <a href="https://github.com/fatedier/frp">frp</a> 和这台服务器来实现内网穿透，来达到校外通过 SSH 访问学校内网 PC 的目的。</p>
<span id="more"></span>

<h1 id="frp-服务器配置"><a href="#frp-服务器配置" class="headerlink" title="frp 服务器配置"></a>frp 服务器配置</h1><h2 id="下载-frp"><a href="#下载-frp" class="headerlink" title="下载 frp"></a>下载 frp</h2><p>在有公网 IP 的服务器上，下载 <a href="https://github.com/fatedier/frp/releases">frp 最新 release</a>，并解压到 <code>/opt</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wegt https://github.com/fatedier/frp/releases/download/v0.27.0/frp_0.27.0_linux_amd64.tar.gz</span><br><span class="line">sudo tar -xvf frp_0.27.0_linux_amd64.tar.gz -C /opt</span><br><span class="line">sudo <span class="built_in">mv</span> /opt/frp_0.27.0_linux_amd64 /opt/frp</span><br></pre></td></tr></table></figure>

<h2 id="启用-frps-服务"><a href="#启用-frps-服务" class="headerlink" title="启用 frps 服务"></a>启用 frps 服务</h2><p>修改 <code>/opt/frp/systemd/frps.service</code> 中的文件路径 (第 10 行) 为</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ExecStart=/opt/frp/frps -c /opt/frp/frps.ini</span><br></pre></td></tr></table></figure>

<p>然后执行以下命令，启用 frps 服务</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /opt/frp/systemd/frps.service /etc/systemd/system/</span><br><span class="line">sudo service frps start</span><br></pre></td></tr></table></figure>
<p>这样就完成了服务器端的配置。</p>
<h1 id="frp-客户端配置"><a href="#frp-客户端配置" class="headerlink" title="frp 客户端配置"></a>frp 客户端配置</h1><p>客户端即你想在校外访问的 PC ，配置方法与服务器端配置类似，注意以下操作都是在客户端进行。</p>
<h2 id="内网-PC-下载-frp"><a href="#内网-PC-下载-frp" class="headerlink" title="内网 PC 下载 frp"></a>内网 PC 下载 frp</h2><p>参见 <a href="#frp-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE">frp 服务器配置</a> 中的 <a href="#%E4%B8%8B%E8%BD%BD-frp">下载 frp</a></p>
<h2 id="修改-frpc-ini"><a href="#修改-frpc-ini" class="headerlink" title="修改 frpc.ini"></a>修改 frpc.ini</h2><p>修改 <code>/opt/frp/frpc.ini</code> 如下</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = <span class="number">1.1</span>.<span class="number">1.1</span></span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[ssh]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">22</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">22000</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>server_addr</code> 为你的服务器公网 ip 或者绑定的域名，也可以使用其他人提供的 <a href="http://www.frps.top/">免费 frp 服务器</a>。<br><code>remote_port</code> 为端口号，可设置为任何不冲突端口号（如 22000），后续外网访问内网 PC 就是使用此端口号。</p>
<h2 id="启用-frpc-服务"><a href="#启用-frpc-服务" class="headerlink" title="启用 frpc 服务"></a>启用 frpc 服务</h2><p>修改 <code>/opt/frp/systemd/frpc.service</code> 中的文件路径 (第 10，11 行) 为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExecStart=/opt/frp/frpc -c /opt/frp/frpc.ini</span><br><span class="line">ExecReload=/opt/frp/frpc reload -c /opt/frp/frpc.ini</span><br></pre></td></tr></table></figure>
<p>然后执行以下命令，启用 frpc 服务</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /opt/frp/systemd/frps.service /etc/systemd/system/</span><br><span class="line">sudo service frps start</span><br></pre></td></tr></table></figure>
<p>这样就完成了客户端的配置。</p>
<h1 id="外网访问"><a href="#外网访问" class="headerlink" title="外网访问"></a>外网访问</h1><h2 id="现在就可以使用-SSH-外网连接内网-PC-了，端口号和上面配置的相对应就行。"><a href="#现在就可以使用-SSH-外网连接内网-PC-了，端口号和上面配置的相对应就行。" class="headerlink" title="现在就可以使用 SSH 外网连接内网 PC 了，端口号和上面配置的相对应就行。"></a>现在就可以使用 SSH 外网连接内网 PC 了，端口号和上面配置的相对应就行。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh deng@1.1.1.1 -P 22000</span><br></pre></td></tr></table></figure></h2><p>更多 frp 的相关应用可以查看 <a href="https://github.com/fatedier/frp/blob/master/README_zh.md">官方文档</a>。</p>
]]></content>
      <categories>
        <category>Practice</category>
      </categories>
      <tags>
        <tag>Practice</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<span id="more"></span>

<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>使用 Travis CI 自动构建 Hexo 博客</title>
    <url>/posts/hexo-with-travis-ci/</url>
    <content><![CDATA[<p><a href="https://travis-ci.com/">Travis CI</a> 提供的持续集成服务可以在我们将 Commit push 到 Github 后自动执行用户定义的一系列任务。这里记录一下使用 Travis CI 对 Hexo 静态博客自动部署到 Github Pages 的过程。</p>
<span id="more"></span>

<h2 id="设置-Travis-CI"><a href="#设置-Travis-CI" class="headerlink" title="设置 Travis CI"></a>设置 Travis CI</h2><p>使用 GitHub 登录 <a href="https://travis-ci.com/">Travis CI</a>，会自动读取 GitHub repositories 信息。Travis CI 的原理是在虚拟机 clone 对应的 GitHub repository 并进入该目录下执行用户在配置文件中定义的一些过程。而 Travis CI 的虚拟机默认是不具备我们 GitHub Pages 对应的 repository 的写权限的，所以需要提供 Access token，这里在 <a href="https://github.com/settings/tokens">GitHub 设置</a> 里点击「Generate new token」建一个 Access token，权限只需要选择 <code>public_repo</code> 即可。然后将该 token 添加到 Travis CI 对应 repo 设置里的「Environment Variables」处，如下图：<br><img src="https://raw.githubusercontent.com/csJd/res/master/pic/image.ieihyyw7zge.png" alt="image"><br><code>NAME</code> 处填 <code>GITHUB_TOKEN</code>， <code>VALUE</code> 处填刚才复制的 token，点击右方「Add」就可以添加环境变量 <code>GITHUB_TOKEN</code>，这个在后面会用到</p>
<h2 id="编辑-travis-yml"><a href="#编辑-travis-yml" class="headerlink" title="编辑 .travis.yml"></a>编辑 <code>.travis.yml</code></h2><p>在 Hexo 站点源文件根目录新建 <code>.travis.yml</code> 文件，比如我的 Hexo 站点源文件托管在 <a href="https://github.com/csJd/csJd.github.io">个人 GitHub Pages repo</a> 的 <code>hexo</code> branch，而生成的静态博客内容在 <code>master</code> branch，则设置 <code>.travis.yml</code> 文件内容如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Travis CI for hexo on GitHub Pages</span></span><br><span class="line"></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span> <span class="string">stable</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Build on which branches</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hexo</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="comment"># install pandoc which is required by `hexo-renderer-pandoc`</span></span><br><span class="line">  <span class="comment"># - wget https://github.com/jgm/pandoc/releases/download/2.7.3/pandoc-2.7.3-1-amd64.deb</span></span><br><span class="line">  <span class="comment"># - sudo dpkg -i pandoc-2.7.3-1-amd64.deb</span></span><br><span class="line">  <span class="comment"># `npm ci` is better than `npm install` on CI</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">ci</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># deply to GitHub Pages https://docs.travis-ci.com/user/deployment/pages/</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">pages</span></span><br><span class="line">  <span class="attr">local_dir:</span> <span class="string">public/</span></span><br><span class="line">  <span class="attr">target_branch:</span> <span class="string">master</span>  <span class="comment"># branch for GitHub Page</span></span><br><span class="line">  <span class="attr">skip_cleanup:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">committer_from_gh:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Set in the settings page of your repository, as a secure variable</span></span><br><span class="line">  <span class="attr">github_token:</span> <span class="string">$GITHUB_TOKEN</span></span><br><span class="line">  <span class="attr">keep_history:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">on:</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">hexo</span>  <span class="comment"># branch for the source files</span></span><br></pre></td></tr></table></figure>

<h2 id="Push-to-GitHub"><a href="#Push-to-GitHub" class="headerlink" title="Push to GitHub"></a>Push to GitHub</h2><p>编辑好 <code>.travis.yml</code> 文件后，push 到 GitHub，Travis CI 就会自动触发构建过程，相当于我们本地执行了 <code>hexo g -d</code>。后续每次只用编辑 blog 的 markdown 源文件，每次 push 到 GitHub，Travis CI 都会帮我们完成构建过程，跨设备编辑也变得更加方便，本机都可以不用安装 <code>hexo</code>，<code>node.js</code> 之类的了。<br>Travis CI 构建成功的 <a href="https://travis-ci.com/csJd/csJd.github.io">状态</a> 如下图：<br><img src="https://raw.githubusercontent.com/csJd/res/master/pic/image.qg9k3370t5a.png" alt="image"></p>
]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>Practice</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 iptables 设置防火墙</title>
    <url>/posts/iptables/</url>
    <content><![CDATA[<p>Lightsail 的网络管理界面可以控制端口的开启和关闭，不想开放所有端口，每次服务器上安装的新的服务都需要去管理界面开启新的端口也比较麻烦，就了解了一下使用 <code>iptables</code> 直接通过 <code>ssh</code> 终端来设置防火墙。</p>
<span id="more"></span>

<p>关于 <code>iptables</code> 的相关概念可以参考 <a href="https://www.howtogeek.com/177621/the-beginners-guide-to-iptables-the-linux-firewall">这篇文章</a> 以及 <a href="https://help.ubuntu.com/community/IptablesHowTo">Ubuntu 提供的 Wiki</a>。</p>
<p>我进行的设置如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 清除现有的防火墙配置</span></span><br><span class="line">sudo iptables -F</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许 localhost 的 packet</span></span><br><span class="line">sudo iptables -A INPUT -i lo -j ACCEPT</span><br><span class="line"><span class="comment"># 允许已建立连接的相关 packet</span></span><br><span class="line">sudo iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line"><span class="comment"># 允许 22 端口的 TCP 传入连接，用于 SSH</span></span><br><span class="line">sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT</span><br><span class="line"><span class="comment"># 允许 icmp packet，用于 ping</span></span><br><span class="line">sudo iptables -A INPUT -p icmp -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认规则，需放到最后</span></span><br><span class="line">sudo iptables -P INPUT DROP  <span class="comment"># 禁止其他传入连接</span></span><br><span class="line">sudo iptables -P OUTPUT ACCEPT  <span class="comment"># 允许所有传出连接</span></span><br><span class="line">sudo iptables -P FORWARD ACCEPT  <span class="comment"># 允许所有传出连接</span></span><br></pre></td></tr></table></figure>

<p>执行 <code>sudo iptables -L -v</code> 查看当前的防火墙设置信息，我的结果如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Chain INPUT (policy DROP 206 packets, 25286 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line">  100 10560 ACCEPT     all  --  lo     any     anywhere             anywhere</span><br><span class="line"> 1330  161K ACCEPT     all  --  any    any     anywhere             anywhere             state RELATED,ESTABLISHED</span><br><span class="line">    3   148 ACCEPT     tcp  --  any    any     anywhere             anywhere             tcp dpt:ssh</span><br><span class="line">    1    84 ACCEPT     icmp --  any    any     anywhere             anywhere</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 440 packets, 53272 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br></pre></td></tr></table></figure>

<p>想禁止 <code>ping</code>，则可删除 <code>INPUT</code> 下的对应规则：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo iptables -D INPUT 4                   <span class="comment"># 按规则对应序号删除</span></span><br><span class="line">sudo iptables -D INPUT -p icmp -j ACCEPT   <span class="comment"># 按详细规则内容删除</span></span><br></pre></td></tr></table></figure>

<p>这样设置的防火墙规则都是临时的，重启后就会失效，<code>iptables-save</code> 可以手动导出当前配置到 <code>stdout</code>，<code>iptables-restore</code> 可从文件手动恢复导出的配置。<br>安装 <code>iptables-persistent</code> 工具包可实现防火墙设置的持久化管理：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt install iptables-persistent</span><br><span class="line">sudo iptables-save &gt; /etc/iptables/rules.v4</span><br></pre></td></tr></table></figure>

<p>这样重启后防火墙的配置也会保留，更新防火墙配置后仍需手动运行 <code>sudo iptables-save &gt; /etc/iptables/rules.v4</code> 保存更新的配置。</p>
]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>Practice</tag>
      </tags>
  </entry>
  <entry>
    <title>我的 Gradle 使用实践（零）</title>
    <url>/posts/my-gradle-practice-0/</url>
    <content><![CDATA[<p>Gradle 是一款非常强大的构建工具，最近学习了下 Gradle 的基础使用，这里记录下我的使用实践。</p>
<span id="more"></span>

<h2 id="一-安装-Gradle"><a href="#一-安装-Gradle" class="headerlink" title="一. 安装 Gradle"></a>一. 安装 Gradle</h2><p><a href="https://gradle.org/install#manually">安装 Gradle</a> 直接去官网下载 <a href="https://gradle.org/releases">最新 zip 包</a>，解压到某个文件夹，然后添加环境变量<code>GRADLE_HOME</code>，内容为你解压文文件夹的路径，此目录下含有 <code>bin</code> 文件夹。然后再将 <code>%GRADLE_HOME%\bin</code> 添加到 PATH 变量中，cmd 执行 <code>gradle -v</code>，类似下图则安装成功：<br><img src="http://upload-images.jianshu.io/upload_images/1281889-dcb4090d1cc75b47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="二-构建简单的-Java-项目"><a href="#二-构建简单的-Java-项目" class="headerlink" title="二. 构建简单的 Java 项目"></a>二. 构建简单的 Java 项目</h2><p>安装成功后在工作目录创建 <code>gradle-java</code> 目录，在此目录下使用 Gradle 进行简单 Java 项目的实践。</p>
<h3 id="1-初始化项目框架"><a href="#1-初始化项目框架" class="headerlink" title="1. 初始化项目框架"></a>1. 初始化项目框架</h3><p>执行 <code>gradle tasks</code> 可以查看当前目录的 Gradle 项目可用的所有 Gradle 任务：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1281889-40b52c339ca38589.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><code>init</code> 任务可以理解为创建 Gradle 工程初始骨架，可以输入 <code>gradle help --task init</code> 查看帮助：<br><img src="http://upload-images.jianshu.io/upload_images/1281889-264ba01db2bc954b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>我们执行以下命令就是初始化一个 Java 项目:</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">gradle init --type java-application</span><br></pre></td></tr></table></figure>
<p>执行完毕后目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gradle-java</span><br><span class="line">│  build.gradle</span><br><span class="line">│  gradlew</span><br><span class="line">│  gradlew.bat</span><br><span class="line">│  settings.gradle</span><br><span class="line">│</span><br><span class="line">├─gradle</span><br><span class="line">│  └─wrapper</span><br><span class="line">│          gradle-wrapper.jar</span><br><span class="line">│          gradle-wrapper.properties</span><br><span class="line">│</span><br><span class="line">└─src</span><br><span class="line">    ├─main</span><br><span class="line">    │  └─java</span><br><span class="line">    │          App.java</span><br><span class="line">    │</span><br><span class="line">    └─test</span><br><span class="line">        └─java</span><br><span class="line">                AppTest.java</span><br></pre></td></tr></table></figure>
<p>Gradle 完成了项目基本骨架的创建。</p>
<h3 id="2-运行项目"><a href="#2-运行项目" class="headerlink" title="2. 运行项目"></a>2. 运行项目</h3><p>App.java 文件内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This Java source file was generated by the Gradle &#x27;init&#x27; task.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGreeting</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello world.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">App</span>().getGreeting());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时执行 <code>gradle tasks</code> 看看这个项目 Gradle 能执行哪些任务：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1281889-020874c8c72f932d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以看到多了很多新任务，后面再讨论为什么，执行 <code>gradle run</code> 看看：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1281889-cdecacfce14764a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>没错，<code>run</code> 任务完成了编译运行工作。</p>
]]></content>
      <categories>
        <category>Practice</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>我的 Gradle 使用实践（一）</title>
    <url>/posts/my-gradle-practice-1/</url>
    <content><![CDATA[<p>上面已经成功执行了一个使用 Gradle 的 Java 项目，下面大概介绍一下原理，官方也给出了详细的 <a href="https://guides.gradle.org/creating-java-applications/">Getting Started</a>。</p>
<span id="more"></span>

<h2 id="一-build-gradle-plugin"><a href="#一-build-gradle-plugin" class="headerlink" title="一. build.gradle - plugin"></a>一. build.gradle - plugin</h2><p>为什么 <code>init</code> 后能执行一些新的任务，这是由 <strong>build.gradle</strong> 文件决定的，我们打开这个文件可以看到：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This build file was generated by the Gradle &#x27;init&#x27; task.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This generated file contains a sample Java project to get you started.</span></span><br><span class="line"><span class="comment"> * For more details take a look at the Java Quickstart chapter in the Gradle</span></span><br><span class="line"><span class="comment"> * user guide available at https://docs.gradle.org/3.4.1/userguide/tutorial_java_projects.html</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the java plugin to add support for Java</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;java&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the application plugin to add support for building an application</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;application&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// In this section you declare where to find the dependencies of your project</span></span><br><span class="line">repositories &#123;</span><br><span class="line">    <span class="comment">// Use jcenter for resolving your dependencies.</span></span><br><span class="line">    <span class="comment">// You can declare any Maven/Ivy/file repository here.</span></span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// This dependency is found on compile classpath of this component and consumers.</span></span><br><span class="line">    compile <span class="string">&#x27;com.google.guava:guava:20.0&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use JUnit test framework</span></span><br><span class="line">    testCompile <span class="string">&#x27;junit:junit:4.12&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the main class for the application</span></span><br><span class="line">mainClassName = <span class="string">&#x27;App&#x27;</span></span><br></pre></td></tr></table></figure>

<p>里面注释已经给得挺详细，之所以能够构建 java 项目，是因为 <code>apply plugin: &#39;java&#39;</code> 这句话，也就是应用 Gradle 提供的 Java 插件，这个插件能提供构建 Java 项目的任务，如 <code>compileJava</code>, <code>jar</code>, <code>build</code> 等，想详细了解可查看 <a href="https://docs.gradle.org/3.4.1/userguide/java_plugin.html">官方文档</a>。</p>
<p>同样的，<code>apply plugin: application</code> 是应用 Gradle 给出的运行 Java 应用的插件（<a href="https://docs.gradle.org/3.4.1/userguide/application_plugin.html">官方文档</a>），它提供了 <code>run</code> 任务，我们必须主动声明 Java 应用的主类，可以看到 <code>build.gradle</code> 里最后一句代码 <code>mainClassName = &#39;App&#39;</code>，是在声明这个 Java Application 的主类是 <code>./src/main/java/</code> 目录下的 App 类，我们修改 <strong>App.java</strong> 里的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGreeting</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello world, hello Gradle!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">App</span>().getGreeting());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再执行 <code>gradle run</code> 可以看到：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1281889-e20543a15366d08b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我们可以去编写我们的项目，然后 <code>gradle run</code> 就能运行了，正是 Gradle plugins 提供了这些功能，关于 plugin 的详细介绍可查阅 <a href="https://docs.gradle.org/3.4.1/userguide/plugins.html">官方文档</a>。</p>
<h2 id="二-build-gradle-repositories"><a href="#二-build-gradle-repositories" class="headerlink" title="二. build.gradle - repositories"></a>二. build.gradle - repositories</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    <span class="comment">// Use jcenter for resolving your dependencies.</span></span><br><span class="line">    <span class="comment">// You can declare any Maven/Ivy/file repository here.</span></span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里指定 Gradle 下载依赖的仓库，兼容 Maven 仓库，以上代码是使用<code>jcenter</code>仓库作为依赖下载仓库，常见的仓库有：</p>
<ul>
<li><a href="http://search.maven.org/">The Central Repository</a> （Maven 中央仓库）<br>在<code>repositories</code>块中加入<code>mavenCentral()</code>可使用此仓库，此仓库国内下载较慢</li>
<li><a href="https://bintray.com/bintray/jcenter">Jcenter</a> （JFrog 公司提供的仓库）<br>在<code>repositories</code>块中加入<code>jcenter()</code>可使用此仓库，新版 Gralde 和 Android Studio 默认仓库，国内下载比中央仓库快。</li>
<li>自定义仓库<br>Gradle 兼容 Maven 仓库和 Ivy 仓库，如在<code>repositories</code>块中加入一下内容就添加了一个自定义 <code>url</code>的 Maven 仓库：</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">maven &#123;</span><br><span class="line">        url <span class="string">&quot;http://repo.mycompany.com/maven2&quot;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>url</code>也可以是本地路径。</p>
<p>关于 repositories 的更多内容可查阅 <a href="https://docs.gradle.org/3.4.1/userguide/artifact_dependencies_tutorial.html#sec:repositories_tutoria">官方文档</a>。</p>
<h2 id="三-build-gradle-dependencies"><a href="#三-build-gradle-dependencies" class="headerlink" title="三. build.gradle - dependencies"></a>三. build.gradle - dependencies</h2><p>这就是 Gradle 项目管理依赖的地方，非常方便，添加某个依赖只需要在 <code>dependencies</code> 块中加入一行代码：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">compile <span class="string">&#x27;group:name:version&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如 <strong>build.gradle</strong> 中默认添加了 <code>guava</code> 作为依赖和 <code>junit</code> 作为测试时（执行 <code>gradle test</code> 任务时）的依赖</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">compile <span class="string">&#x27;com.google.guava:guava:20.0&#x27;</span></span><br><span class="line">testCompile <span class="string">&#x27;junit:junit:4.12&#x27;</span></span><br></pre></td></tr></table></figure>
<p>作为实践，我们现在要在项目中输出一个 <code>Json</code> 数组，需要 <a href="http://json.org/">http://json.org</a> 提供的 <code>json.jar</code> 依赖，我们直接去 <a href="https://bintray.com/bintray/jcenter">Jcenter</a>搜索依赖，如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1281889-b0e48588e1bd9920.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>点击搜索出的结果即进入 <a href="https://bintray.com/bintray/jcenter/org.json:json">详细界面</a>，可以看到其给出的 Gradle 依赖语句：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">compile <span class="string">&#x27;org.json:json:20160810&#x27;</span></span><br></pre></td></tr></table></figure>
<p>我们把这个加到 <code>dependencies</code> 块中，就是添加了 <code>json</code> 依赖，不用我们自己再去官网下载 <code>jar</code> 文件加入 <code>lib</code>。<br>编辑 <code>App.java</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.json.JSONArray;</span><br><span class="line"><span class="keyword">import</span> org.json.JSONObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGreeting</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello world, hello Gradle!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">App</span>().getGreeting());</span><br><span class="line"></span><br><span class="line">        <span class="type">JSONArray</span> <span class="variable">ja</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONArray</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)&#123;</span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">jo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">            jo.put(<span class="string">&quot;hello gradle!&quot;</span>,i);</span><br><span class="line">            ja.put(jo);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ja.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后执行 <code>gradle run</code> 任务：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1281889-7138a25ea4e025e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>第一次执行 gradle 会去下载依赖缓存到本地，以后的项目用到相同的依赖就不用再下载了。<br>关于 Gradle 依赖管理的详细内容可查看 <a href="https://docs.gradle.org/3.4.1/userguide/artifact_dependencies_tutorial.html">官方文档</a>。</p>
]]></content>
      <categories>
        <category>Practice</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>我的 Hexo 使用实践（二）</title>
    <url>/posts/my-practice-with-hexo-2/</url>
    <content><![CDATA[<p>将 Blog 成功搭到 Github 后就要考虑一些配置问题了，需要更加美观的主题，换了电脑或者重装系统后还需要快速的从以前的配置恢复，下面就解决这些问题。</p>
<span id="more"></span>

<h2 id="一-设置主题"><a href="#一-设置主题" class="headerlink" title="一. 设置主题"></a>一. 设置<a href="https://hexo.io/themes/">主题</a></h2><p>Hexo 官网就提供了很多<a href="https://hexo.io/themes/">主题</a>，我是用的是<a href="http://theme-next.iissnan.com/">NexT 主题</a>，简单大方且不失美观，以下以 NexT 主题为例，其余主题也类似。</p>
<h3 id="1-下载-NexT"><a href="#1-下载-NexT" class="headerlink" title="1. 下载 NexT"></a>1. 下载 NexT</h3><p>推荐使用<a href="https://github.com/iissnan/hexo-theme-next/releases">最新稳定版本</a>,下载后解压到你的站点目录下的 <code>themes</code> 目录下，并将 解压后的文件夹名称（hexo-theme-next-5.0.1）更改为  next。</p>
<h3 id="2-使用-NexT"><a href="#2-使用-NexT" class="headerlink" title="2. 使用 NexT"></a>2. 使用 NexT</h3><p>下载并重命名后将站点配置文件（站点目录下的 <strong>_config.yml</strong> 文件）中的 theme 属性修改为 next，再次执行 <code>hexo g -d</code>，Blog 就应用新主题了。<br>在站点目录下的 <code>themes\next</code> 目录下也有 <strong>_config.yml</strong> 文件，是 NexT 主题的主题配置文件，关于其详细配置和问题可参考<a href="http://theme-next.iissnan.com/getting-started.html#theme-settings">官方文档</a>和官方 <a href="https://github.com/iissnan/hexo-theme-next/wiki/%E5%88%9B%E5%BB%BA%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2">Github Wiki</a>。</p>
<h2 id="二-配置信息同步"><a href="#二-配置信息同步" class="headerlink" title="二. 配置信息同步"></a>二. 配置信息同步</h2><p>可以发现，<code>hexo d</code> 只将站点显示所需文件 push 到了 github master 分支，markdown 源文件以及 hexo 配置文件等都只在本地，我们在系统重装或者换电脑后再次搭建就失去了原来的配置以及源文件。要想多端同步和重装后快速恢复，比较好的解决方法就是将这些源文件和配置文件也上传到 Github Repo，刚好 <code>hexo g</code> 已经提供了 <strong>.gitignore</strong> 文件，就是用于我们把整个站点 push 到 GitHub 上去的。</p>
<h3 id="1-建立-hexo-分支"><a href="#1-建立-hexo-分支" class="headerlink" title="1. 建立 hexo 分支"></a>1. 建立 hexo 分支</h3><p>由于 GitHub 上 master 分支管理的是站点显示文件，这是由 <code>hexo d</code> 命令来部署的，我们需要再建一个 hexo 分支来管理 Hexo 的配置文件和站点源文件，我们手动管理这个分支。<br>执行以下命令就完成了新分支的创建：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch hexo     <span class="comment">#本地新建hexo分支</span></span><br><span class="line">git checkout hexo   <span class="comment">#切换到hexo</span></span><br><span class="line">git add .           <span class="comment">#添加站点文件到git</span></span><br><span class="line">git commit -m <span class="string">&quot;add hexo branch&quot;</span>     <span class="comment">#提交修改</span></span><br><span class="line">git push origin hexo    <span class="comment">#push本地更改到GitHub Repo</span></span><br></pre></td></tr></table></figure>
<p>此时在 Github 上就看到了新的分支 hexo，在 Github 上修改 Default branch 为 hexo 分支，这样我们以后的手动 push 默认就是 hexo 分支了，正是我们所想要的。<br>类似的，还可以建立 res 分支存放图片等资源文件，这样就不用把这些文件放 <code>source</code> 文件夹中了，clone 的内容也更少了。像上篇文章的图片地址为 <a href="https://github.com/csJd/csJd.github.io/raw/res/My-Practice-with-Hexo.png">https://github.com/csJd/csJd.github.io/raw/res/My-Practice-with-Hexo.png</a>，此图片就放在 res 分支下。</p>
<h3 id="2-恢复配置"><a href="#2-恢复配置" class="headerlink" title="2. 恢复配置"></a>2. 恢复配置</h3><p>以后在新的 PC 获重装系统后要编辑博客时只用安装 git 和 node.js，然后 clone 你的 Github Repo：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:csJd/csJd.github.io.git</span><br></pre></td></tr></table></figure>
<p>进入站点文件夹（<em>yourGithubUserName.github.io</em>文件夹），输入以下命令就恢复以前的环境了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g               <span class="comment">#安装hexo</span></span><br><span class="line">npm install                           <span class="comment">#安装模块到node_modules</span></span><br></pre></td></tr></table></figure>
<p>然后就可以像以前一样在 <code>source/_posts</code> 文件夹编写博客，使用 <code>hexo g -d</code> 即可发布到 GitHub Pages。</p>
]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>Practice</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>我的 Hexo 使用实践（一）</title>
    <url>/posts/my-practice-with-hexo/</url>
    <content><![CDATA[<p>此博客是由 Github Pages 和 Hexo 搭建的，分享以下我的使用实践。</p>
<h2 id="一-安装-Hexo"><a href="#一-安装-Hexo" class="headerlink" title="一. 安装 Hexo"></a>一. 安装 <a href="https://hexo.io/zh-cn/">Hexo</a></h2><h3 id="1-安装-Node-js-和-Git"><a href="#1-安装-Node-js-和-Git" class="headerlink" title="1. 安装 Node.js 和 Git"></a>1. 安装 Node.js 和 Git</h3><p>必须安装了 Node.js 和 Git 才能安装使用 Hexo，按照 <a href="https://hexo.io/zh-cn/docs/index.html">Hexo 官方提供的教程</a>安装即可，Windows 用户推荐使用安装包安装，安装过程勾选添加到 PATH。</p>
<span id="more"></span>

<h3 id="2-安装-Hexo"><a href="#2-安装-Hexo" class="headerlink" title="2. 安装 Hexo"></a>2. 安装 Hexo</h3><p>使用 npm 一条命令就可完成 Hexo 的安装，Windows 用户推荐使用 Windows 版 Git 提供的 Git Bash 执行此命令即后续所有命令（在随意目录鼠标右键点击空白处就有 Git Bash Here）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h2 id="二-部署到-Github"><a href="#二-部署到-Github" class="headerlink" title="二. 部署到 Github"></a>二. 部署到 Github</h2><h3 id="1-创建你的-Github-Pages-repository"><a href="#1-创建你的-Github-Pages-repository" class="headerlink" title="1. 创建你的 Github Pages repository"></a>1. 创建你的 Github Pages repository</h3><p>在 Github Repositories 点击 New 创建新 Repository，命名为<em>yourGithubUsername.github.io</em>，yourGithubUsername 必须是你的 Github 用户名，如下图。<br><img src="https://github.com/csJd/csJd.github.io/raw/res/My-Practice-with-Hexo.png"><br>点击下方 Create repository 即可完成创建。</p>
<h3 id="2-初始化-Hexo"><a href="#2-初始化-Hexo" class="headerlink" title="2. 初始化 Hexo"></a>2. 初始化 Hexo</h3><p>在你想维护你博客的文件夹下 clone 你刚新建的 repository，使用 https 方式每次 push 都要输入密码，故推荐使用 SSH 方式（可参考此处，<a href="https://help.github.com/articles/which-remote-url-should-i-use/#cloning-with-ssh-urls">Cloning with SSH URLs</a>），在[Github SSH keys 管理界面](Github SSH keys 管理界面)上传你的 PC 的 SSH key 后，就可以使用如下命令 clone。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:csJd/csJd.github.io.git</span><br></pre></td></tr></table></figure>
<p>clone 完成后进入 <em>yourGithubUsername.github.io</em> 文件夹，执行以下命令初始化 Hexo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<h3 id="3-部署到-Github"><a href="#3-部署到-Github" class="headerlink" title="3. 部署到 Github"></a>3. 部署到 Github</h3><p>进入 <em>yourGithubUsername.github.io</em> 文件夹，编辑站点配置文件 <strong>_config.yml</strong>，最下 deploy 处改为如下，username 替换为你的 GitHub 用户名。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:username/username.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<p>改好后输入以下命令即可部署到 GitHub</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>
<p>稍等一会，访问 <a href="https://yourgithubusername.github.io/">https://yourGithubUsername.github.io</a>，就能看到 Hexo 的初始页面。<br>关于 <code>_config.yml</code> 的详细配置可参考<a href="https://hexo.io/zh-cn/docs/configuration.html">官方文档</a>。</p>
]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>Practice</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 上使用 zip 包安装 MySQL</title>
    <url>/posts/mysql-zip-install/</url>
    <content><![CDATA[<p>由于重装系统比较频繁，每次都使用安装包安装 MySQL 的话比较麻烦，看到 <a href="https://dev.mysql.com/downloads/mysql/">MySQL 官网</a>提供了 MySQL 的 ZIP Archive，查了下<a href="https://dev.mysql.com/doc/refman/5.7/en/windows-install-archive.html">官方文档</a>，这里记录一下使用 ZIP 包安装 MySQL 的方法。</p>
<span id="more"></span>

<h2 id="1-解压，编辑-my-ini"><a href="#1-解压，编辑-my-ini" class="headerlink" title="1. 解压，编辑 my.ini"></a>1. 解压，编辑 my.ini</h2><p>将下载的 ZIP 包解压到你要安装 MySQL 的文件夹（如：<code>d:/dev/mysql/</code>），然后进入该文件夹，复制 <code>my-default.ini</code> 为 <code>my.ini</code>，编辑 <code>my.ini</code>，在 <code>[mysqld]</code> 下添加如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mysql所在位置，替换为你解压的位置</span></span><br><span class="line">basedir = d:/dev/mysql</span><br><span class="line"><span class="comment"># data文件夹位置，替换为你的解压位置/data</span></span><br><span class="line">datadir = d:/dev/mysql/data</span><br></pre></td></tr></table></figure>

<h2 id="2-初始化-data-文件夹"><a href="#2-初始化-data-文件夹" class="headerlink" title="2. 初始化 data 文件夹"></a>2. 初始化 data 文件夹</h2><p>然后<em>管理员权限</em>打开<em>cmd</em>进入 MySQL 文件夹下的 bin 文件夹，输入以下内容 <a href="https://dev.mysql.com/doc/refman/5.7/en/data-directory-initialization-mysqld.html">初始化 data 文件夹</a>：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">mysqld --initialize-insecure</span><br><span class="line">mysqld -install</span><br></pre></td></tr></table></figure>


<h2 id="3-开启-MySQL-服务"><a href="#3-开启-MySQL-服务" class="headerlink" title="3. 开启 MySQL 服务"></a>3. 开启 MySQL 服务</h2><p>完成以上步骤后，<em>管理员权限</em>在 cmd 输入 <code>net start mysql</code> 即可开启 MySQL 服务，如下图：<br><img src="https://github.com/csJd/csJd.github.io/raw/res/mysql-zip-install-1.png"></p>
<h2 id="4-加入环境变量，设置-root-密码"><a href="#4-加入环境变量，设置-root-密码" class="headerlink" title="4. 加入环境变量，设置 root 密码"></a>4. 加入环境变量，设置 root 密码</h2><p>为了在命令行直接使用 MySQL，需要把 MySQL 文件夹下的 bin 文件夹加入系统环境变量的 PATH 变量，加入即可。root 默认是没有密码的，初次使用时，在 cmd 输入 <code>mysql -u root</code> 即可使用 root 登录 mysql，登入后输入以下命令即可修改 root 密码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; set password = password(&#x27;your_new_password&quot;);</span><br></pre></td></tr></table></figure>
<p>然后就配置完毕了，重装系统后可以直接在 MySQL 文件夹再次配置，不需要再安装安装包。</p>
]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Naive Bayes Review</title>
    <url>/posts/naive-bayes/</url>
    <content><![CDATA[<p>笔试题中遇到了 <a href="https://en.wikipedia.org/wiki/Naive_Bayes_classifier">朴素贝叶斯算法</a> 的实现，这里对朴素贝叶斯算法做个简单回顾。</p>
<span id="more"></span>

<h2 id="朴素贝叶斯算法"><a href="#朴素贝叶斯算法" class="headerlink" title="朴素贝叶斯算法"></a>朴素贝叶斯算法</h2><p>朴素贝叶斯算法是一个相对比较简单的机器学习算法，是基于贝叶斯定理和特征独立假设的分类方法。</p>
<p>对于给定的训练集（设共 $m$ 条训练数据，$n$ 种特征，$t$ 种类别 $0, 1, …, t-1$)</p>
<p>可以先得到各个类别的先验概率分布：</p>
<p>$$<br>P(Y&#x3D;k)&#x3D; |{y_i &#x3D; k }|&#x2F;m, \quad i&#x3D;0, 1, …, m-1 \tag{0}<br>$$</p>
<p>在特征条件独立性假设下， 有条件概率分布：</p>
<p>$$<br>P(X&#x3D;x|Y&#x3D;k)&#x3D;\prod_{j&#x3D;0}^{n-1}P(X^j&#x3D;x^j|Y&#x3D;k) \tag{1}<br>$$</p>
<p>根据贝叶斯定理可以得到后验概率分布：<br>$$<br>P(Y&#x3D;k|X&#x3D;x)&#x3D;\frac{P(Y&#x3D;k)\prod_jP(X^j&#x3D;x^j|Y&#x3D;k)}{\sum_kP(Y&#x3D;k)\prod_jP(X^j&#x3D;x^j|Y&#x3D;k)}<br>\tag{2}<br>$$<br>使得后验概率最大的类别即分类器需要输出的类别，对于输入 $x$，式 $(2)$ 的分母对于所有类别都是相同的，所以朴素贝叶斯分类器可表示为：<br>$$<br>y&#x3D;f(x) &#x3D;\underset{k}{argmax}P(Y&#x3D;k)\prod_jP(X^j&#x3D;x^j|Y&#x3D;k)<br>\tag{3}<br>$$</p>
<h2 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h2><blockquote>
<p>朴素贝叶斯分类器假设在给定样本 label 的情况下，样本的不同特征之间相互独立。<br>现用朴素贝叶斯分类器进行垃圾邮件识别，数据包含 4 个特征。<br>现在将所有的特征进行转换后，得到下表(请在程序以硬编码方式读入);<br>转换规则如下: (注: [m,n]表示m,n之间的闭区间，[m,+]表示大于m的开区间)</p>
<p>标题长度(feature1) : 1: [0,3], 2: [3,6]，3: [6,+] </br><br>正文长度(feature2) : 1: [0,10], 2: [10,20], 3: [20,+] </br><br>附件含有可执行程序(feature3) : 1:是，0:否 </br><br>正文含特殊字符(feature4) : 1:是，0:否 </br></p>
<p>请在程序中读入上述训练数据，实现朴素贝叶斯分类器，语言不限，但不能使用第三方库，<br>不需要考虑平滑方法，然后对给定的测试数据(特征已转换)进行预测，输出结果;</p>
<p>输入描述： </br><br>输入数据如下，第一行一个数字 M，表示共有 M 行训练数据，<br>第 2~M+1 行，每行 5 个数字，分别以空格隔开，前四个数字分别代表四个特征，第<br>5 个数字代表这一个样本 label 值。<br>第 M+2 行是一个数字 N，表示共有 N 行测试样本，随后的 N 行每行 4 个数字，分别代表四个特征的值。</p>
<p>输出描述：</br><br>使用贝叶斯模型对测试样本进行预测，所有结果按顺序输出到一行，以空格分隔;</p>
</blockquote>
<p>对应该笔试题的 Python 代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输入示例：</span></span><br><span class="line"><span class="string">14</span></span><br><span class="line"><span class="string">1 1 1 0 1</span></span><br><span class="line"><span class="string">1 1 1 1 1</span></span><br><span class="line"><span class="string">2 1 1 0 0</span></span><br><span class="line"><span class="string">3 2 1 0 0</span></span><br><span class="line"><span class="string">3 3 0 0 0</span></span><br><span class="line"><span class="string">3 3 0 1 1</span></span><br><span class="line"><span class="string">2 3 0 1 0</span></span><br><span class="line"><span class="string">1 2 1 0 1</span></span><br><span class="line"><span class="string">1 3 0 0 0</span></span><br><span class="line"><span class="string">3 2 0 0 0</span></span><br><span class="line"><span class="string">1 2 0 0 0</span></span><br><span class="line"><span class="string">2 2 1 1 0</span></span><br><span class="line"><span class="string">2 1 0 0 0</span></span><br><span class="line"><span class="string">3 2 1 1 1</span></span><br><span class="line"><span class="string">5</span></span><br><span class="line"><span class="string">1 1 0 0</span></span><br><span class="line"><span class="string">1 1 1 0</span></span><br><span class="line"><span class="string">1 2 1 0</span></span><br><span class="line"><span class="string">2 1 0 1</span></span><br><span class="line"><span class="string">2 2 1 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">输出示例：</span></span><br><span class="line"><span class="string">0 1 1 0 0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    m = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line">    n_values = [<span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">    n_features = <span class="number">4</span></span><br><span class="line">    n_classes = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    X = <span class="built_in">list</span>()</span><br><span class="line">    cnt = [<span class="number">0</span>] * n_classes</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        X.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">        X[-<span class="number">1</span>][<span class="number">0</span>] -= <span class="number">1</span>  <span class="comment"># x[0], x[1] are from 1 here</span></span><br><span class="line">        X[-<span class="number">1</span>][<span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line">        cnt[X[-<span class="number">1</span>][-<span class="number">1</span>]] += <span class="number">1</span>  <span class="comment"># X[-1][-1] is y</span></span><br><span class="line">    p_classes = [X / m <span class="keyword">for</span> X <span class="keyword">in</span> cnt]  <span class="comment"># P(y=class[i])</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># p_values[j][k][v] save the proba of P(Xj=v|y=k)</span></span><br><span class="line">    p_values = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n_features):</span><br><span class="line">        <span class="comment"># save value counts in each class of the j-th feature</span></span><br><span class="line">        value_counts = [[<span class="number">0</span>] * n_values[j] <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(n_classes)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            y = X[i][-<span class="number">1</span>]</span><br><span class="line">            value_counts[y][X[i][j]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># p_values[j][k][v] save the proba of P(Xj=v|y=k)</span></span><br><span class="line">        p_values.append(</span><br><span class="line">            [[value_counts[k][v]/cnt[k] <span class="keyword">if</span> cnt[k] <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">              <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">range</span>(n_values[j])]</span><br><span class="line">             <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n_classes)]</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    ans = <span class="built_in">list</span>()</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        xi = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">        xi[<span class="number">0</span>] -= <span class="number">1</span></span><br><span class="line">        xi[<span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line">        y_pred, maxp = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n_classes):</span><br><span class="line">            p = <span class="number">1</span></span><br><span class="line">            <span class="comment"># to calclate P(x=xi|y=k)</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n_features):</span><br><span class="line">                v = xi[j]</span><br><span class="line">                p *= p_values[j][k][v]</span><br><span class="line">            p *= p_classes[k]</span><br><span class="line">            <span class="keyword">if</span> p &gt; maxp:</span><br><span class="line">                y_pred, maxp = k, p</span><br><span class="line">        ans.append(y_pred)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, ans)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Review</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>在 VPS 上搭建 NOT FOUND Server</title>
    <url>/posts/not-found/</url>
    <content><![CDATA[<p>分享在 Ubuntu 18.04 VPS 上搭建 Shadowsocks Server 的方法。</p>
<span id="more"></span>

<h2 id="一-安装-Shadowsocks"><a href="#一-安装-Shadowsocks" class="headerlink" title="一. 安装 Shadowsocks"></a>一. 安装 Shadowsocks</h2><p>执行以下命令即完成 Shadowsocks 的安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install shadowsocks-libev</span><br></pre></td></tr></table></figure>

<h2 id="二-开启-BBR"><a href="#二-开启-BBR" class="headerlink" title="二. 开启 BBR"></a>二. 开启 BBR</h2><p><a href="https://github.com/google/bbr">BBR</a> 是 Google 提出的较新的 TCP 拥塞控制算法，已集成在了 <code>4.9.0</code> 及更新版本的 Linux 内核中，但需要手动开启。<br>终端输入 <code>sudo vi /etc/sysctl.conf</code> 在最后添加以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net.core.default_qdisc = fq</span><br><span class="line">net.ipv4.tcp_congestion_control = bbr</span><br></pre></td></tr></table></figure>

<p>再执行 <code>sudo sysctl -p</code> 即可开启 BBR，执行 <code>lsmod | grep bbr</code> 可查看是否开启。</p>
<h2 id="三-编辑-Shadowsocks-服务端的配置文件"><a href="#三-编辑-Shadowsocks-服务端的配置文件" class="headerlink" title="三. 编辑 Shadowsocks 服务端的配置文件"></a>三. 编辑 Shadowsocks 服务端的配置文件</h2><p>终端输入 <code>sudo vi /etc/shadowsocks-libev/config.json</code>，修改配置文件内容如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span><span class="string">&quot;0.0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;server_port&quot;</span><span class="punctuation">:</span><span class="number">8388</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span><span class="string">&quot;setYourPassword&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span><span class="number">600</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span><span class="string">&quot;aes-256-gcm&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;mode&quot;</span><span class="punctuation">:</span><span class="string">&quot;tcp_only&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;fast_open&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>密码设置自己的，其余可与以上相同，其中每项的具体作用可查阅 <a href="https://shadowsocks.org/en/config/quick-guide.html">Shadowsocks 官网</a>。</p>
<h2 id="四-开启-Shadowsocks-后台服务"><a href="#四-开启-Shadowsocks-后台服务" class="headerlink" title="四. 开启 Shadowsocks 后台服务"></a>四. 开启 Shadowsocks 后台服务</h2><p>执行以下命令即可开启 Shadowsocks 后台服务：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo service shadowsocks-libev start</span><br></pre></td></tr></table></figure>

<p>开启服务后重启 VPS 该服务也会自动开启，以下命令可以查看服务运行状态：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo service shadowsocks-libev status</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Additional-not-required"><a href="#Additional-not-required" class="headerlink" title="Additional (not required)"></a>Additional (not required)</h2><ul>
<li><p>Using a well-know port (such as 80, 443) might make it more stable</p>
</li>
<li><p>If you have <a href="https://github.com/shadowsocks/v2ray-plugin">v2ray-plugin</a> installed in your server (build or download the compatible version and place it to <code>/usr/local/bin/</code>), add following to <code>config.json</code> of <code>ss-server</code> to enable it</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;plugin&quot;</span><span class="punctuation">:</span><span class="string">&quot;v2ray-plugin&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;plugin_opts&quot;</span><span class="punctuation">:</span><span class="string">&quot;server&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<p>to enalbe well-know ports binding:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">setcap</span> cap_net_bind_service+ep /usr/local/bin/v2ray-plugin</span><br></pre></td></tr></table></figure>
</li>
<li><p>To enable <code>v2ray-plugin</code> in your client:</p>
<ul>
<li>set <code>plugin</code> field as the relative path of <code>v2ray-plugin</code></li>
<li>set <code>plugin_opts</code> field as what you want, keep it empty is ok</li>
</ul>
</li>
<li><p><a href="https://github.com/shadowsocks/shadowsocks/wiki/Optimizing-Shadowsocks">Optimizing</a>  </p>
<p>Append following content to <code>/etc/sysctl.conf</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># max open files</span><br><span class="line"># fs.file-max = 51200</span><br><span class="line"># max read buffer</span><br><span class="line">net.core.rmem_max = 67108864</span><br><span class="line"># max write buffer</span><br><span class="line">net.core.wmem_max = 67108864</span><br><span class="line"># default read buffer</span><br><span class="line"># default read buffer</span><br><span class="line">net.core.rmem_default = 65536</span><br><span class="line"># default write buffer</span><br><span class="line">net.core.wmem_default = 65536</span><br><span class="line"># max processor input queue</span><br><span class="line">net.core.netdev_max_backlog = 4096</span><br><span class="line"># max backlog</span><br><span class="line">net.core.somaxconn = 4096</span><br><span class="line"></span><br><span class="line"># resist SYN flood attacks</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line"># reuse timewait sockets when safe</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line"># turn off fast timewait sockets recycling</span><br><span class="line">net.ipv4.tcp_tw_recycle = 0</span><br><span class="line"># short FIN timeout</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line"># short keepalive time</span><br><span class="line">net.ipv4.tcp_keepalive_time = 1200</span><br><span class="line"># outbound port range</span><br><span class="line">net.ipv4.ip_local_port_range = 10000 65000</span><br><span class="line"># max SYN backlog</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 4096</span><br><span class="line"># max timewait sockets held by system simultaneously</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 5000</span><br><span class="line"># turn on TCP Fast Open on both client and server side</span><br><span class="line">net.ipv4.tcp_fastopen = 3</span><br><span class="line"># TCP receive buffer</span><br><span class="line">net.ipv4.tcp_rmem = 4096 87380 67108864</span><br><span class="line"># TCP write buffer</span><br><span class="line">net.ipv4.tcp_wmem = 4096 65536 67108864</span><br><span class="line"># turn on path MTU discovery</span><br><span class="line">net.ipv4.tcp_mtu_probing = 1</span><br></pre></td></tr></table></figure>

<p>then run:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Tutorials</category>
      </categories>
      <tags>
        <tag>Practice</tag>
        <tag>VPS</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Basic Tutorial</title>
    <url>/posts/python-tutorial/</url>
    <content><![CDATA[<h1 id="Python-Basic-Tutorial（2019-01-26-SCUT）"><a href="#Python-Basic-Tutorial（2019-01-26-SCUT）" class="headerlink" title="Python Basic Tutorial（2019.01.26 @ SCUT）"></a>Python Basic Tutorial（2019.01.26 @ SCUT）</h1><ul>
<li><a href="#python-basic-tutorial20190126--scut">Python Basic Tutorial（2019.01.26 @ SCUT）</a><ul>
<li><a href="#prerequisites">Prerequisites</a></li>
<li><a href="#python-tutorial--forked-from-cs231">Python tutorial ( Forked from CS231)</a><ul>
<li><a href="#standard-input--output">Standard Input &amp; Output</a></li>
<li><a href="#basic-data-types">Basic data types</a><ul>
<li><a href="#numbers">Numbers</a></li>
<li><a href="#booleans">Booleans</a></li>
<li><a href="#strings">Strings</a></li>
<li><a href="#none">None</a></li>
<li><a href="#type-casting">Type casting</a></li>
<li><a href="#quiz-1-calclating-a--b--c">Quiz #1: Calclating A + B + C</a></li>
</ul>
</li>
<li><a href="#containers">Containers</a><ul>
<li><a href="#lists--value">Lists | [value, ]</a></li>
<li><a href="#quiz-2-fibonacci-numbers">Quiz #2: Fibonacci numbers</a></li>
<li><a href="#dictionaries--key-value">Dictionaries | {key: value, }</a></li>
<li><a href="#sets--element">Sets | {element, }</a></li>
<li><a href="#quiz-3-remove-repeated-values">Quiz #3: Remove repeated values</a></li>
<li><a href="#tuples--value">Tuples | (value, )</a></li>
</ul>
</li>
<li><a href="#control-flow">Control flow</a><ul>
<li><a href="#condition">Condition</a></li>
<li><a href="#loops">Loops</a></li>
</ul>
</li>
<li><a href="#functions">Functions</a><ul>
<li><a href="#quiz-4--implement-sqrt-function">Quiz #4 : Implement <code>sqrt()</code> function</a></li>
</ul>
</li>
<li><a href="#classes">Classes</a></li>
<li><a href="#file-input--output">File Input &amp; Output</a><ul>
<li><a href="#quiz-5-char-count">Quiz #5: Char count</a></li>
</ul>
</li>
<li><a href="#exceptions">Exceptions</a></li>
</ul>
</li>
<li><a href="#end">END</a></li>
</ul>
</li>
</ul>
<h2 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h2><ul>
<li><p><a href="https://code.visualstudio.com/">VS Code</a></p>
<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=ms-python.python">Python extension</a></li>
</ul>
</li>
<li><p><a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/">Python 3  (conda version)</a></p>
<ul>
<li><p>Use tuna mirrors (<a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/">conda</a> , <a href="https://mirrors.tuna.tsinghua.edu.cn/help/pypi/">pypi</a> )</p>
</li>
<li><p><a href="https://ipython.org/">IPython</a>, <code>pip(conda) install ipython</code></p>
</li>
<li><p><a href="http://www.numpy.org/">NumPy</a> , <code>pip(conda) install numpy</code></p>
</li>
<li><p>Create a Python 3.6 environment and activate it</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">conda create --name py36 python=3.6</span><br><span class="line">activate py36</span><br><span class="line"><span class="comment"># activate base</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><a href="https://www.jetbrains.com/pycharm/download">PyCharm (Community Version)</a></p>
</li>
</ul>
<p>You can know more about conda package manager <a href="https://conda.io/projects/conda/en/latest/user-guide/getting-started.html">in the documentation</a>.</p>
<h2 id="Python-tutorial-Forked-from-CS231"><a href="#Python-tutorial-Forked-from-CS231" class="headerlink" title="Python tutorial ( Forked from CS231)"></a>Python tutorial ( Forked from <a href="http://cs231n.github.io/python-numpy-tutorial/">CS231</a>)</h2><h3 id="Standard-Input-amp-Output"><a href="#Standard-Input-amp-Output" class="headerlink" title="Standard Input &amp; Output"></a>Standard Input &amp; Output</h3><p>The <a href="https://docs.python.org/3/library/functions.html#input"><code>input()</code></a> built-in function read a line from standard input with trailing newline stripped.</p>
<p>The <a href="https://docs.python.org/3/library/functions.html#print"><code>print()</code></a> built-in function usually used to print something to standard output with adding a trailing newline.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">something = <span class="built_in">input</span>()</span><br><span class="line"><span class="built_in">print</span>(something)</span><br><span class="line"></span><br><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;Input your name: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>, name)</span><br></pre></td></tr></table></figure>



<h3 id="Basic-data-types"><a href="#Basic-data-types" class="headerlink" title="Basic data types"></a>Basic data types</h3><p>Like most languages, Python has a number of basic types including integers, floats, booleans, and strings. These data types behave in ways that are familiar from other programming languages.</p>
<h4 id="Numbers"><a href="#Numbers" class="headerlink" title="Numbers"></a>Numbers</h4><p>Integers and floats work as you would expect from other languages:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">3</span></span><br><span class="line">a, b = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(x)) <span class="comment"># Prints &quot;&lt;class &#x27;int&#x27;&gt;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(x)       <span class="comment"># Prints &quot;3&quot;</span></span><br><span class="line"><span class="built_in">print</span>(x + <span class="number">1</span>)   <span class="comment"># Addition; prints &quot;4&quot;</span></span><br><span class="line"><span class="built_in">print</span>(x - <span class="number">1</span>)   <span class="comment"># Subtraction; prints &quot;2&quot;</span></span><br><span class="line"><span class="built_in">print</span>(x * <span class="number">2</span>)   <span class="comment"># Multiplication; prints &quot;6&quot;</span></span><br><span class="line"><span class="built_in">print</span>(x ** <span class="number">3</span>)  <span class="comment"># Exponentiation; prints &quot;27&quot;</span></span><br><span class="line"><span class="built_in">print</span>(x / <span class="number">2</span>)   <span class="comment"># Division</span></span><br><span class="line"><span class="built_in">print</span>(x // <span class="number">2</span>)  <span class="comment"># Integer division</span></span><br><span class="line"><span class="built_in">print</span>(x % <span class="number">2</span>)   <span class="comment"># Remainder of the division</span></span><br><span class="line">x += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># Prints &quot;4&quot;</span></span><br><span class="line">x *= <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># Prints &quot;8&quot;</span></span><br><span class="line">y = <span class="number">2.5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(y)) <span class="comment"># Prints &quot;&lt;class &#x27;float&#x27;&gt;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(y, y + <span class="number">1</span>, y * <span class="number">2</span>, y ** <span class="number">2</span>) <span class="comment"># Prints &quot;2.5 3.5 5.0 6.25&quot;</span></span><br></pre></td></tr></table></figure>

<p>Note that unlike many languages, Python does not have unary increment (<code>x++</code>) or decrement (<code>x--</code>) operators.</p>
<p>Python also has built-in types for complex numbers; you can find all of the details <a href="https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex">in the documentation</a>.</p>
<h4 id="Booleans"><a href="#Booleans" class="headerlink" title="Booleans"></a>Booleans</h4><p>Python implements all of the usual operators for Boolean logic, but uses English words rather than symbols (<code>&amp;&amp;</code>, <code>||</code>, etc.):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = <span class="literal">True</span></span><br><span class="line">f = <span class="literal">False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t)) <span class="comment"># Prints &quot;&lt;class &#x27;bool&#x27;&gt;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(t <span class="keyword">and</span> f) <span class="comment"># Logical AND; prints &quot;False&quot;</span></span><br><span class="line"><span class="built_in">print</span>(t <span class="keyword">or</span> f)  <span class="comment"># Logical OR; prints &quot;True&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> t)   <span class="comment"># Logical NOT; prints &quot;False&quot;</span></span><br><span class="line"><span class="built_in">print</span>(t != f)  <span class="comment"># Logical XOR; prints &quot;True&quot;</span></span><br><span class="line"><span class="built_in">print</span>(t == t)</span><br></pre></td></tr></table></figure>


<h4 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h4><p>Python has great support for strings:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hello = <span class="string">&#x27;hello&#x27;</span>    <span class="comment"># String literals can use single quotes</span></span><br><span class="line">world = <span class="string">&quot;world&quot;</span>    <span class="comment"># or double quotes; it does not matter.</span></span><br><span class="line"><span class="built_in">print</span>(hello)       <span class="comment"># Prints &quot;hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(hello[<span class="number">0</span>])    <span class="comment"># Prints &#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(hello))  <span class="comment"># String length; prints &quot;5&quot;</span></span><br><span class="line">hw = hello + <span class="string">&#x27; &#x27;</span> + world  <span class="comment"># String concatenation</span></span><br><span class="line"><span class="built_in">print</span>(hw)  <span class="comment"># prints &quot;hello world&quot;</span></span><br><span class="line">hw12 = <span class="string">&#x27;%s %s %d&#x27;</span> % (hello, world, <span class="number">12</span>)  <span class="comment"># sprintf style string formatting</span></span><br><span class="line"><span class="built_in">print</span>(hw12)  <span class="comment"># prints &quot;hello world 12&quot;</span></span><br></pre></td></tr></table></figure>

<p>String objects have a bunch of useful methods; for example:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.capitalize())  <span class="comment"># Capitalize a string; prints &quot;Hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.upper())       <span class="comment"># Convert a string to uppercase; prints &quot;HELLO&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.rjust(<span class="number">7</span>))      <span class="comment"># Right-justify a string, padding with spaces; prints &quot;  hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.center(<span class="number">7</span>))     <span class="comment"># Center a string, padding with spaces; prints &quot; hello &quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.replace(<span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;(ell)&#x27;</span>))  <span class="comment"># Replace all instances of one substring with another;</span></span><br><span class="line">                                <span class="comment"># prints &quot;he(ell)(ell)o&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;  world &#x27;</span>.strip())  <span class="comment"># Strip leading and trailing whitespace; prints &quot;world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>.split())</span><br></pre></td></tr></table></figure>

<p><strong>Note</strong>: strings in python are readonly objects</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hello = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">hello[<span class="number">0</span>] = <span class="string">&#x27;i&#x27;</span>  <span class="comment"># Invalid statement</span></span><br></pre></td></tr></table></figure>

<p>You can find a list of all string methods <a href="https://docs.python.org/3/library/stdtypes.html#string-methods">in the documentation</a>.</p>
<h4 id="None"><a href="#None" class="headerlink" title="None"></a>None</h4><p>The sole value of the type <code>NoneType</code>. <a href="https://docs.python.org/3/library/constants.html#None"><code>None</code></a> is frequently used to represent the absence of a value.</p>
<h4 id="Type-casting"><a href="#Type-casting" class="headerlink" title="Type casting"></a>Type casting</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="number">1.5</span>))     <span class="comment"># Convert floating point into integer truncates towards zero</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="string">&#x27;-233&#x27;</span>))  <span class="comment"># A string must be a valid integer string to be converted into integer</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">float</span>(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="number">1</span>), <span class="built_in">bool</span>(<span class="number">0</span>), <span class="built_in">bool</span>(<span class="number">1.1</span>), <span class="built_in">bool</span>(<span class="number">0.0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">bool</span>(<span class="string">&quot;hello&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>You can konw more about Python built-in types <a href="https://docs.python.org/3/library/stdtypes.html">in the documentation</a>.</p>
<h4 id="Quiz-1-Calclating-A-B-C"><a href="#Quiz-1-Calclating-A-B-C" class="headerlink" title="Quiz #1: Calclating A + B + C"></a>Quiz #1: <a href="https://nanti.jisuanke.com/t/1">Calclating A + B + C</a></h4><h3 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a>Containers</h3><p>Python includes several built-in container types: lists, dictionaries, sets, and tuples.</p>
<h4 id="Lists-value"><a href="#Lists-value" class="headerlink" title="Lists | [value, ]"></a>Lists | [value, ]</h4><p>A list is the Python equivalent of an array, but is resizeable and can contain elements of different types:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">list</span>()</span><br><span class="line">b = []</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a), <span class="built_in">type</span>(b))</span><br><span class="line"></span><br><span class="line">xs = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]    <span class="comment"># Create a list</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> <span class="keyword">in</span> xs)    <span class="comment"># Check whether an element is in a list</span></span><br><span class="line"><span class="built_in">print</span>(xs, xs[<span class="number">2</span>])  <span class="comment"># Prints &quot;[3, 1, 2] 2&quot;</span></span><br><span class="line"><span class="built_in">print</span>(xs[-<span class="number">1</span>])     <span class="comment"># Negative indices count from the end of the list; prints &quot;2&quot;</span></span><br><span class="line">xs[<span class="number">2</span>] = <span class="string">&#x27;foo&#x27;</span>     <span class="comment"># Lists can contain elements of different types</span></span><br><span class="line"><span class="built_in">print</span>(xs)         <span class="comment"># Prints &quot;[3, 1, &#x27;foo&#x27;]&quot;</span></span><br><span class="line">xs.append(<span class="string">&#x27;bar&#x27;</span>)  <span class="comment"># Add a new element to the end of the list</span></span><br><span class="line"><span class="built_in">print</span>(xs)         <span class="comment"># Prints &quot;[3, 1, &#x27;foo&#x27;, &#x27;bar&#x27;]&quot;</span></span><br><span class="line">x = xs.pop()      <span class="comment"># Remove and return the last element of the list</span></span><br><span class="line"><span class="built_in">print</span>(x, xs)      <span class="comment"># Prints &quot;bar [3, 1, &#x27;foo&#x27;]&quot;</span></span><br></pre></td></tr></table></figure>

<p>As usual, you can find all the gory details about lists <a href="https://docs.python.org/3/tutorial/datastructures.html#more-on-lists">in the documentation</a>.</p>
<p><strong>Slicing:</strong> In addition to accessing list elements one at a time, Python provides concise syntax to access sublists; this is known as <em>slicing</em>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">5</span>))     <span class="comment"># range is a built-in function that creates a list of integers</span></span><br><span class="line"><span class="built_in">print</span>(nums)               <span class="comment"># Prints &quot;[0, 1, 2, 3, 4]&quot;</span></span><br><span class="line"><span class="built_in">print</span>(nums[<span class="number">2</span>:<span class="number">4</span>])          <span class="comment"># Get a slice from index 2 to 4 (exclusive); prints &quot;[2, 3]&quot;</span></span><br><span class="line"><span class="built_in">print</span>(nums[<span class="number">2</span>:])           <span class="comment"># Get a slice from index 2 to the end; prints &quot;[2, 3, 4]&quot;</span></span><br><span class="line"><span class="built_in">print</span>(nums[:<span class="number">2</span>])           <span class="comment"># Get a slice from the start to index 2 (exclusive); prints &quot;[0, 1]&quot;</span></span><br><span class="line"><span class="built_in">print</span>(nums[:])            <span class="comment"># Get a slice of the whole list; prints &quot;[0, 1, 2, 3, 4]&quot;</span></span><br><span class="line"><span class="built_in">print</span>(nums[:-<span class="number">1</span>])          <span class="comment"># Slice indices can be negative; prints &quot;[0, 1, 2, 3]&quot;</span></span><br><span class="line"><span class="built_in">print</span>(nums[<span class="number">0</span>:<span class="number">4</span>:<span class="number">2</span>])        <span class="comment"># Get a slice from index 0 to 4 (exclusive) with step 2</span></span><br><span class="line">nums[<span class="number">2</span>:<span class="number">4</span>] = [<span class="number">8</span>, <span class="number">9</span>]        <span class="comment"># Assign a new sublist to a slice</span></span><br><span class="line"><span class="built_in">print</span>(nums)               <span class="comment"># Prints &quot;[0, 1, 8, 9, 4]&quot;</span></span><br></pre></td></tr></table></figure>

<p>We will see slicing again in the context of numpy arrays.</p>
<p><strong>Loops:</strong> You can loop over the elements of a list like this:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">animals = [<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;monkey&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> animals:</span><br><span class="line">    <span class="built_in">print</span>(animal)</span><br><span class="line"><span class="comment"># Prints &quot;cat&quot;, &quot;dog&quot;, &quot;monkey&quot;, each on its own line.</span></span><br></pre></td></tr></table></figure>

<p>If you want access to the index of each element within the body of a loop, use the built-in <code>enumerate</code> function:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">animals = [<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;monkey&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> idx, animal <span class="keyword">in</span> <span class="built_in">enumerate</span>(animals):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;#%d: %s&#x27;</span> % (idx + <span class="number">1</span>, animal))</span><br><span class="line"><span class="comment"># Prints &quot;#1: cat&quot;, &quot;#2: dog&quot;, &quot;#3: monkey&quot;, each on its own line</span></span><br></pre></td></tr></table></figure>

<p><strong>List comprehensions:</strong> When programming, frequently we want to transform one type of data into another. As a simple example, consider the following code that computes square numbers:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">squares = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">    squares.append(x ** <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(squares)   <span class="comment"># Prints [0, 1, 4, 9, 16]</span></span><br></pre></td></tr></table></figure>

<p>You can make this code simpler using a <strong>list comprehension</strong>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">squares = [x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> nums]</span><br><span class="line"><span class="built_in">print</span>(squares)   <span class="comment"># Prints [0, 1, 4, 9, 16]</span></span><br></pre></td></tr></table></figure>

<p>List comprehensions can also contain conditions:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">even_squares = [x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> nums <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(even_squares)  <span class="comment"># Prints &quot;[0, 4, 16]&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="Quiz-2-Fibonacci-numbers"><a href="#Quiz-2-Fibonacci-numbers" class="headerlink" title="Quiz #2: Fibonacci numbers"></a>Quiz #2: <a href="https://nanti.jisuanke.com/t/4">Fibonacci numbers</a></h4><h4 id="Dictionaries-key-value"><a href="#Dictionaries-key-value" class="headerlink" title="Dictionaries | {key: value, }"></a>Dictionaries | {key: value, }</h4><p>A dictionary stores (key, value) pairs, similar to a <code>Map</code> in Java or an object in Javascript. You can use it like this:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">dict</span>()</span><br><span class="line">b = &#123;&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a), <span class="built_in">type</span>(b))</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;cat&#x27;</span>: <span class="string">&#x27;cute&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>: <span class="string">&#x27;furry&#x27;</span>&#125;  <span class="comment"># Create a new dictionary with some data</span></span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;cat&#x27;</span>])       <span class="comment"># Get an entry from a dictionary; prints &quot;cute&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;cat&#x27;</span> <span class="keyword">in</span> d)     <span class="comment"># Check if a dictionary has a given key; prints &quot;True&quot;</span></span><br><span class="line">d[<span class="string">&#x27;fish&#x27;</span>] = <span class="string">&#x27;wet&#x27;</span>     <span class="comment"># Set an entry in a dictionary</span></span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;fish&#x27;</span>])      <span class="comment"># Prints &quot;wet&quot;</span></span><br><span class="line"><span class="comment"># print(d[&#x27;monkey&#x27;])  # KeyError: &#x27;monkey&#x27; not a key of d</span></span><br><span class="line"><span class="built_in">print</span>(d.get(<span class="string">&#x27;monkey&#x27;</span>, <span class="string">&#x27;N/A&#x27;</span>))  <span class="comment"># Get an element with a default; prints &quot;N/A&quot;</span></span><br><span class="line"><span class="built_in">print</span>(d.get(<span class="string">&#x27;fish&#x27;</span>, <span class="string">&#x27;N/A&#x27;</span>))    <span class="comment"># Get an element with a default; prints &quot;wet&quot;</span></span><br><span class="line"><span class="keyword">del</span> d[<span class="string">&#x27;fish&#x27;</span>]         <span class="comment"># Remove an element from a dictionary</span></span><br><span class="line"><span class="built_in">print</span>(d.get(<span class="string">&#x27;fish&#x27;</span>, <span class="string">&#x27;N/A&#x27;</span>)) <span class="comment"># &quot;fish&quot; is no longer a key; prints &quot;N/A&quot;</span></span><br></pre></td></tr></table></figure>

<p>You can find all you need to know about dictionaries <a href="https://docs.python.org/3/library/stdtypes.html#dict">in the documentation</a>.</p>
<p><strong>Loops:</strong> It is easy to iterate over the keys in a dictionary:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;person&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;cat&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;spider&#x27;</span>: <span class="number">8</span>&#125;</span><br><span class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> d:</span><br><span class="line">    legs = d[animal]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;A %s has %d legs&#x27;</span> % (animal, legs))</span><br><span class="line"><span class="comment"># Prints &quot;A person has 2 legs&quot;, &quot;A cat has 4 legs&quot;, &quot;A spider has 8 legs&quot;</span></span><br></pre></td></tr></table></figure>

<p>If you want access to keys and their corresponding values, use the <code>items</code> method:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;person&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;cat&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;spider&#x27;</span>: <span class="number">8</span>&#125;</span><br><span class="line"><span class="keyword">for</span> animal, legs <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;A %s has %d legs&#x27;</span> % (animal, legs))</span><br><span class="line"><span class="comment"># Prints &quot;A person has 2 legs&quot;, &quot;A cat has 4 legs&quot;, &quot;A spider has 8 legs&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>Dictionary comprehensions:</strong> These are similar to list comprehensions, but allow you to easily construct dictionaries. For example:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">even_num_to_square = &#123;x: x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> nums <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(even_num_to_square)  <span class="comment"># Prints &quot;&#123;0: 0, 2: 4, 4: 16&#125;&quot;</span></span><br></pre></td></tr></table></figure>


<h4 id="Sets-element"><a href="#Sets-element" class="headerlink" title="Sets | {element, }"></a>Sets | {element, }</h4><p>A set is an unordered collection of distinct elements. As a simple example, consider the following:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">set</span>()</span><br><span class="line">b = &#123;&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a), <span class="built_in">type</span>(b))</span><br><span class="line"></span><br><span class="line">animals = &#123;<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;cat&#x27;</span> <span class="keyword">in</span> animals)   <span class="comment"># Check if an element is in a set; prints &quot;True&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;fish&#x27;</span> <span class="keyword">in</span> animals)  <span class="comment"># prints &quot;False&quot;</span></span><br><span class="line">animals.add(<span class="string">&#x27;fish&#x27;</span>)       <span class="comment"># Add an element to a set</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;fish&#x27;</span> <span class="keyword">in</span> animals)  <span class="comment"># Prints &quot;True&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(animals))       <span class="comment"># Number of elements in a set; prints &quot;3&quot;</span></span><br><span class="line">animals.add(<span class="string">&#x27;cat&#x27;</span>)        <span class="comment"># Adding an element that is already in the set does nothing</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(animals))       <span class="comment"># Prints &quot;3&quot;</span></span><br><span class="line">animals.remove(<span class="string">&#x27;cat&#x27;</span>)     <span class="comment"># Remove an element from a set</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(animals))       <span class="comment"># Prints &quot;2&quot;</span></span><br></pre></td></tr></table></figure>

<p>As usual, everything you want to know about sets can be found <a href="https://docs.python.org/3/library/stdtypes.html#set">in the documentation</a>.</p>
<p><strong>Loops:</strong> Iterating over a set has the same syntax as iterating over a list; however since sets are unordered, you cannot make assumptions about the order in which you visit the elements of the set:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">animals = &#123;<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;fish&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> idx, animal <span class="keyword">in</span> <span class="built_in">enumerate</span>(animals):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;#%d: %s&#x27;</span> % (idx + <span class="number">1</span>, animal))</span><br><span class="line"><span class="comment"># Prints &quot;#1: fish&quot;, &quot;#2: dog&quot;, &quot;#3: cat&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>Set comprehensions:</strong> Like lists and dictionaries, we can easily construct sets using set comprehensions:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line">nums = &#123;<span class="built_in">int</span>(sqrt(x)) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>)&#125;</span><br><span class="line"><span class="built_in">print</span>(nums)  <span class="comment"># Prints &quot;&#123;0, 1, 2, 3, 4, 5&#125;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Quiz-3-Remove-repeated-values"><a href="#Quiz-3-Remove-repeated-values" class="headerlink" title="Quiz #3: Remove repeated values"></a>Quiz #3: <a href="https://nanti.jisuanke.com/t/11">Remove repeated values</a></h4><h4 id="Tuples-value"><a href="#Tuples-value" class="headerlink" title="Tuples | (value, )"></a>Tuples | (value, )</h4><p>A tuple is an (immutable) ordered list of values. A tuple is in many ways similar to a list; one of the most important differences is that tuples can be used as keys in dictionaries and as elements of sets, while lists cannot. Here is a trivial example:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;(x, x + <span class="number">1</span>): x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)&#125;  <span class="comment"># Create a dictionary with tuple keys</span></span><br><span class="line">t = (<span class="number">5</span>, <span class="number">6</span>)        <span class="comment"># Create a tuple</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t))    <span class="comment"># Prints &quot;&lt;class &#x27;tuple&#x27;&gt;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(d[t])       <span class="comment"># Prints &quot;5&quot;</span></span><br><span class="line"><span class="built_in">print</span>(d[(<span class="number">1</span>, <span class="number">2</span>)])  <span class="comment"># Prints &quot;1&quot;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences">The documentation</a> has more information about tuples.</p>
<h3 id="Control-flow"><a href="#Control-flow" class="headerlink" title="Control flow"></a>Control flow</h3><h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p>Python use <a href="https://docs.python.org/3/reference/compound_stmts.html#if"><code>if</code></a> statement to perform condition control flow.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Please enter an integer: &quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Negative changed to zero&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> x == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Zero&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> x == <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Single&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;More&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>There can be zero or more <a href="https://docs.python.org/3/reference/compound_stmts.html#elif"><code>elif</code></a> parts, and the <a href="https://docs.python.org/3/reference/compound_stmts.html#else"><code>else</code></a> part is optional. The keyword ‘<code>elif</code>’ is short for ‘else if’, and is useful to avoid excessive indentation. An <code>if … elif … elif …</code> sequence is a substitute for the <code>switch</code> or <code>case</code> statements found in other languages.</p>
<p><strong>Truth value testing</strong> : Any object can be tested for truth value, for use in an <a href="https://docs.python.org/3/reference/compound_stmts.html#if"><code>if</code></a> or <a href="https://docs.python.org/3/reference/compound_stmts.html#while"><code>while</code></a> condition or as operand of the Boolean operations below. The following values are considered false:</p>
<ul>
<li><code>None</code></li>
<li><code>False</code></li>
<li>zero of any numeric type, for example, <code>0</code>, <code>0L</code>, <code>0.0</code>, <code>0j</code>.</li>
<li>any empty sequence, for example, <code>&#39;&#39;</code>, <code>()</code>, <code>[]</code>.</li>
<li>any empty mapping, for example, <code>&#123;&#125;</code>.</li>
<li>most of others are true.</li>
</ul>
<h4 id="Loops"><a href="#Loops" class="headerlink" title="Loops"></a>Loops</h4><p>The <a href="https://docs.python.org/3/reference/compound_stmts.html#for"><code>for</code></a> statement in Python differs a bit from other programming languages, Python’s <code>for</code> statement iterates over the items of any sequence (a list or a string), in the order that they appear in the sequence.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Loop over list:</span></span><br><span class="line">words = [<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;window&#x27;</span>, <span class="string">&#x27;defenestrate&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">    <span class="built_in">print</span>(w, <span class="built_in">len</span>(w))</span><br><span class="line">word = words[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Loop over string</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">    <span class="built_in">print</span>(char)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Loop over range</span></span><br><span class="line">rng = <span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(rng)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>

<p>The <a href="https://docs.python.org/3/reference/compound_stmts.html#while"><code>while</code></a> statement is used for repeated execution as long as an expression is true.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>A <a href="https://docs.python.org/3/reference/simple_stmts.html#break"><code>break</code></a> statement will terminate the loop.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># judge whether a number is a prime number</span></span><br><span class="line">x = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">flag = <span class="literal">True</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, x):</span><br><span class="line">    <span class="keyword">if</span> x % i == <span class="number">0</span>:</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> flag:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;YES&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;NO&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>A <a href="https://docs.python.org/3/reference/simple_stmts.html#continue"><code>continue</code></a> statement executed in the first suite skips the rest of the suite and continues with the next item.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Found an even number&quot;</span>, num)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Found a number&quot;</span>, num)</span><br></pre></td></tr></table></figure>

<p>The <a href="https://docs.python.org/3/reference/simple_stmts.html#pass"><code>pass</code></a> statement does nothing. It can be used when a statement is required syntactically but the program requires no action.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>You can know more about loops from <a href="https://docs.python.org/3/tutorial/datastructures.html#tut-loopidioms">offical documents</a> , and more about Python’s simple statements in <a href="https://docs.python.org/3/reference/simple_stmts.html">documents</a> too</p>
<h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><p>Python functions are defined using the <code>def</code> keyword. For example:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;positive&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> x &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;negative&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;zero&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]:</span><br><span class="line">    <span class="built_in">print</span>(sign(x))</span><br><span class="line"><span class="comment"># Prints &quot;negative&quot;, &quot;zero&quot;, &quot;positive&quot;</span></span><br></pre></td></tr></table></figure>

<p>We will often define functions to take optional keyword arguments, like this:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">name, loud=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="keyword">if</span> loud:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;HELLO, %s!&#x27;</span> % name.upper())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Hello, %s&#x27;</span> % name)</span><br><span class="line"></span><br><span class="line">hello(<span class="string">&#x27;Bob&#x27;</span>) <span class="comment"># Prints &quot;Hello, Bob&quot;</span></span><br><span class="line">hello(<span class="string">&#x27;Fred&#x27;</span>, loud=<span class="literal">True</span>)  <span class="comment"># Prints &quot;HELLO, FRED!&quot;</span></span><br></pre></td></tr></table></figure>

<p>There are a number of built-in functions (like <code>len()</code>) in Python, you can konw more about them <a href="https://docs.python.org/3/library/functions.html">in the documentation</a>.</p>
<p>There is a lot more information about Python functions <a href="https://docs.python.org/3/tutorial/controlflow.html#defining-functions">in the documentation</a>.</p>
<h4 id="Quiz-4-Implement-sqrt-function"><a href="#Quiz-4-Implement-sqrt-function" class="headerlink" title="Quiz #4 : Implement sqrt() function"></a>Quiz #4 : <a href="https://nanti.jisuanke.com/t/17">Implement <code>sqrt()</code> function</a></h4><h3 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h3><p>The syntax for defining classes in Python is straightforward:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Constructor</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name  <span class="comment"># Create an instance variable</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Instance method</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">self, loud=<span class="literal">False</span></span>):</span><br><span class="line">        <span class="keyword">if</span> loud:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;HELLO, %s!&#x27;</span> % self.name.upper())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Hello, %s&#x27;</span> % self.name)</span><br><span class="line"></span><br><span class="line">g = Greeter(<span class="string">&#x27;Fred&#x27;</span>)  <span class="comment"># Construct an instance of the Greeter class</span></span><br><span class="line">g.greet()            <span class="comment"># Call an instance method; prints &quot;Hello, Fred&quot;</span></span><br><span class="line">g.greet(loud=<span class="literal">True</span>)   <span class="comment"># Call an instance method; prints &quot;HELLO, FRED!&quot;</span></span><br></pre></td></tr></table></figure>

<p>You can read a lot more about Python classes <a href="https://docs.python.org/3/tutorial/classes.html">in the documentation</a>.</p>
<h3 id="File-Input-amp-Output"><a href="#File-Input-amp-Output" class="headerlink" title="File Input &amp; Output"></a>File Input &amp; Output</h3><p>Interact with files in Python is much easier than other languages , you can simply use <a href="https://docs.python.org/3/library/functions.html#open"><code>open()</code></a> built-in function.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># wirte content into a file</span></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;file.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">file.write(<span class="string">&#x27;hello\n&#x27;</span>)</span><br><span class="line">file.write(<span class="string">&#x27;\n1\n2\n3\n&#x27;</span>)</span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># read from a file</span></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;file.txt&#x27;</span>)  <span class="comment"># the default mode is &#x27;r&#x27;</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># use &#x27;with&#x27; statement (PEP343)</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;file.txt&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="built_in">print</span>(file.readlines())</span><br></pre></td></tr></table></figure>



<h4 id="Quiz-5-Char-count"><a href="#Quiz-5-Char-count" class="headerlink" title="Quiz #5: Char count"></a>Quiz #5: Char count</h4><p><a href="https://raw.githubusercontent.com/csJd/md-notes/master/review/python_tutorial.md">Download data file here</a>. Calclate all characters’ frequencies and save them into <code>charcount.txt</code> file like following.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char counts</span><br><span class="line">-----------</span><br><span class="line">.    233</span><br><span class="line">a    2333</span><br><span class="line">A    23333</span><br></pre></td></tr></table></figure>





<h3 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">zero_division_fails</span>():</span><br><span class="line">    x = <span class="number">1</span>/<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">type_error_fails</span>():</span><br><span class="line">    x = <span class="string">&quot;hello&quot;</span></span><br><span class="line">    x[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">no_error</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I&#x27;m fine&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">test_func</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        test_func()</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> err:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Handling run-time error:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">except</span> TypeError <span class="keyword">as</span> err:</span><br><span class="line">        <span class="keyword">raise</span> err</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;In finally&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;test zero division case&quot;</span>)</span><br><span class="line">test(zero_division_fails)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\ntest type error case&quot;</span>)</span><br><span class="line">test(type_error_fails)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nno error case&quot;</span>)</span><br><span class="line">test(no_error)</span><br></pre></td></tr></table></figure>

<p>You can know more about errors and exceptions in Python <a href="https://docs.python.org/3/tutorial/errors.html">in the documentation</a>.</p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>You can read a lot more about Python in official <a href="https://docs.python.org/3/tutorial/index.html">Python Tutorial</a>.</p>
<p>Thank You.</p>
]]></content>
      <categories>
        <category>Tutorials</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>SVM Review</title>
    <url>/posts/svm-review/</url>
    <content><![CDATA[<h2 id="支持向量机的基本型"><a href="#支持向量机的基本型" class="headerlink" title="支持向量机的基本型"></a>支持向量机的基本型</h2><p>支持向量机（SVM）是一种二类分类模型，其学习的基本想法是求解能够正确划分训练数据集并且间隔最大的划分超平面。</p>
<span id="more"></span>

<p>划分超平面 $(\mathbf{w}, b)$ 可以由线性方程 $\mathbf{w}^T\mathbf{x} + b &#x3D; 0$ 来描述，令</p>
<p>$$<br>  y_i(\mathbf{w}^T\mathbf{x}_i + b) \ge 1, \quad i &#x3D; 1,…, m, y_i \in {-1, 1}<br>  \tag{0}<br>$$</p>
<blockquote>
<p>注：若超平面 $(\mathbf{w}_t, b_t)$ 能将训练样本正确分类，即 $y_i(\mathbf{w}_t^T\mathbf{x}_i + b_t) \ge 0$，则总存在缩放变换 $\mathbf{w}^T&#x3D;\varsigma \mathbf{w}^T_t, b &#x3D; \varsigma b_t$ 使得式（0）成立</p>
</blockquote>
<p>此时的间隔 $\gamma$ 定义为 $\gamma &#x3D; \frac{2}{| \mathbf{w} |}$，使间隔最大化，即对以下优化问题求解：<br>$$<br>  \begin{aligned}<br>    \underset{\mathbf{w},b}{max} \quad &amp; \frac{2}{\Vert \mathbf{w}\Vert} \<br>    s.t. \quad &amp; y_i(\mathbf{w}^T\mathbf{x}_i+b) \ge 1, \quad i &#x3D; 1, …, m<br>  \end{aligned}<br>  \tag{1}<br>$$</p>
<p>这等价于：</p>
<p>$$<br>  \begin{aligned}<br>    \underset{\mathbf{w},b}{min} \quad &amp; \frac{1}{2}{\Vert \mathbf{w}\Vert}^2 \<br>    s.t. \quad &amp; y_i(\mathbf{w}^T\mathbf{x}_i+b) \ge 1, \quad i &#x3D; 1, …, m<br>  \end{aligned}<br>  \tag{2}<br>$$</p>
<p>这是支持向量机的基本型，对求解式 (2) 使用 <a href="https://zh.wikipedia.org/wiki/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E6%95%B0">拉格朗日乘数法</a> 有：<br>$$<br>  L(\mathbf{w}, b, \alpha) &#x3D; \frac{1}{2}{\Vert \mathbf{w}\Vert}^2+\sum_{i&#x3D;1}^m\alpha_i(1-y_i(\mathbf{w}^T\mathbf{x}_i+b))<br>  \tag{3}<br>$$</p>
<p>令 $L$ 对 $\mathbf{w}, b$ 的偏导为零得</p>
<p>$$<br>  \begin{aligned}<br>    \mathbf{w} &amp;&#x3D; \sum_{i&#x3D;1}^m\alpha_iy_i\mathbf{x}<em>i\<br>    0 &amp;&#x3D; \sum</em>{i&#x3D;1}^m\alpha_iy_i<br>  \end{aligned}<br>  \tag{4}<br>$$</p>
<p>代入式（3）将 $\mathbf{w}$ 和 $b$ 消去有</p>
<p>$$<br>  \begin{aligned}<br>    \underset{\mathbf{w},b}{min}\ L(\mathbf{w},b,\alpha) &amp;&#x3D; \frac{1}{2}\sum_{i&#x3D;1}^{m}\sum_{j&#x3D;1}^m \alpha_i\alpha_jy_iy_j(\mathbf{x}<em>i^T\mathbf{x}<em>j) - \sum</em>{i&#x3D;1}^m\alpha_iy_i\left(\left(\sum</em>{j&#x3D;1}^m\alpha_jy_j\mathbf{x}<em>j\right)\mathbf{x}<em>i + b\right) + \sum</em>{i &#x3D; 1}^m\alpha_i\<br>    &amp;&#x3D;-\frac{1}{2}\sum</em>{i&#x3D;1}^{m}\sum_{j&#x3D;1}^m \alpha_i\alpha_jy_iy_j(\mathbf{x}_i^T\mathbf{x}<em>j) + \sum</em>{i&#x3D;1}^m\alpha_i<br>  \end{aligned}<br>  \tag{5}<br>$$</p>
<p>得到对偶问题：</p>
<p>$$<br>  \begin{aligned}<br>    \underset{\alpha}{max} \quad &amp; -\frac{1}{2}\sum_{i&#x3D;1}^{m}\sum_{j&#x3D;1}^m \alpha_i\alpha_jy_iy_j(\mathbf{x}<em>i^T\mathbf{x}<em>j) + \sum</em>{i&#x3D;1}^m\alpha_i \<br>    s.t.\quad<br>    &amp; \sum</em>{i&#x3D;1}^m\alpha_iy_i &#x3D; 0, \<br>    &amp; \alpha_i \ge 0, \quad i &#x3D; 1, …, m<br>  \end{aligned}<br>  \tag{6}<br>$$</p>
<p>解出 $\alpha$ 后求出 $\mathbf{w}$ 与 $b$ 即可得到模型 $f(\mathbf{x}) &#x3D; \mathbf{w}^Tx + b &#x3D; \sum_{i&#x3D;1}^m\alpha_iy_i(\mathbf{x}_i^T\mathbf{x}) + b$</p>
<p>可以使用 SMO 算法来进行求解，SMO 不断执行如下两个步骤直到收敛：</p>
<ul>
<li>选取一对需要更新的变量 $\alpha_i$ 和 $\alpha_j$</li>
<li>固定 $\alpha_i$ 和 $\alpha_j$ 以外的参数，求解式（3）更新后的 $\alpha_i$ 和 $\alpha_j$</li>
</ul>
<h2 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h2><p>原始的特征空间的也许并不存在一个能正确划分两类样本的超平面，此时存在一个更高维度的空间，将原始空间中的样本映射到高维度空间后是线性可分的，令 $\phi (\mathbf{x})$ 表示将 $\mathbf{x}$ 映射到高维空间后的特征向量。类似上面的基本型，可以得到此情况下的对偶问题：</p>
<p>$$<br>  \begin{aligned}<br>    \underset{\alpha}{max} \quad &amp; -\frac{1}{2}\sum_{i&#x3D;1}^{m}\sum_{j&#x3D;1}^m \alpha_i\alpha_jy_iy_j\phi(\mathbf{x}<em>i)^T\phi(\mathbf{x}<em>j) + \sum</em>{i&#x3D;1}^m\alpha_i \<br>    s.t.\quad<br>    &amp; \sum</em>{i&#x3D;1}^m\alpha_iy_i &#x3D; 0, \<br>    &amp; \alpha_i \ge 0, \quad i &#x3D; 1, …, m<br>  \end{aligned}<br>  \tag{7}<br>$$</p>
<p>直接计算 $\phi(\mathbf{x}_i)\cdot\phi(\mathbf{x}_j)$ 可能会很困难，设想有这样的函数：</p>
<p>$$<br>  \kappa(\mathbf{x}_i, \mathbf{x}_j) &#x3D; \langle\phi(\mathbf{x}_i), \phi(\mathbf{x}_j)\rangle &#x3D;\phi(\mathbf{x}_i)^T\phi(\mathbf{x}_j)<br>  \tag{8}<br>$$</p>
<p>即 $\mathbf{x}_i$ 与 $\mathbf{x}_j$ 映射到高维空间后的内积等于在原始特征空间中通过函数 $\kappa(.,.)$ 计算的结果，函数 $\kappa(.,.)$ 称作 <a href="https://en.wikipedia.org/wiki/Positive-definite_kernel">核函数</a>。</p>
<h2 id="软间隔"><a href="#软间隔" class="headerlink" title="软间隔"></a>软间隔</h2><p>往往很难确定合适的核函数使得训练样本严格线性可分，软间隔 SVM 允许某些样本不满足约束，在最大化间隔的同时，不满足约束的样本应尽可能少。使用 hinge 损失函数时，可以得到此条件下的优化目标</p>
<p>$$<br>  \begin{aligned}<br>    \underset{\mathbf{w},b}{min} \quad &amp; \frac{1}{2}{|\mathbf{w}|}^2 + C\sum_{i&#x3D;1}^mmax(0, 1-y_i(\mathbf{w}^T\mathbf{x}_i + b)),\quad i &#x3D; 1, …, m<br>  \end{aligned}<br>  \tag{9}<br>$$</p>
<p>若引入松弛变量 $\xi_i \ge 0$，可将式（9）重写为</p>
<p>$$<br>  \begin{aligned}<br>    \underset{\mathbf{w},b,\xi_i}{min} \quad &amp; \frac{1}{2}{|\mathbf{w}|}^2 + C\sum_{i&#x3D;1}^m\xi_i\<br>    s.t. \quad &amp; y_i(\mathbf{w}^T\mathbf{x}_i+ b) \ge 1-\xi_i\<br>    &amp;\xi_i \ge 0, \quad i &#x3D; 1, …, m<br>  \end{aligned}<br>  \tag{10}<br>$$<br>这就是软间隔支持向量机。</p>
<h2 id="与-LR-Logistic-Regression-的区别"><a href="#与-LR-Logistic-Regression-的区别" class="headerlink" title="与 LR (Logistic Regression) 的区别"></a>与 LR (Logistic Regression) 的区别</h2><ul>
<li><p>二者的 Loss function 可以表示为一种类似的形式<br>$$<br>  \begin{aligned}<br>LR:\quad &amp;\lambda |\mathbf{w}|^2 + \sum_{i&#x3D;1}^mlog(1 + exp(-y_i\mathbf{w}^T\mathbf{x}<em>i))\<br>SVM:\quad &amp; \lambda |\mathbf{w}|^2 + \sum</em>{i&#x3D;1}^mmax{0, 1-y_i\mathbf{w}^T\mathbf{x}_i}<br>  \end{aligned}<br>$$<br>其中 $y_i \in {-1, 1}$，LR 是 Logistic Loss， SVM 是 Hinge Loss</p>
</li>
<li><p>SVM 只考虑支持向量（使不等式等号成立的点），LR 考虑所有点；SVM 不依赖于数据分布， LR 受数据分布影响</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Review</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>TCPCopy</title>
    <url>/posts/tcpcopy/</url>
    <content><![CDATA[<p><a href="https://github.com/session-replay-tools/tcpcopy">TCPCopy</a> 是一个开源的 TCP 服务器测试工具，<br>功能是复制在线 server 的 TCP 类型的请求数据包，修改 TCP&#x2F;IP 头部信息，<br>发送给测试服务器，达到欺骗测试服务器的 TCP 程序的目的。</p>
<span id="more"></span>

<h2 id="测试服务器安装并启动-intercept"><a href="#测试服务器安装并启动-intercept" class="headerlink" title="测试服务器安装并启动 intercept"></a>测试服务器安装并启动 intercept</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line">yum install -y libnetfilter_queue-devel</span><br><span class="line">wget https://github.com/session-replay-tools/intercept/archive/refs/tags/1.0.0.tar.gz</span><br><span class="line">tar -xvf intercept-1.0.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> intercept-1.0.0</span><br><span class="line">./configure --single --traditional --nfqueue --prefix=/opt/tcpcopy</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">iptables --insert OUTPUT -p tcp --sport 80 -j NFQUEUE</span><br><span class="line">/opt/tcpcopy/sbin/intercept -d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">pkill -9 intercept</span><br><span class="line">iptables --delete OUTPUT -p tcp --sport 80 -j NFQUEUE</span><br><span class="line"><span class="comment"># 一定要先停止现网的 tcpcopy 再停止测试机的 intercept</span></span><br></pre></td></tr></table></figure>

<h2 id="现网服务器安装并启动-tcpcopy"><a href="#现网服务器安装并启动-tcpcopy" class="headerlink" title="现网服务器安装并启动 tcpcopy"></a>现网服务器安装并启动 tcpcopy</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line">wget https://github.com/session-replay-tools/tcpcopy/archive/refs/tags/v1.2.0.tar.gz</span><br><span class="line">tar -xvf tcpcopy-1.2.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> tcpcopy-1.2.0</span><br><span class="line">./configure --single --with-cc-opt=-O3 --prefix=/opt/tcpcopy</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">/opt/tcpcopy/sbin/tcpcopy -x 0:80-1.1.1.1:80 -s 1.1.1.1 -n 1 -d</span><br><span class="line"><span class="comment"># 参数说明：</span></span><br><span class="line"><span class="comment"># -x: transfer, src_port-dst_ip:dst_port</span></span><br><span class="line"><span class="comment"># -s: 运行 intercept 的 ip，例子中为 1.1.1.1</span></span><br><span class="line"><span class="comment"># -n: 流量放大倍数，默认为 1，即不放大</span></span><br><span class="line"><span class="comment"># -d: run as daemon</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">pkill -9 tcpcopy</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Practice</category>
      </categories>
      <tags>
        <tag>Practice</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针技巧的应用</title>
    <url>/posts/two-pointers/</url>
    <content><![CDATA[<p>这里对笔试题中常用到的「双指针技巧」进行简单的归纳，后续遇到会继续补充。</p>
<span id="more"></span>

<h2 id="LeetCode-文章-「常用的双指针技巧」"><a href="#LeetCode-文章-「常用的双指针技巧」" class="headerlink" title="LeetCode 文章 「常用的双指针技巧」"></a>LeetCode 文章 「<a href="https://leetcode-cn.com/circle/article/GMopsy">常用的双指针技巧</a>」</h2><ul>
<li>判定链表中是否含有环</li>
<li>已知链表中含有环，返回这个环的起始位置</li>
<li>寻找链表的中点</li>
<li>寻找链表的倒数第 k 个元素</li>
<li><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/hua-dong-chuang-kou-tong-yong-si-xiang-jie-jue-zi-/">滑动窗口解决子串问题</a></li>
<li><a href="https://leetcode.com/tag/two-pointers/">LeetCode 相关题目</a></li>
</ul>
<h2 id="数组相关问题"><a href="#数组相关问题" class="headerlink" title="数组相关问题"></a>数组相关问题</h2><ul>
<li>调整数组顺序使得满足某种条件的数（如奇数）位于不满足条件的前面</li>
<li>排序数组中和为 s 的两个数字</li>
<li>排序数组中和为 s 的所有子数组</li>
<li>和为 s 的连续正数序列</li>
<li><a href="https://leetcode.com/problems/trapping-rain-water/description">接雨水问题</a></li>
<li><a href="https://leetcode.com/problems/sort-colors/description/">颜色排序问题</a></li>
</ul>
<h2 id="笔试题记录"><a href="#笔试题记录" class="headerlink" title="笔试题记录"></a>笔试题记录</h2><ul>
<li><p>网易游戏笔试题 (190811）：</p>
<blockquote>
<p>你可以最多改变两个大写字母，使得字符串所包含的连续的 N 串的长度最长，求最长长度</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">5</span></span><br><span class="line"><span class="string">NNTN</span></span><br><span class="line"><span class="string">NNNNGGNNNN</span></span><br><span class="line"><span class="string">NGNNNNGNNNNNNNNSNNNN</span></span><br><span class="line"><span class="string">TNT</span></span><br><span class="line"><span class="string">T</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">10</span></span><br><span class="line"><span class="string">18</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># two pointers solution</span></span><br><span class="line">    n_cases = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="keyword">while</span> n_cases &gt; <span class="number">0</span>:</span><br><span class="line">        n_cases -= <span class="number">1</span></span><br><span class="line">        s = <span class="built_in">input</span>().strip()</span><br><span class="line">        length = <span class="built_in">len</span>(s)</span><br><span class="line"></span><br><span class="line">        le = ri = <span class="number">0</span></span><br><span class="line">        max_length = <span class="number">0</span></span><br><span class="line">        cnt = <span class="number">0</span>  <span class="comment"># the count of non-&#x27;N&#x27;s in current [le, ri] window</span></span><br><span class="line">        <span class="keyword">while</span> ri &lt; length:</span><br><span class="line">            <span class="keyword">if</span> cnt &gt; <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> s[le] != <span class="string">&#x27;N&#x27;</span>:</span><br><span class="line">                    cnt -= <span class="number">1</span></span><br><span class="line">                le += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> s[ri] != <span class="string">&#x27;N&#x27;</span>:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                ri += <span class="number">1</span></span><br><span class="line">                max_length = <span class="built_in">max</span>(max_length, ri-le)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(max_length)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
</li>
<li><p>网易云音乐面试题（190817）</p>
<blockquote>
<p>给定一个字符串，请你找出其中不含有重复字符的最长子串</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输入：原始字符串</span></span><br><span class="line"><span class="string">输出：最长子串</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">input: abcabcaa</span></span><br><span class="line"><span class="string">output: abc</span></span><br><span class="line"><span class="string">input: ddddddd</span></span><br><span class="line"><span class="string">output: d</span></span><br><span class="line"><span class="string">input: skkwek</span></span><br><span class="line"><span class="string">output: kwe</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">length = <span class="built_in">len</span>(s)</span><br><span class="line"></span><br><span class="line">le = ri = <span class="number">0</span></span><br><span class="line">window = <span class="built_in">set</span>()</span><br><span class="line">ans = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="keyword">while</span> ri &lt; length:</span><br><span class="line">    <span class="keyword">while</span> s[ri] <span class="keyword">in</span> window:</span><br><span class="line">        window.remove(s[le])</span><br><span class="line">        le += <span class="number">1</span></span><br><span class="line">    window.add(s[ri])</span><br><span class="line">    ri += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(window) &gt; ans[<span class="number">1</span>] - ans[<span class="number">0</span>] + <span class="number">1</span>:</span><br><span class="line">        ans[<span class="number">0</span>], ans[<span class="number">1</span>] = le, ri</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s[ans[<span class="number">0</span>]:ans[<span class="number">1</span>]+<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>字节跳动面试题（190818）</p>
<blockquote>
<p>求 arr[j] - arr[i] 的最大值， j &gt;&#x3D; i</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1 3 2 4 5 0 2 3 7</span></span><br><span class="line"><span class="string">7</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    arr = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(arr):</span><br><span class="line">        <span class="keyword">if</span> arr[j] &lt;= arr[i]:</span><br><span class="line">            i = j</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, arr[j] - arr[i])</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(ans)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Review</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces 16B Burglar and Matches (贪心)</title>
    <url>/posts/oj/dp/CodeForces%2016B%20Burglar%20and%20Matches%20(%E8%B4%AA%E5%BF%83)/</url>
    <content><![CDATA[<p>题意 一个窃贼到火柴仓库偷火柴 仓库有m个容器 第i个容器有a[i]个火柴盒 其中每个火柴盒中有b[i]根火柴 窃贼最大可以拿n个火柴盒 输入n m 然后m行a[i] b[i] 求窃贼最多能偷多少根火柴</p>
<p>很水的贪心 直接每次选当前火柴最多的盒子 n减去盒子数 直到n&#x3D;0</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;  </span><br><span class="line">#include&lt;cstring&gt;  </span><br><span class="line">#include&lt;algorithm&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line"><span class="keyword">const</span> int M = <span class="number">25</span>;  </span><br><span class="line">int a[M], b[M], c[M], n, m, ans;  </span><br><span class="line">  </span><br><span class="line">bool cmp (int i, int j)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">return</span> b[i] &gt; b[j];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);  </span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= m; ++i)  </span><br><span class="line">    &#123;  </span><br><span class="line">        c[i] = i;  </span><br><span class="line">        scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;a[i], &amp;b[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    sort (c + <span class="number">1</span>, c + m + <span class="number">1</span>, cmp);  </span><br><span class="line">    ans = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= m; ++i)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (n &gt;= a[c[i]])  </span><br><span class="line">        &#123;  </span><br><span class="line">            n -= a[c[i]];  </span><br><span class="line">            ans += a[c[i]] * b[c[i]];  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            ans += n * b[c[i]];  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    printf (<span class="string">&quot;%d\n&quot;</span>, ans);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A burglar got into a matches warehouseand wants to steal as many matches as possible. In the warehouse there are <em>m</em>containers, in the <em>i</em>-th container there are <em>a**i</em> matchboxes, and each matchbox contains <em>b**i</em> matches. All the matchboxes are of the same size. The burglar’s rucksack can hold <em>n</em> matchboxes exactly. Your task is to find out the maximum amount of matches that a burglar can carry away. He has no time to rearrange matches in the matchboxes, that’s why he just chooses not more than <em>n</em> matchboxes so that the total amount of matches in them is maximal.<br>Input</p>
<p>The first line of the input contains integer <em>n</em> (1 ≤ <em>n</em> ≤ 2·108) and integer <em>m</em> (1 ≤ <em>m</em> ≤ 20). The <em>i</em> + 1-th line contains a pair of numbers <em>a**i</em> and <em>b**i</em> (1 ≤ <em>a**i</em> ≤ 108, 1 ≤ <em>b**i</em> ≤ 10). All the input numbers are integer.</p>
<p>Output</p>
<p>Output the only number — answer to the problem.<br>Sample test(s)</p>
<p>input 7 3 5 10 2 5 3 6</p>
<p>output 62<br>input 3 3 1 3 2 2 3 1</p>
<p>output 7</p>
<p>﻿﻿</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforce 22B Bargaining Table</title>
    <url>/posts/oj/dp/Codeforce%2022B%20Bargaining%20Table/</url>
    <content><![CDATA[<p>B. Bargaining Table</p>
<p>Bob wants to put a new bargaining table in his office. To do so he measured the office room thoroughly and drew its plan: Bob’s office room is a rectangular room <em>n</em> × <em>m</em> meters. Each square meter of the room is either occupied by some furniture, or free. A bargaining table is rectangular, and should be placed so, that its sides are parallel to the office walls. Bob doesn’t want to change or rearrange anything, that’s why all the squares that will be occupied by the table should be initially free. Bob wants the new table to sit as many people as possible, thus its perimeter should be maximal. Help Bob find out the maximum possible perimeter of a bargaining table for his office.<br>Input</p>
<p>The first line contains 2 space-separated numbers <em>n</em> and <em>m</em> (1 ≤ <em>n</em>, <em>m</em> ≤ 25) — the office room dimensions. Then there follow <em>n</em> lines with <em>m</em> characters 0 or 1 each. 0 stands for a free square meter of the office room. 1 stands for an occupied square meter. It’s guaranteed that at least one square meter in the room is free.</p>
<p>Output</p>
<p>Output one number — the maximum possible perimeter of a bargaining table for Bob’s office room.<br>Sample test(s)</p>
<p>input 3 3 000 010 000</p>
<p>output 8<br>input 5 4 1100 0000 0000 0000 0000</p>
<p>output 16</p>
<p>HDU 1505，1506的变形 只是由求面积变成了求周长 具体分析可见<a href="http://blog.csdn.net/iooden/article/details/38379065">http://blog.csdn.net/iooden/article/details/38379065</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">30</span>;</span><br><span class="line">int l[N][N], r[N][N], h[N][N], n, m, ans;</span><br><span class="line">char a[N][N];</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        h[i][<span class="number">0</span>] = h[i][m + <span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">        scanf (<span class="string">&quot;%s&quot;</span>, a[i] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] == <span class="string">&#x27;0&#x27;</span>) h[i][j] = h[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">            l[i][j] = r[i][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (int j = m; j &gt;= <span class="number">1</span>; --j)</span><br><span class="line">            <span class="keyword">while</span> (h[i][r[i][j] + <span class="number">1</span>] &gt;= h[i][j]&amp;&amp;h[i][j])</span><br><span class="line">                r[i][j] = r[i][r[i][j] + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (h[i][l[i][j] - <span class="number">1</span>] &gt;= h[i][j]&amp;&amp;h[i][j])</span><br><span class="line">                l[i][j] = l[i][l[i][j] - <span class="number">1</span>];</span><br><span class="line">            ans = max (ans, r[i][j] - l[i][j] + <span class="number">1</span> + h[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf (<span class="string">&quot;%d\n&quot;</span>, <span class="number">2</span> * ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外这题数据比较小 也可以暴力枚举 枚举每点作为左上角 然后枚举合法的的长和宽, 判断形成的的矩阵是否全由 ‘0’组成, 如果是就更新结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line"><span class="keyword">const</span> int maxn = <span class="number">30</span>;</span><br><span class="line">int n, m;</span><br><span class="line">int a[maxn][maxn];</span><br><span class="line">int sum[maxn][maxn];</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (~scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        memset (a, <span class="number">0</span>, sizeof (a));</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">                scanf (<span class="string">&quot;%1d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">        memset (sum, <span class="number">0</span>, sizeof (sum));</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum[i][j] = sum[i][j - <span class="number">1</span>] + sum[i - <span class="number">1</span>][j] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int x, y;</span><br><span class="line">        int ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (int x1 = <span class="number">1</span>; x1 &lt;= n; x1++)</span><br><span class="line">            <span class="keyword">for</span> (int y1 = <span class="number">1</span>; y1 &lt;= m; y1++)</span><br><span class="line">                <span class="keyword">for</span> (int x2 = x1; x2 &lt;= n; x2++)</span><br><span class="line">                    <span class="keyword">for</span> (int y2 = y1; y2 &lt;= m; y2++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        int tmp = sum[x2][y2] + sum[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>] - sum[x1 - <span class="number">1</span>][y2] - sum[x2][y1 - <span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span> (tmp == <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            int dx = x2 - x1 + <span class="number">1</span>;</span><br><span class="line">                            int dy = y2 - y1 + <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">if</span> (ans &lt; (dx + dy) * <span class="number">2</span>) ans = (dx + dy) * <span class="number">2</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">        printf (<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 534B Covered Path(贪心)</title>
    <url>/posts/oj/dp/Codeforces%20534B%20Covered%20Path(%E8%B4%AA%E5%BF%83)/</url>
    <content><![CDATA[<p>题意 你在路上走 每秒钟的开始都可以改变自己的速度(改变速度都是瞬间完成的) 知道你开始的速度v1 结束时的速度v2 整个过程所用时间t 以及每秒最多改变的速度d 求这段时间内你最多走了多远</p>
<p>最优的肯定是先把速度从v1升到最大 然后从最大减到v2 使得用的时间不会超多t 因为肯定是足够从v1减为或升到v2的 那么我们只用从两端往中间靠 哪边的速度小 哪边就加上d 知道两边相邻 这样就能保证每次改变的速度都最大 而且最后两端的速度差也不会大于d 也就是最优答案了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">105</span>;</span><br><span class="line">int v[N];</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int v1, v2, t, d, k;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;v1, &amp;v2, &amp;t, &amp;d))</span><br><span class="line">    &#123;</span><br><span class="line">        v[<span class="number">0</span>] = v1, v[t - <span class="number">1</span>] = v2;</span><br><span class="line">        int le = <span class="number">0</span>, ri = t - <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(le &lt; ri - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(v[le] &lt; v[ri]) v[le + <span class="number">1</span>] = v[le++] + d;</span><br><span class="line">            <span class="keyword">else</span> v[ri - <span class="number">1</span>] = v[ri--] + d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; t; ++i) ans += v[i];</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Last modified :   2015-04-13 00:27</span></span><br></pre></td></tr></table></figure>

<p>B. Covered Path</p>
<p>The on-board computer on Polycarp’s car measured that the car speed at the beginning of some section of the path equals <em>v</em>1 meters per second, and in the end it is <em>v</em>2 meters per second. We know that this section of the route took exactly <em>t</em> seconds to pass.</p>
<p>Assuming that at each of the seconds the speed is constant, and between seconds the speed can change at most by <em>d</em> meters per second in absolute value (i.e., the difference in the speed of any two adjacent seconds does not exceed <em>d</em> in absolute value), find the maximum possible length of the path section in meters.<br>Input</p>
<p>The first line contains two integers <em>v</em>1 and <em>v</em>2 (1 ≤ <em>v</em>1, <em>v</em>2 ≤ 100) — the speeds in meters per second at the beginning of the segment and at the end of the segment, respectively.</p>
<p>The second line contains two integers <em>t</em> (2 ≤ <em>t</em> ≤ 100) — the time when the car moves along the segment in seconds, <em>d</em> (0 ≤ <em>d</em> ≤ 10) — the maximum value of the speed change between adjacent seconds.</p>
<p>It is guaranteed that there is a way to complete the segment so that:</p>
<p>Output</p>
<p>Print the maximum possible length of the path segment in meters.<br>Sample test(s)</p>
<p>input 5 6 4 2</p>
<p>output 26<br>input 10 10 10 0</p>
<p>output 100</p>
<p>Note</p>
<p>In the first sample the sequence of speeds of Polycarpus’ car can look as follows: 5, 7, 8, 6. Thus, the total path is 5 + 7 + 8 + 6 &#x3D; 26meters.</p>
<p>In the second sample, as <em>d</em> &#x3D; 0, the car covers the whole segment at constant speed <em>v</em> &#x3D; 10. In <em>t</em> &#x3D; 10 seconds it covers the distance of 100 meters.</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1003 Max Sum(dp，最大连续子序列和)</title>
    <url>/posts/oj/dp/HDU%201003%20Max%20Sum(dp%EF%BC%8C%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C)/</url>
    <content><![CDATA[<h1 id="Max-Sum"><a href="#Max-Sum" class="headerlink" title="Max Sum"></a>Max Sum</h1><p>Problem Description</p>
<p>Given a sequence a[1],a[2],a[3]……a[n], your job is to calculate the max sum of a sub-sequence. For example, given (6,-1,5,4,-7), the max sum in this sequence is 6 + (-1) + 5 + 4 &#x3D; 14.<br>Input</p>
<p>The first line of the input contains an integer T(1&lt;&#x3D;T&lt;&#x3D;20) which means the number of test cases. Then T lines follow, each line starts with a number N(1&lt;&#x3D;N&lt;&#x3D;100000), then N integers followed(all the integers are between -1000 and 1000).<br>Output</p>
<p>For each test case, you should output two lines. The first line is “Case &#x2F;#:”, &#x2F;# means the number of the test case. The second line contains three integers, the Max Sum in the sequence, the start position of the sub-sequence, the end position of the sub-sequence. If there are more than one result, output the first one. Output a blank line between two cases.<br>Sample Input</p>
<p>2 5 6 -1 5 4 -7 7 0 6 -1 1 -6 7 -5<br>Sample Output</p>
<p>Case 1: 14 1 4  Case 2: 7 1 6</p>
<p>题意 求n个数字的最大连续和</p>
<p>DP的入门题目 令d[i]表示以第i个数a为右端的最大连续子序列和 那么很容易得出转移方程 d[i]&#x3D;max(d[i-1]+a,a)</p>
<p>很显然 当第i个数比以第i-1个数为右端的最大和加上第i个数还大的时候 以第i个数为右端的最大和就是第i个数自己了 同时更新左端为自己</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">100005</span>;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int a, cas, ans, l, le, ri, n, d[N];</span><br><span class="line">    scanf (<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">for</span> (int k = <span class="number">1</span>; k &lt;= cas; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        memset (d, <span class="number">0x8f</span>, sizeof (d));</span><br><span class="line">        ans = d[<span class="number">0</span>];</span><br><span class="line">        scanf (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf (<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">            <span class="keyword">if</span> (d[i - <span class="number">1</span>] + a &lt; a)</span><br><span class="line">                d[i] = a, l = i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                d[i] = d[i - <span class="number">1</span>] + a;</span><br><span class="line">            <span class="keyword">if</span> (d[i] &gt; ans)</span><br><span class="line">                ans = d[i], le = l, ri = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">1</span>) printf (<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        printf (<span class="string">&quot;Case %d:\n%d %d %d\n&quot;</span>, k, ans, le, ri);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1024 Max Sum Plus Plus (DP·滚动数组)</title>
    <url>/posts/oj/dp/HDU%201024%20Max%20Sum%20Plus%20Plus%20(DP%C2%B7%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84)/</url>
    <content><![CDATA[<p>题意 从n个数的数组中选出不相交的m段 求被选数的和的最大值</p>
<p>Max Sum 的升级版 不只是要选一段连续的了 而是选m段 思想还是类似 依旧dp</p>
<p>状态和状态转移方程不是很难想 在 Max Sum 这个问题中 dp[i] 表示的是以第i个数结尾的一段的 Max Sum 由于这里还有一个多少段的状态 于是这里令 dp[i][j] 表示在前 i 个数中选取 j 组 且第 i 个数在最后一组中的 Max Sum Plus Plus</p>
<p>那么现在对于第i个数有两种决策</p>
<p>1, 第 i 个数和第 i-1 个数连接成一段<strong>dp[i][j] &#x3D; dp[i-1][j] + a[i]</strong></p>
<p>2, 第 i 个数自己单独做一段 那么前面就需要有 j-1 段<strong>dp[i][j] &#x3D; max{dp[k][j-1] | j - 1&lt;&#x3D; k &lt; i} + a[i]</strong></p>
<p>那么也就有了状态转移方程<strong>dp[i][j] &#x3D; max(dp[i-1][j], max{dp[k][j-1] | j - 1&lt;&#x3D; k &lt; i}) + a[i];</strong></p>
<p>有了方程就可以写了呀 我们先不考虑复杂度问题 假设时间空间都是无限的 恩 无限的</p>
<p>那么很容易有下面的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">10005</span>, <span class="variable constant_">INF</span> = <span class="number">1e9</span>;</span><br><span class="line">int a[N], dp[N][N];</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="title function_">memset</span>(dp, <span class="number">0</span>, sizeof dp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//dp[i][j] 表示前i个数第i个数被选 选j组的Max Sum Plus Plus</span></span><br><span class="line">        <span class="comment">//dp[i][j] = max(dp[i-1][j], max&#123;dp[k][j-1], j - 1 &lt;= k &lt; i&#125;) + a[i]</span></span><br><span class="line">        int ans = -<span class="variable constant_">INF</span>;</span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(int i = j; i &lt;= n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = i - <span class="number">1</span> &lt; j ? -<span class="variable constant_">INF</span> : dp[i - <span class="number">1</span>][j]; <span class="comment">//i-1 &lt; j时dp[i - 1][j]是没意义的</span></span><br><span class="line">                <span class="keyword">for</span>(int k = j - <span class="number">1</span>; k &lt; i; ++k)</span><br><span class="line">                    dp[i][j] = <span class="title function_">max</span>(dp[i][j], dp[k][j - <span class="number">1</span>]);</span><br><span class="line">                dp[i][j] += a[i];</span><br><span class="line">                <span class="keyword">if</span>(j == m) ans = <span class="title function_">max</span>(ans, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可是并不是无限的呀 上面这个时间复杂度0(n&#x2F;*n&#x2F;*m) 空间复杂度O(n&#x2F;*n) n高达1000000 简直可怕</p>
<p>再来看看转移方程<strong>dp[i][j] &#x3D; max(dp[i-1][j],max{dp[k][j-1] | j - 1&lt;&#x3D; k &lt; i}) + a[i];</strong></p>
<p>发现更新 dp[i][j] 的时候只用到了 dp[.][j] 和 dp[.][j-1] 里面的值 也就是 dp[.][0~j-2] 都已经没用了 那也就不用存这些没用的了 也就是j只用开两维就够了 也就是所谓的滚动数组了 用 dp[.][1] 和 dp[.][0] 来轮换表示 dp[.][j] 和 dp[.][j-1] 这样空间复杂度就降到了O(n) 这是可以接受的 那么有空间优化后的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1000005</span>, <span class="variable constant_">INF</span> = <span class="number">1e9</span>;</span><br><span class="line">int a[N], dp[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="title function_">memset</span>(dp, <span class="number">0</span>, sizeof dp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//dp[i][j] 表示前i个数第i个数被选 选j组的Max Sum Plus Plus</span></span><br><span class="line">        <span class="comment">//dp[i][j] = max(dp[i-1][j], max&#123;dp[k][j-1], j - 1 &lt;= k &lt; i&#125;) + a[i]</span></span><br><span class="line">        int ans = -<span class="variable constant_">INF</span>, j0 = <span class="number">0</span>, j1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(int i = j; i &lt;= n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//dp[i][j0]存的是dp[i][j-1]的值 dp[i][j1] 存的是dp[i][j]的值</span></span><br><span class="line">                dp[i][j1] = i - <span class="number">1</span> &lt; j ? -<span class="variable constant_">INF</span> : dp[i - <span class="number">1</span>][j1]; <span class="comment">//i-1 &lt; j时dp[i - 1][j]是没意义的</span></span><br><span class="line">                <span class="keyword">for</span>(int k = j - <span class="number">1</span>; k &lt; i; ++k)</span><br><span class="line">                    dp[i][j1] = <span class="title function_">max</span>(dp[i][j1], dp[k][j0]);</span><br><span class="line">                dp[i][j1] += a[i];</span><br><span class="line">                <span class="keyword">if</span>(j == m) ans = <span class="title function_">max</span>(ans, dp[i][j1]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">swap</span>(j0, j1); <span class="comment">//滚动数组交换0, 1  因为这轮的j在下轮就变成j - 1了</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在空间问题解决了 那么时间问题呢 来看这段代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;span style=<span class="string">&quot;white-space:pre&quot;</span>&gt;	&lt;/span&gt;<span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">      &lt;span style=<span class="string">&quot;white-space:pre&quot;</span>&gt;	&lt;/span&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(int i = j; i &lt;= n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                dp[i][j1] = i - <span class="number">1</span> &lt; j ? -<span class="variable constant_">INF</span> : dp[i - <span class="number">1</span>][j1]; <span class="comment">//</span></span><br><span class="line">                <span class="keyword">for</span>(int k = j - <span class="number">1</span>; k &lt; i; ++k)</span><br><span class="line">                    dp[i][j1] = <span class="title function_">max</span>(dp[i][j1], dp[k][j0]); <span class="comment">//这轮循环只比上轮多了个dp[i-1][j0]！！！</span></span><br><span class="line">                dp[i][j1] += a[i];</span><br><span class="line">                <span class="keyword">if</span>(j == m) ans = <span class="title function_">max</span>(ans, dp[i][j1]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">swap</span>(j0, j1); <span class="comment">//</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>看注释部分！！！ 这轮只比上轮多了一个数 我还循环那么多是什么鬼 把上轮的值 ma 记录下来 这轮只用和 dp[i-1][j0] 比较一下就行了 那么就有了可以ac的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1000005</span>, <span class="variable constant_">INF</span> = <span class="number">1e9</span>;</span><br><span class="line">int a[N], dp[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="title function_">memset</span>(dp, <span class="number">0</span>, sizeof dp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//dp[i][j] 表示前i个数第i个数被选 选j组的Max Sum Plus Plus</span></span><br><span class="line">        <span class="comment">//dp[i][j] = max(dp[i-1][j], max&#123;dp[k][j-1], j - 1 &lt;= k &lt; i&#125;) + a[i]</span></span><br><span class="line">        int ans = -<span class="variable constant_">INF</span>, j0 = <span class="number">0</span>, j1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            int ma = dp[j - <span class="number">1</span>][j1] = -<span class="variable constant_">INF</span>; <span class="comment">//dp[j - 1][j]是没意义的</span></span><br><span class="line">            <span class="keyword">for</span>(int i = j; i &lt;= n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//dp[i][j0]存的是dp[i][j-1]的值 dp[i][j1]存的是dp[i][j]的值</span></span><br><span class="line">                ma = <span class="title function_">max</span>(ma, dp[i - <span class="number">1</span>][j0]); <span class="comment">//ma维护max&#123;dp[k][j-1], j - 1 &lt;= k &lt; i&#125;</span></span><br><span class="line">                dp[i][j1] = <span class="title function_">max</span>(dp[i - <span class="number">1</span>][j1], ma) + a[i];</span><br><span class="line">                <span class="keyword">if</span>(j == m) ans = <span class="title function_">max</span>(ans, dp[i][j1]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">swap</span>(j0, j1); <span class="comment">//滚动数组交换0, 1  因为这轮的j在下轮就变成j - 1了</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Max-Sum-Plus-Plus"><a href="#Max-Sum-Plus-Plus" class="headerlink" title="Max Sum Plus Plus"></a>Max Sum Plus Plus</h1><p>Problem Description</p>
<p>Now I think you have got an AC in Ignatius.L’s “Max Sum” problem. To be a brave ACMer, we always challenge ourselves to more difficult problems. Now you are faced with a more difficult problem.<br>Given a consecutive number sequence S <em>1</em>, S <em>2</em>, S <em>3</em>, S <em>4</em> … S <em>x</em>, … S <em>n</em> (1 ≤ x ≤ n ≤ 1,000,000, -32768 ≤ S <em>x</em> ≤ 32767). We define a function sum(i, j) &#x3D; S <em>i</em> + … + S <em>j</em> (1 ≤ i ≤ j ≤ n).<br>Now given an integer m (m &gt; 0), your task is to find m pairs of i and j which make sum(i <em>1</em>, j <em>1</em>) + sum(i <em>2</em>, j <em>2</em>) + sum(i <em>3</em>, j <em>3</em>) + … + sum(i <em>m</em>, j <em>m</em>) maximal (i <em>x</em> ≤ i <em>y</em> ≤ j <em>x</em> or i <em>x</em> ≤ j <em>y</em> ≤ j <em>x</em> is not allowed).<br>But I&#96;m lazy, I don’t want to write a special-judge module, so you don’t have to output m pairs of i and j, just output the maximal summation of sum(i <em>x</em>, j <em>x</em>)(1 ≤ x ≤ m) instead. ^_^<br>Input</p>
<p>Each test case will begin with two integers m and n, followed by n integers S <em>1</em>, S <em>2</em>, S <em>3</em> … S <em>n</em>.<br>Process to the end of file.<br>Output</p>
<p>Output the maximal summation described above in one line.<br>Sample Input</p>
<p>1 3 1 2 3 2 6 -1 4 -2 3 -2 3<br>Sample Output</p>
<p>6 8</p>
<p><em>Hint</em> Huge input, scanf and dynamic programming is recommended.<br>Author</p>
<p>JGShining（极光炫影）</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1058 Humble Numbers（DP,数）</title>
    <url>/posts/oj/dp/HDU%201058%20Humble%20Numbers%EF%BC%88DP,%E6%95%B0%EF%BC%89/</url>
    <content><![CDATA[<p>题意 所有只能被2，3，5，7这4个素数整除的数称为Humble Number 输入n 输出第n个Humble Number</p>
<p>1是第一个humble number 对于一个Humble Number a 有2&#x2F;<em>a,3&#x2F;<em>a,5&#x2F;<em>a,7&#x2F;<em>a都是Humble Number 可以以1为基数 依次展开即可得到一定范围内的Humble Number 用i,j,k,l分别记录 2，3，5，7分别乘到了第几个Humble Number 当前在计算第cnt个Humble Number 那么有 hum[cnt] &#x3D; min ( hum[i] &#x2F;</em> 2, hum[j] &#x2F;</em> 3, hum[k] &#x2F;</em> 5, hum[l] &#x2F;</em> 7) 然后对应min的i或j或k或l就加1 当cnt到达了n 结果就出来了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">5843</span>;</span><br><span class="line">int hum[N], cnt, n;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int i = <span class="number">1</span>, j = <span class="number">1</span>, k = <span class="number">1</span>, l = hum[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (cnt = <span class="number">2</span>; cnt &lt; N; ++cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        hum[cnt] = min ( <span class="title function_">min</span>(hum[i] * <span class="number">2</span>, hum[j] * <span class="number">3</span>), min (hum[k] * <span class="number">5</span>, hum[l] * <span class="number">7</span>));</span><br><span class="line">        <span class="keyword">if</span> (hum[cnt] == hum[i] * <span class="number">2</span>) ++i;</span><br><span class="line">        <span class="keyword">if</span> (hum[cnt] == hum[j] * <span class="number">3</span>) ++j;</span><br><span class="line">        <span class="keyword">if</span> (hum[cnt] == hum[k] * <span class="number">5</span>) ++k;</span><br><span class="line">        <span class="keyword">if</span> (hum[cnt] == hum[l] * <span class="number">7</span>) ++l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (scanf (<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        printf (<span class="string">&quot;The %d&quot;</span>, n);</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">100</span> != <span class="number">11</span> &amp;&amp; n % <span class="number">10</span> == <span class="number">1</span>) printf (<span class="string">&quot;st &quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">100</span> != <span class="number">12</span> &amp;&amp; n % <span class="number">10</span> == <span class="number">2</span>) printf (<span class="string">&quot;nd &quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">100</span> != <span class="number">13</span> &amp;&amp; n % <span class="number">10</span> == <span class="number">3</span>) printf (<span class="string">&quot;rd &quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> printf (<span class="string">&quot;th &quot;</span>);</span><br><span class="line">        printf (<span class="string">&quot;humble number is %d.\n&quot;</span>, hum[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Humble-Numbers"><a href="#Humble-Numbers" class="headerlink" title="Humble Numbers"></a>Humble Numbers</h1><p>Problem Description</p>
<p>A number whose only prime factors are 2,3,5 or 7 is called a humble number. The sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 24, 25, 27, … shows the first 20 humble numbers.<br>Write a program to find and print the nth element in this sequence<br>Input</p>
<p>The input consists of one or more test cases. Each test case consists of one integer n with 1 &lt;&#x3D; n &lt;&#x3D; 5842. Input is terminated by a value of zero (0) for n.<br>Output</p>
<p>For each test case, print one line saying “The nth humble number is number.”. Depending on the value of n, the correct suffix “st”, “nd”, “rd”, or “th” for the ordinal number nth has to be used like it is shown in the sample output.<br>Sample Input</p>
<p>1 2 3 4 11 12 13 21 22 23 100 1000 5842 0<br>Sample Output</p>
<p>The 1st humble number is 1. The 2nd humble number is 2. The 3rd humble number is 3. The 4th humble number is 4. The 11th humble number is 12. The 12th humble number is 14. The 13th humble number is 15. The 21st humble number is 28. The 22nd humble number is 30. The 23rd humble number is 32. The 100th humble number is 450. The 1000th humble number is 385875. The 5842nd humble number is 2000000000.</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1069 Monkey and Banana(DP 长方体堆放问题)</title>
    <url>/posts/oj/dp/HDU%201069%20Monkey%20and%20Banana(DP%20%E9%95%BF%E6%96%B9%E4%BD%93%E5%A0%86%E6%94%BE%E9%97%AE%E9%A2%98)/</url>
    <content><![CDATA[<p>题意 给你n种长方体 每种都有无穷个 三条棱长为a,b,c 当一个长方体的长宽都小于另一个时 这个长方体就可以堆在另一个上面 求这些长方体能堆起的最大高度</p>
<p>每个长方体都有6种放置方式 但只有三种高度 分别为a,b,c 为了便于操坐 可以把一个长方体分为三个 每个的高度都是唯一的 然后就可以用最长连通来求了 令d[i]表示以第i个长方体为最顶上一个时的最大高度 当第i个长方体的长和宽小于第j个的长和宽或宽和长时 第i个就可以放在第j个上面 即 d[i]&#x3D;max(d[i],d[j]+a[i].h)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">35</span> * <span class="number">3</span>;</span><br><span class="line">int d[N], n;</span><br><span class="line">struct <span class="title class_">Cube</span></span><br><span class="line">&#123;</span><br><span class="line">    int a, b, c;</span><br><span class="line">    <span class="title class_">Cube</span> (int aa = <span class="number">0</span>, int bb = <span class="number">0</span>, int cc = <span class="number">0</span>) : a (aa), b (bb), c (cc) &#123;&#125;</span><br><span class="line">&#125; cub[N];</span><br><span class="line"></span><br><span class="line">int dp (int i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (d[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> d[i];</span><br><span class="line">    d[i] = cub[i].<span class="property">c</span>;</span><br><span class="line">    <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= <span class="number">3</span> * n; ++j)</span><br><span class="line">        <span class="keyword">if</span> ( (cub[i].<span class="property">a</span> &lt; cub[j].<span class="property">a</span> &amp;&amp; cub[i].<span class="property">b</span> &lt; cub[j].<span class="property">b</span>) || (cub[i].<span class="property">a</span> &lt; cub[j].<span class="property">b</span> &amp;&amp; cub[i].<span class="property">b</span> &lt; cub[j].<span class="property">a</span>))</span><br><span class="line">            d[i] = max (d[i], dp (j) + cub[i].<span class="property">c</span>);</span><br><span class="line">    <span class="keyword">return</span> d[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas = <span class="number">0</span>, ans, a, b, c;</span><br><span class="line">    <span class="keyword">while</span> (scanf (<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        memset (d, <span class="number">0</span>, sizeof (d));</span><br><span class="line">        <span class="keyword">for</span> (int i = ans = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf (<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">            cub[<span class="number">3</span> * i + <span class="number">1</span>] = <span class="title class_">Cube</span> (a, b, c);</span><br><span class="line">            cub[<span class="number">3</span> * i + <span class="number">2</span>] = <span class="title class_">Cube</span> (a, c, b);</span><br><span class="line">            cub[<span class="number">3</span> * i + <span class="number">3</span>] = <span class="title class_">Cube</span> (b, c, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= <span class="number">3</span> * n; ++i)</span><br><span class="line">            ans = max (ans, dp (i));</span><br><span class="line">        printf (<span class="string">&quot;Case %d: maximum height = %d\n&quot;</span>, ++cas, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Monkey-and-Banana"><a href="#Monkey-and-Banana" class="headerlink" title="Monkey and Banana"></a>Monkey and Banana</h1><p>Problem Description</p>
<p>A group of researchers are designing an experiment to test the IQ of a monkey. They will hang a banana at the roof of a building, and at the mean time, provide the monkey with some blocks. If the monkey is clever enough, it shall be able to reach the banana by placing one block on the top another to build a tower and climb up to get its favorite food.<br>The researchers have n types of blocks, and an unlimited supply of blocks of each type. Each type-i block was a rectangular solid with linear dimensions (xi, yi, zi). A block could be reoriented so that any two of its three dimensions determined the dimensions of the base and the other dimension was the height.<br>They want to make sure that the tallest tower possible by stacking blocks can reach the roof. The problem is that, in building a tower, one block could only be placed on top of another block as long as the two base dimensions of the upper block were both strictly smaller than the corresponding base dimensions of the lower block because there has to be some space for the monkey to step on. This meant, for example, that blocks oriented to have equal-sized bases couldn’t be stacked.<br>Your job is to write a program that determines the height of the tallest tower the monkey can build with a given set of blocks.<br>Input</p>
<p>The input file will contain one or more test cases. The first line of each test case contains an integer n,<br>representing the number of different blocks in the following data set. The maximum value for n is 30.<br>Each of the next n lines contains three integers representing the values xi, yi and zi.<br>Input is terminated by a value of zero (0) for n.<br>Output</p>
<p>For each test case, print one line containing the case number (they are numbered sequentially starting from 1) and the height of the tallest possible tower in the format “Case case: maximum height &#x3D; height”.<br>Sample Input</p>
<p>1 10 20 30 2 6 8 10 5 5 5 7 1 1 1 2 2 2 3 3 3 4 4 4 5 5 5 6 6 6 7 7 7 5 31 41 59 26 53 58 97 93 23 84 62 64 33 83 27 0<br>Sample Output</p>
<p>Case 1: maximum height &#x3D; 40 Case 2: maximum height &#x3D; 21 Case 3: maximum height &#x3D; 28 Case 4: maximum height &#x3D; 342</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1074 Doing Homework（DP·状态压缩）</title>
    <url>/posts/oj/dp/HDU%201074%20Doing%20Homework%EF%BC%88DP%C2%B7%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%EF%BC%89/</url>
    <content><![CDATA[<p>题意 有n个作业要做 给你每个作业的最后期限 和做完这个作业需要的时间 作业每超过最后期限一天就会扣一分 只能把一个作业做完了再做另一个作业 问做完所有作业至少扣多少分</p>
<p>作业最多只有15个 看到这个数字容易想到是状态压缩 dp[i]表示i对应状态的最小扣分 i转换为二进制后为1的位表明该位对应的作业已经做了 为0的位没做 那么dp[i] &#x3D; min{dp[k] + cost |k为将某一位变成1后等于 i 的状态}</p>
<p>由于要打印路径 所有还需要记录每个状态的上一个状态pre</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">16</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line">int d[N], c[N], n;</span><br><span class="line">int dp[M], pre[M], t[M];</span><br><span class="line">char s[N][<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span>(<span class="params">int k</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="title function_">print</span>(pre[k]);</span><br><span class="line">    k -= pre[k];</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span> &lt;&lt; i) <span class="title function_">puts</span>(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int T, m, cost;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, s[i], &amp;d[i], &amp;c[i]);</span><br><span class="line">        <span class="title function_">memset</span>(dp, <span class="number">0x3f</span>, <span class="title function_">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>] = t[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">//边界 所有作业都没做的扣分为0</span></span><br><span class="line">        m = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((i &amp; <span class="number">1</span> &lt;&lt; j) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                int k = i - (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                t[i] = t[k] + c[j];</span><br><span class="line">                cost = t[i] &gt; d[j] ? t[i] - d[j] : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[k] + cost &lt;= dp[i])  <span class="comment">//&#x27;=&#x27;保证字典序最小</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = dp[k] + cost;</span><br><span class="line">                    pre[i] =  k;  <span class="comment">//记录路径</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[m - <span class="number">1</span>]);</span><br><span class="line">        <span class="title function_">print</span>(m - <span class="number">1</span>);  <span class="comment">//打印路径</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Doing-Homework"><a href="#Doing-Homework" class="headerlink" title="Doing Homework"></a>Doing Homework</h1><p>Problem Description</p>
<p>Ignatius has just come back school from the 30th ACM&#x2F;ICPC. Now he has a lot of homework to do. Every teacher gives him a deadline of handing in the homework. If Ignatius hands in the homework after the deadline, the teacher will reduce his score of the final test, 1 day for 1 point. And as you know, doing homework always takes a long time. So Ignatius wants you to help him to arrange the order of doing homework to minimize the reduced score.<br>Input</p>
<p>The input contains several test cases. The first line of the input is a single integer T which is the number of test cases. T test cases follow.<br>Each test case start with a positive integer N(1&lt;&#x3D;N&lt;&#x3D;15) which indicate the number of homework. Then N lines follow. Each line contains a string S(the subject’s name, each string will at most has 100 characters) and two integers D(the deadline of the subject), C(how many days will it take Ignatius to finish this subject’s homework).<br>Note: All the subject names are given in the alphabet increasing order. So you may process the problem much easier.<br>Output</p>
<p>For each test case, you should output the smallest total reduced score, then give out the order of the subjects, one subject in a line. If there are more than one orders, you should output the alphabet smallest one.<br>Sample Input</p>
<p>2 3 Computer 3 3 English 20 1 Math 3 2 3 Computer 3 3 English 6 3 Math 6 3<br>Sample Output</p>
<p>2 Computer Math English 3 Computer English Math</p>
<p><em>Hint</em> In the second test case, both Computer-&gt;English-&gt;Math and Computer-&gt;Math-&gt;English leads to reduce 3 points, but the word “English” appears earlier than the word “Math”, so we choose the first order. That is so-called alphabet order.</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1078 FatMouse and Cheese(DP)</title>
    <url>/posts/oj/dp/HDU%201078%20FatMouse%20and%20Cheese(DP)/</url>
    <content><![CDATA[<p>题意 老鼠在一个小镇吃奶酪 城镇可以看成一个n&#x2F;*n的矩阵 其中每个格子都有一定数量的奶酪mat[i][j] 老鼠从(0,0) 开始吃 而且下个吃的格子里的奶酪必须比上个格子多 老鼠只能水平方向或者垂直方向走 而且每次走的距离不能超过k 求老鼠最多能吃多少奶酪</p>
<p>起点是固定的 比较容易 直接记忆化搜索</p>
<p>令d[i][j]表示以(i,j)为终点的最优解 那么对于所有(i,j)能到达的点(x,y)有 d[i][j]&#x3D;max(d[i][j],d[x][y]+mat[x][y]) 结果直接输出d[0][0]就行了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">105</span>;</span><br><span class="line">#define xx i+k*x[l]</span><br><span class="line">#define yy j+k*y[l]</span><br><span class="line">int d[N][N], mat[N][N], m, n;</span><br><span class="line">int x[<span class="number">4</span>] = &#123; -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, y[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">int dp (int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (d[i][j] &gt; <span class="number">0</span>) <span class="keyword">return</span> d[i][j];</span><br><span class="line">    d[i][j] = mat[i][j];</span><br><span class="line">    <span class="keyword">for</span> (int k = <span class="number">1</span>; k &lt;= m; ++k)</span><br><span class="line">        <span class="keyword">for</span> (int l = <span class="number">0</span>; l &lt;= <span class="number">4</span>; ++l)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (xx &gt; <span class="number">0</span> &amp;&amp; xx &lt;= n &amp;&amp; yy &gt; <span class="number">0</span> &amp;&amp; yy &lt;= n &amp;&amp; mat[xx][yy] &gt; mat[i][j])</span><br><span class="line">                d[i][j] = max (d[i][j], mat[i][j] + dp (xx, yy));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> d[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m), n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        memset (d, -<span class="number">1</span>, sizeof (d));</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">                scanf (<span class="string">&quot;%d&quot;</span>, &amp;mat[i][j]);</span><br><span class="line">        printf (<span class="string">&quot;%d\n&quot;</span>, dp (<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="FatMouse-and-Cheese"><a href="#FatMouse-and-Cheese" class="headerlink" title="FatMouse and Cheese"></a>FatMouse and Cheese</h1><p>Problem Description</p>
<p>FatMouse has stored some cheese in a city. The city can be considered as a square grid of dimension n: each grid location is labelled (p,q) where 0 &lt;&#x3D; p &lt; n and 0 &lt;&#x3D; q &lt; n. At each grid location Fatmouse has hid between 0 and 100 blocks of cheese in a hole. Now he’s going to enjoy his favorite food.<br>FatMouse begins by standing at location (0,0). He eats up the cheese where he stands and then runs either horizontally or vertically to another location. The problem is that there is a super Cat named Top Killer sitting near his hole, so each time he can run at most k locations to get into the hole before being caught by Top Killer. What is worse – after eating up the cheese at one location, FatMouse gets fatter. So in order to gain enough energy for his next run, he has to run to a location which have more blocks of cheese than those that were at the current hole.<br>Given n, k, and the number of blocks of cheese at each grid location, compute the maximum amount of cheese FatMouse can eat before being unable to move.<br>Input</p>
<p>There are several test cases. Each test case consists of<br>a line containing two integers between 1 and 100: n and k<br>n lines, each with n numbers: the first line contains the number of blocks of cheese at locations (0,0) (0,1) … (0,n-1); the next line contains the number of blocks of cheese at locations (1,0), (1,1), … (1,n-1), and so on.<br>The input ends with a pair of -1’s.<br>Output</p>
<p>For each test case output in a line the single integer giving the number of blocks of cheese collected.<br>Sample Input</p>
<p>3 1 1 2 5 10 11 6 12 12 7 -1 -1<br>Sample Output</p>
<p>37</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1087 Super Jumping! Jumping! Jumping!(DP)</title>
    <url>/posts/oj/dp/HDU%201087%20Super%20Jumping!%20Jumping!%20Jumping!(DP)/</url>
    <content><![CDATA[<h1 id="Super-Jumping-Jumping-Jumping"><a href="#Super-Jumping-Jumping-Jumping" class="headerlink" title="Super Jumping! Jumping! Jumping!"></a>Super Jumping! Jumping! Jumping!</h1><p>Problem Description</p>
<p>Nowadays, a kind of chess game called “Super Jumping! Jumping! Jumping!” is very popular in HDU. Maybe you are a good boy, and know little about this game, so I introduce it to you now.<br><img src="/../images/cn-data-images-1087-1.jpg.png"><br>The game can be played by two or more than two players. It consists of a chessboard（棋盘）and some chessmen（棋子）, and all chessmen are marked by a positive integer or “start” or “end”. The player starts from start-point and must jumps into end-point finally. In the course of jumping, the player will visit the chessmen in the path, but everyone must jumps from one chessman to another absolutely bigger (you can assume start-point is a minimum and end-point is a maximum.). And all players cannot go backwards. One jumping can go from a chessman to next, also can go across many chessmen, and even you can straightly get to end-point from start-point. Of course you get zero point in this situation. A player is a winner if and only if he can get a bigger score according to his jumping solution. Note that your score comes from the sum of value on the chessmen in you jumping path.<br>Your task is to output the maximum value according to the given chessmen list.<br>Input</p>
<p>Input contains multiple test cases. Each test case is described in a line as follow:<br>N value_1 value_2 …value_N<br>It is guarantied that N is not more than 1000 and all value_i are in the range of 32-int.<br>A test case starting with 0 terminates the input and this test case is not to be processed.<br>Output</p>
<p>For each case, print the maximum according to rules, and one line one case.<br>Sample Input</p>
<p>3 1 3 2 4 1 2 3 4 4 3 3 2 1 0<br>Sample Output</p>
<p>4 10 3</p>
<p>题意 求n个数字的和最大的递增子序列</p>
<p>基础的dp题目 令d[i]表示以第i个数字结尾的和最大的递增子序列 有d[i]&#x3D;max(d[i],d[j]+a[i]) j为1到a之间的数 且a[i]&gt;a[j]</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1005</span>;</span><br><span class="line">int a[N], d[N];</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int ans,n;</span><br><span class="line">    <span class="keyword">while</span> (scanf (<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf (<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">            d[i]=a[i];</span><br><span class="line">            <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;i;++j)</span><br><span class="line">                <span class="keyword">if</span>(a[i]&gt;a[j]) d[i]=<span class="title function_">max</span>(d[i],d[j]+a[i]);</span><br><span class="line">            ans=<span class="title function_">max</span>(ans,d[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1114 Piggy-Bank(完全背包 DP)</title>
    <url>/posts/oj/dp/HDU%201114%20Piggy-Bank(%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%20DP)/</url>
    <content><![CDATA[<p>题意 知道空存钱罐的重量和装满钱的存钱罐的重量及每种币值的重量 求存钱罐里至少有多少钱</p>
<p>裸的完全背包 但是是求最小值 所以初始0要变成初始INF max也要变成min</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">10005</span>, <span class="variable constant_">INF</span> = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">int val[N], wei[N], d[N];</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas, t, s, n;</span><br><span class="line">    scanf (<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span> (cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;t, &amp;s);</span><br><span class="line">        s -= t;</span><br><span class="line">        scanf (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;val[i], &amp;wei[i]);</span><br><span class="line">        memset (d, <span class="number">0x3f</span>, sizeof (d));</span><br><span class="line">        d[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (int j = wei[i]; j &lt;= s; ++j)</span><br><span class="line">                d[j] = min (d[j], d[j - wei[i]] + val[i]);</span><br><span class="line">        <span class="keyword">if</span> (d[s] == <span class="variable constant_">INF</span>) printf (<span class="string">&quot;This is impossible.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> printf (<span class="string">&quot;The minimum amount of money in the piggy-bank is %d.\n&quot;</span>, d[s]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Piggy-Bank"><a href="#Piggy-Bank" class="headerlink" title="Piggy-Bank"></a>Piggy-Bank</h1><p>Problem Description</p>
<p>Before ACM can do anything, a budget must be prepared and the necessary financial support obtained. The main income for this action comes from Irreversibly Bound Money (IBM). The idea behind is simple. Whenever some ACM member has any small money, he takes all the coins and throws them into a piggy-bank. You know that this process is irreversible, the coins cannot be removed without breaking the pig. After a sufficiently long time, there should be enough cash in the piggy-bank to pay everything that needs to be paid.<br>But there is a big problem with piggy-banks. It is not possible to determine how much money is inside. So we might break the pig into pieces only to find out that there is not enough money. Clearly, we want to avoid this unpleasant situation. The only possibility is to weigh the piggy-bank and try to guess how many coins are inside. Assume that we are able to determine the weight of the pig exactly and that we know the weights of all coins of a given currency. Then there is some minimum amount of money in the piggy-bank that we can guarantee. Your task is to find out this worst case and determine the minimum amount of cash inside the piggy-bank. We need your help. No more prematurely broken pigs!<br>Input</p>
<p>The input consists of T test cases. The number of them (T) is given on the first line of the input file. Each test case begins with a line containing two integers E and F. They indicate the weight of an empty pig and of the pig filled with coins. Both weights are given in grams. No pig will weigh more than 10 kg, that means 1 &lt;&#x3D; E &lt;&#x3D; F &lt;&#x3D; 10000. On the second line of each test case, there is an integer number N (1 &lt;&#x3D; N &lt;&#x3D; 500) that gives the number of various coins used in the given currency. Following this are exactly N lines, each specifying one coin type. These lines contain two integers each, Pand W (1 &lt;&#x3D; P &lt;&#x3D; 50000, 1 &lt;&#x3D; W &lt;&#x3D;10000). P is the value of the coin in monetary units, W is it’s weight in grams.<br>Output</p>
<p>Print exactly one line of output for each test case. The line must contain the sentence “The minimum amount of money in the piggy-bank is X.” where X is the minimum amount of money that can be achieved using coins with the given total weight. If the weight cannot be reached exactly, print a line “This is impossible.”.<br>Sample Input</p>
<p>3 10 110 2 1 1 30 50 10 110 2 1 1 50 30 1 6 2 10 3 20 4<br>Sample Output</p>
<p>The minimum amount of money in the piggy-bank is 60. The minimum amount of money in the piggy-bank is 100. This is impossible.</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1160 FatMouse&#39;s Speed(DP)</title>
    <url>/posts/oj/dp/HDU%201160%20FatMouse&#39;s%20Speed(DP)/</url>
    <content><![CDATA[<p>题意 输入n个老鼠的体重和速度 从里面找出最长的序列 是的重量递增时速度递减</p>
<p>简单的DP 令d[i]表示以第i个老鼠为所求序列最后一个时序列的长度 对与每个老鼠i 遍历所有老鼠j 当(w[i] &gt; w[j]) &amp;&amp; (s[i] &lt; s[j])时 有d[i]&#x3D;max(d[i],d[j]+1) 输出路径记下最后一个递归就行了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int M=<span class="number">1005</span>;</span><br><span class="line">int w[M], s[M], d[M], pre[M], n, key;</span><br><span class="line"></span><br><span class="line">int dp (int i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (d[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> d[i];</span><br><span class="line">    <span class="keyword">for</span> (int j = d[i] = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        <span class="keyword">if</span> ( (w[i] &gt; w[j]) &amp;&amp; (s[i] &lt; s[j]) &amp;&amp; (d[i] &lt; dp (j) + <span class="number">1</span>))</span><br><span class="line">            d[i] = d[j] + <span class="number">1</span>, pre[i] = j;</span><br><span class="line">    <span class="keyword">return</span> d[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> print (int i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pre[i])</span><br><span class="line">        print (pre[i]);</span><br><span class="line">    printf (<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (scanf (<span class="string">&quot;%d %d&quot;</span>, &amp;w[n], &amp;s[++n]) != <span class="variable constant_">EOF</span>);</span><br><span class="line">    <span class="keyword">for</span> (int i = key =<span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (dp (i) &gt; dp (key)) key = i;</span><br><span class="line">    printf (<span class="string">&quot;%d\n&quot;</span>, d[key]);</span><br><span class="line">    print (key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="FatMouse’s-Speed"><a href="#FatMouse’s-Speed" class="headerlink" title="FatMouse’s Speed"></a>FatMouse’s Speed</h1><p>Problem Description</p>
<p>FatMouse believes that the fatter a mouse is, the faster it runs. To disprove this, you want to take the data on a collection of mice and put as large a subset of this data as possible into a sequence so that the weights are increasing, but the speeds are decreasing.<br>Input</p>
<p>Input contains data for a bunch of mice, one mouse per line, terminated by end of file.<br>The data for a particular mouse will consist of a pair of integers: the first representing its size in grams and the second representing its speed in centimeters per second. Both integers are between 1 and 10000. The data in each test case will contain information for at most 1000 mice.<br>Two mice may have the same weight, the same speed, or even the same weight and speed.<br>Output</p>
<p>Your program should output a sequence of lines of data; the first line should contain a number n; the remaining n lines should each contain a single positive integer (each one representing a mouse). If these n integers are m[1], m[2],…, m[n] then it must be the case that<br>W[m[1]] &lt; W[m[2]] &lt; … &lt; W[m[n]]<br>and<br>S[m[1]] &gt; S[m[2]] &gt; … &gt; S[m[n]]<br>In order for the answer to be correct, n should be as large as possible.<br>All inequalities are strict: weights must be strictly increasing, and speeds must be strictly decreasing. There may be many correct outputs for a given input, your program only needs to find one.<br>Sample Input</p>
<p>6008 1300 6000 2100 500 2000 1000 4000 1100 3000 6000 2000 8000 1400 6000 1200 2000 1900<br>Sample Output</p>
<p>4 4 5 9 7</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1171 Big Event in HDU（多重背包）</title>
    <url>/posts/oj/dp/HDU%201171%20Big%20Event%20in%20HDU%EF%BC%88%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Big-Event-in-HDU"><a href="#Big-Event-in-HDU" class="headerlink" title="Big Event in HDU"></a>Big Event in HDU</h1><p>Problem Description</p>
<p>Nowadays, we all know that Computer College is the biggest department in HDU. But, maybe you don’t know that Computer College had ever been split into Computer College and Software College in 2002.<br>The splitting is absolutely a big event in HDU! At the same time, it is a trouble thing too. All facilities must go halves. First, all facilities are assessed, and two facilities are thought to be same if they have the same value. It is assumed that there is N (0&lt;N&lt;1000) kinds of facilities (different value, different kinds).<br>Input</p>
<p>Input contains multiple test cases. Each test case starts with a number N (0 &lt; N &lt;&#x3D; 50 – the total number of different facilities). The next N lines contain an integer V (0&lt;V&lt;&#x3D;50 –value of facility) and an integer M (0&lt;M&lt;&#x3D;100 –corresponding number of the facilities) each. You can assume that all V are different.<br>A test case starting with a negative integer terminates input and this test case is not to be processed.<br>Output</p>
<p>For each case, print one line containing two integers A and B which denote the value of Computer College and Software College will get respectively. A and B should be as equal as possible. At the same time, you should guarantee that A is not less than B.<br>Sample Input</p>
<p>2 10 1 20 1 3 10 1 20 2 30 1 -1<br>Sample Output</p>
<p>20 10 40 40</p>
<p>题意 把一堆东西尽量分为两份 第一份不小于第二份</p>
<p>把所有东西的总价值s除以2 让它装尽量多的东西作为第二份 剩下的就是第一份了</p>
<p>题目有个小坑点 是以负数作为结束条件的 不是-1 还有不要开始把s&#x2F;&#x3D;2 后来第一份又用s&#x2F;*2-d[s] 因为s&#x2F;2&#x2F;*2不一定等于s了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;span style=<span class="string">&quot;font-family:Arial Black;&quot;</span>&gt;#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">55</span>,  V = <span class="number">255000</span>;</span><br><span class="line">int d[V], val[N], num[N];</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    <span class="keyword">while</span> (scanf (<span class="string">&quot;%d&quot;</span>, &amp;n),n&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        int s = <span class="number">0</span>;</span><br><span class="line">        <span class="title function_">memset</span>(d,<span class="number">0</span>,<span class="title function_">sizeof</span>(d));</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;val[i], &amp;num[i]);</span><br><span class="line">            s += val[i] * num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (int k = <span class="number">1</span>; k&lt;=num[i]; k *=<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num[i] -= k;</span><br><span class="line">                <span class="keyword">for</span> (int j = s / <span class="number">2</span>; j &gt;= k * val[i]; --j)</span><br><span class="line">                    d[j] = max (d[j], d[j - k * val[i]] + k * val[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num[i] != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">for</span> (int j = s / <span class="number">2</span>; j &gt;= num[i] * val[i]; --j)</span><br><span class="line">                    d[j] = max (d[j], d[j - num[i] * val[i]] + num[i] * val[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf (<span class="string">&quot;%d %d\n&quot;</span>, s - d[s/<span class="number">2</span>], d[s/<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1300 Pearls(DP 珠宝店进货问题)</title>
    <url>/posts/oj/dp/HDU%201300%20Pearls(DP%20%E7%8F%A0%E5%AE%9D%E5%BA%97%E8%BF%9B%E8%B4%A7%E9%97%AE%E9%A2%98)/</url>
    <content><![CDATA[<p>﻿﻿</p>
<p>题意 珠宝店到珍珠批发商进货 第i种价格为p[i]的珍珠需要n个 则珍珠的结算价格为∑(n+10)&#x2F;*p[i] 由于没种珍珠的数量结算时都要加上10 所以有时候把便宜的珍珠换为贵的结算价格反而变少了 给你一张购买清单 珍珠价格是递增的 每种珍珠都可以替换为比它贵的 求最少总花费</p>
<p>和上篇博客描述的几乎是一样的 令d[i]表示前i种珍珠的最少花费 sum[i]表示第1种到第第i种的总数 那么有转移方程 d[i]&#x3D;min{d[j-1]+(sum[i]-sum[j-1]+10)&#x2F;*p[i]} (sum[i]-sum[j-1]+10)&#x2F;*p[i]表示第j种到第i种珍珠全部替换为第i种</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">105</span>;</span><br><span class="line">int p[N], d[N], s[N],num, n, cas;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    scanf (<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span> (cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;num, &amp;p[i]);</span><br><span class="line">            s[i] = s[i - <span class="number">1</span>] + num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">memset</span>(d,<span class="number">0x3f</span>,<span class="title function_">sizeof</span>(d));</span><br><span class="line">        d[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">                d[i] = min (d[i], d[j-<span class="number">1</span>] + (s[i] - s[j - <span class="number">1</span>] + <span class="number">10</span>) * p[i]);</span><br><span class="line">        printf (<span class="string">&quot;%d\n&quot;</span>, d[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Pearls"><a href="#Pearls" class="headerlink" title="Pearls"></a>Pearls</h1><p>Problem Description</p>
<p>In Pearlania everybody is fond of pearls. One company, called The Royal Pearl, produces a lot of jewelry with pearls in it. The Royal Pearl has its name because it delivers to the royal family of Pearlania. But it also produces bracelets and necklaces for ordinary people. Of course the quality of the pearls for these people is much lower then the quality of pearls for the royal family. In Pearlania pearls are separated into 100 different quality classes. A quality class is identified by the price for one single pearl in that quality class. This price is unique for that quality class and the price is always higher then the price for a pearl in a lower quality class.<br>Every month the stock manager of The Royal Pearl prepares a list with the number of pearls needed in each quality class. The pearls are bought on the local pearl market. Each quality class has its own price per pearl, but for every complete deal in a certain quality class one has to pay an extra amount of money equal to ten pearls in that class. This is to prevent tourists from buying just one pearl.<br>Also The Royal Pearl is suffering from the slow-down of the global economy. Therefore the company needs to be more efficient. The CFO (chief financial officer) has discovered that he can sometimes save money by buying pearls in a higher quality class than is actually needed. No customer will blame The Royal Pearl for putting better pearls in the bracelets, as long as the prices remain the same.<br>For example 5 pearls are needed in the 10 Euro category and 100 pearls are needed in the 20 Euro category. That will normally cost: (5+10)&#x2F;*10 + (100+10)&#x2F;*20 &#x3D; 2350 Euro.<br>Buying all 105 pearls in the 20 Euro category only costs: (5+100+10)&#x2F;*20 &#x3D; 2300 Euro.<br>The problem is that it requires a lot of computing work before the CFO knows how many pearls can best be bought in a higher quality class. You are asked to help The Royal Pearl with a computer program.<br>Given a list with the number of pearls and the price per pearl in different quality classes, give the lowest possible price needed to buy everything on the list. Pearls can be bought in the requested, or in a higher quality class, but not in a lower one.<br>Input</p>
<p>The first line of the input contains the number of test cases. Each test case starts with a line containing the number of categories c (1 &lt;&#x3D; c &lt;&#x3D; 100). Then, c lines follow, each with two numbers ai and pi. The first of these numbers is the number of pearls ai needed in a class (1 &lt;&#x3D; ai &lt;&#x3D; 1000). The second number is the price per pearl pi in that class (1 &lt;&#x3D; pi &lt;&#x3D; 1000). The qualities of the classes (and so the prices) are given in ascending order. All numbers in the input are integers.<br>Output</p>
<p>For each test case a single line containing a single number: the lowest possible price needed to buy everything on the list.<br>Sample Input</p>
<p>2 2 100 1 100 2 3 1 10 1 11 100 12<br>Sample Output</p>
<p>330 1344</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1300 Pearls(DP)</title>
    <url>/posts/oj/dp/HDU%201300%20Pearls(DP)/</url>
    <content><![CDATA[<p>题意 珠宝店到珍珠批发商进货 第i种价格为p[i]的珍珠需要n个 则珍珠的结算价格为∑(n+10)&#x2F;*p[i] 由于没种珍珠的数量结算时都要加上10 所以有时候把便宜的珍珠换为贵的结算价格反而变少了 给你一张购买清单 珍珠价格是递增的 每种珍珠都可以替换为比它贵的 求最少总花费</p>
<p>简单dp 令d[i]表示前i种珍珠的最少花费 sum[i]表示第1种到第第i种的总数 那么有转移方程 d[i]&#x3D;min{d[j-1]+(sum[i]-sum[j-1]+10)&#x2F;*p[i]} (sum[i]-sum[j-1]+10)&#x2F;*p[i]表示第j种到第i种珍珠全部替换为第i种</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">105</span>;</span><br><span class="line">int p[N], d[N], s[N],num, n, cas;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    scanf (<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span> (cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;num, &amp;p[i]);</span><br><span class="line">            s[i] = s[i - <span class="number">1</span>] + num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">memset</span>(d,<span class="number">0x3f</span>,<span class="title function_">sizeof</span>(d));</span><br><span class="line">        d[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">                d[i] = min (d[i], d[j-<span class="number">1</span>] + (s[i] - s[j - <span class="number">1</span>] + <span class="number">10</span>) * p[i]);</span><br><span class="line">        printf (<span class="string">&quot;%d\n&quot;</span>, d[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Pearls"><a href="#Pearls" class="headerlink" title="Pearls"></a>Pearls</h1><p>Problem Description</p>
<p>In Pearlania everybody is fond of pearls. One company, called The Royal Pearl, produces a lot of jewelry with pearls in it. The Royal Pearl has its name because it delivers to the royal family of Pearlania. But it also produces bracelets and necklaces for ordinary people. Of course the quality of the pearls for these people is much lower then the quality of pearls for the royal family. In Pearlania pearls are separated into 100 different quality classes. A quality class is identified by the price for one single pearl in that quality class. This price is unique for that quality class and the price is always higher then the price for a pearl in a lower quality class.<br>Every month the stock manager of The Royal Pearl prepares a list with the number of pearls needed in each quality class. The pearls are bought on the local pearl market. Each quality class has its own price per pearl, but for every complete deal in a certain quality class one has to pay an extra amount of money equal to ten pearls in that class. This is to prevent tourists from buying just one pearl.<br>Also The Royal Pearl is suffering from the slow-down of the global economy. Therefore the company needs to be more efficient. The CFO (chief financial officer) has discovered that he can sometimes save money by buying pearls in a higher quality class than is actually needed. No customer will blame The Royal Pearl for putting better pearls in the bracelets, as long as the prices remain the same.<br>For example 5 pearls are needed in the 10 Euro category and 100 pearls are needed in the 20 Euro category. That will normally cost: (5+10)&#x2F;*10 + (100+10)&#x2F;*20 &#x3D; 2350 Euro.<br>Buying all 105 pearls in the 20 Euro category only costs: (5+100+10)&#x2F;*20 &#x3D; 2300 Euro.<br>The problem is that it requires a lot of computing work before the CFO knows how many pearls can best be bought in a higher quality class. You are asked to help The Royal Pearl with a computer program.<br>Given a list with the number of pearls and the price per pearl in different quality classes, give the lowest possible price needed to buy everything on the list. Pearls can be bought in the requested, or in a higher quality class, but not in a lower one.<br>Input</p>
<p>The first line of the input contains the number of test cases. Each test case starts with a line containing the number of categories c (1 &lt;&#x3D; c &lt;&#x3D; 100). Then, c lines follow, each with two numbers ai and pi. The first of these numbers is the number of pearls ai needed in a class (1 &lt;&#x3D; ai &lt;&#x3D; 1000). The second number is the price per pearl pi in that class (1 &lt;&#x3D; pi &lt;&#x3D; 1000). The qualities of the classes (and so the prices) are given in ascending order. All numbers in the input are integers.<br>Output</p>
<p>For each test case a single line containing a single number: the lowest possible price needed to buy everything on the list.<br>Sample Input</p>
<p>2 2 100 1 100 2 3 1 10 1 11 100 12<br>Sample Output</p>
<p>330 1344</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1421 搬寝室(DP)</title>
    <url>/posts/oj/dp/HDU%201421%20%E6%90%AC%E5%AF%9D%E5%AE%A4(DP)/</url>
    <content><![CDATA[<p>题意 中文</p>
<p>先把物品重量从小到大排序 d[i][j]表示前i件物品选j对的最小疲劳<br>若选了第i个物品 那么和它一对的必是第i-1个物品 注意是前i件<br>i&#x3D;j&#x2F;*2时 没有选择 d[i][j]&#x3D;d[i-2][j-1]+(w[i]-w[i-1])^2<br>i&gt;j&#x2F;*2时 存在第i个选或者不选之分<br>若选了第i个的话 那么问题就转化为在i-2个物品中选j-1个了<br>若不选第i个的话 问题转化为在i-1个物品中选j个了</p>
<p>那么就有转移方程d[i][j]&#x3D;min(d[i-1][j],d[i-2][j-1]+(w[i]-w[i-1])^2)</p>
<p>d是初始化为无穷大的 所以i&#x3D;j&#x2F;*2时 d[i-1][j]是等于无穷大的 所以状态转移方程可以统一为</p>
<p>d[i][j]&#x3D;min(d[i-1][j],d[i-2][j-1]+(w[i]-w[i-1])^2)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">2014</span>;</span><br><span class="line">int w[N], d[N][N / <span class="number">2</span>], n, k;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (~scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            scanf (<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">        sort (w + <span class="number">1</span>, w + n + <span class="number">1</span>);</span><br><span class="line">        memset (d, <span class="number">0x7f</span>, sizeof (d));</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt;= n; ++i)  d[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">1</span>; j * <span class="number">2</span> &lt;= i; ++j)</span><br><span class="line">                d[i][j] = min (d[i - <span class="number">1</span>][j], d[i - <span class="number">2</span>][j - <span class="number">1</span>] + (w[i] - w[i - <span class="number">1</span>]) * (w[i] - w[i - <span class="number">1</span>]));</span><br><span class="line">                </span><br><span class="line">        printf (<span class="string">&quot;%d\n&quot;</span>, d[n][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="搬寝室"><a href="#搬寝室" class="headerlink" title="搬寝室"></a>搬寝室</h1><p>Problem Description</p>
<p>搬寝室是很累的,xhd深有体会.时间追述2006年7月9号,那天xhd迫于无奈要从27号楼搬到3号楼,因为10号要封楼了.看着寝室里的n件物品,xhd开始发呆,因为n是一个小于2000的整数,实在是太多了,于是xhd决定随便搬2&#x2F;*k件过去就行了.但还是会很累,因为2&#x2F;*k也不小是一个不大于n的整数.幸运的是xhd根据多年的搬东西的经验发现每搬一次的疲劳度是和左右手的物品的重量差的平方成正比(这里补充一句,xhd每次搬两件东西,左手一件右手一件).例如xhd左手拿重量为3的物品,右手拿重量为6的物品,则他搬完这次的疲劳度为(6-3)^2 &#x3D; 9.现在可怜的xhd希望知道搬完这2&#x2F;*k件物品后的最佳状态是怎样的(也就是最低的疲劳度),请告诉他吧.<br>Input</p>
<p>每组输入数据有两行,第一行有两个数n,k(2&lt;&#x3D;2&#x2F;*k&lt;&#x3D;n&lt;2000).第二行有n个整数分别表示n件物品的重量(重量是一个小于2^15的正整数).<br>Output</p>
<p>对应每组输入数据,输出数据只有一个表示他的最少的疲劳度,每个一行.<br>Sample Input</p>
<p>2 1 1 3<br>Sample Output</p>
<p>4</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1501 Zipper(DP，DFS)</title>
    <url>/posts/oj/dp/HDU%201501%20Zipper(DP%EF%BC%8CDFS)/</url>
    <content><![CDATA[<p>题意 判断能否由字符串a,b中的字符不改变各自的相对顺序组合得到字符串c</p>
<p>本题有两种解法 DP或者DFS</p>
<p>考虑DP 令d[i][j]表示能否有a的前i个字符和b的前j个字符组合得到c的前i+j个字符 值为0或者1 那么有d[i][j]&#x3D;(d[i-1][j]&amp;&amp;a[i]&#x3D;&#x3D;c[i+j])||(d[i][j-1]&amp;&amp;b[i]&#x3D;&#x3D;c[i+j]) a,b的下标都是从1开始的 注意0的初始化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">205</span>;</span><br><span class="line">char a[N], b[N], c[<span class="number">2</span> * N];</span><br><span class="line">bool  d[N][N];</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas;</span><br><span class="line">    scanf (<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">for</span> (int k = <span class="number">1</span>; k &lt;= cas; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf (<span class="string">&quot;%s%s%s&quot;</span>, a + <span class="number">1</span>, b + <span class="number">1</span>, c + <span class="number">1</span>);</span><br><span class="line">        int la = strlen (a + <span class="number">1</span>), lb = strlen (b + <span class="number">1</span>), i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">        memset (d, <span class="number">0</span>, sizeof (d));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (a[i] == c[i] &amp;&amp; i &lt;= la)</span><br><span class="line">            d[i++][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (b[j] == c[j] &amp;&amp; j &lt;= lb)</span><br><span class="line">            d[<span class="number">0</span>][j++] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= la; ++i)</span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= lb; ++j)</span><br><span class="line">                d[i][j] = ( (d[i - <span class="number">1</span>][j] &amp;&amp; a[i] == c[i + j]) || (d[i][j - <span class="number">1</span>] &amp;&amp; b[j] == c[i + j]));</span><br><span class="line"></span><br><span class="line">        printf (<span class="string">&quot;Data set %d: &quot;</span>, k);</span><br><span class="line">        printf (d[la][lb] ? <span class="string">&quot;yes\n&quot;</span> : <span class="string">&quot;no\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是dfs的代码 看能否在ab中对应搜到c的每一个字母就可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DFS版</span></span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">205</span>;</span><br><span class="line">char a[N], b[N], c[<span class="number">2</span> * N];</span><br><span class="line">bool vis[N][N], ans;</span><br><span class="line"><span class="keyword">void</span> dfs (int i, int j, int k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (c[k] == <span class="string">&#x27;\0&#x27;</span>) ans = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ans || vis[i][j])  <span class="keyword">return</span> ;</span><br><span class="line">    vis[i][j] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[i] == c[k]) dfs (i + <span class="number">1</span>, j, k + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (b[j] == c[k]) dfs (i, j + <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas;</span><br><span class="line">    scanf (<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">for</span> (int ca = <span class="number">1</span>; ca &lt;= cas; ++ca)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="literal">false</span>;</span><br><span class="line">        memset (vis, <span class="number">0</span>, sizeof (vis));</span><br><span class="line">        scanf (<span class="string">&quot;%s%s%s&quot;</span>, a, b, c);</span><br><span class="line">        dfs (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        printf (<span class="string">&quot;Data set %d: &quot;</span>, ca);</span><br><span class="line">        printf (ans ? <span class="string">&quot;yes\n&quot;</span> : <span class="string">&quot;no\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Zipper"><a href="#Zipper" class="headerlink" title="Zipper"></a>Zipper</h1><p>Problem Description</p>
<p>Given three strings, you are to determine whether the third string can be formed by combining the characters in the first two strings. The first two strings can be mixed arbitrarily, but each must stay in its original order.<br>For example, consider forming “tcraete” from “cat” and “tree”:<br>String A: cat<br>String B: tree<br>String C: tcraete<br>As you can see, we can form the third string by alternating characters from the two strings. As a second example, consider forming “catrtee” from “cat” and “tree”:<br>String A: cat<br>String B: tree<br>String C: catrtee<br>Finally, notice that it is impossible to form “cttaree” from “cat” and “tree”.<br>Input</p>
<p>The first line of input contains a single positive integer from 1 through 1000. It represents the number of data sets to follow. The processing for each data set is identical. The data sets appear on the following lines, one data set per line.<br>For each data set, the line of input consists of three strings, separated by a single space. All strings are composed of upper and lower case letters only. The length of the third string is always the sum of the lengths of the first two strings. The first two strings will have lengths between 1 and 200 characters, inclusive.<br>Output</p>
<p>For each data set, print:<br>Data set n: yes<br>if the third string can be formed from the first two, or<br>Data set n: no<br>if it cannot. Of course n should be replaced by the data set number. See the sample output below for an example.<br>Sample Input</p>
<p>3 cat tree tcraete cat tree catrtee cat tree cttaree<br>Sample Output</p>
<p>Data set 1: yes Data set 2: yes Data set 3: no</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1505 City Game（DP）</title>
    <url>/posts/oj/dp/HDU%201505%20City%20Game%EF%BC%88DP%EF%BC%89/</url>
    <content><![CDATA[<p>1506的升级版 只是多了一维 h要自己算 详情看上一篇</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1005</span>;</span><br><span class="line">int mat[N][N], le[N][N], ri[N][N], h[N][N], cas, n, m;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    char s[<span class="number">5</span>];</span><br><span class="line">    scanf (<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span> (cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        memset (mat, <span class="number">0</span>, sizeof (mat));</span><br><span class="line">        memset (h, <span class="number">0</span>, sizeof (h));</span><br><span class="line">        scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            h[i][<span class="number">0</span>] = h[i][m + <span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                scanf (<span class="string">&quot;%s&quot;</span>, s), mat[i][j] = s[<span class="number">0</span>];</span><br><span class="line">                le[i][j] = ri[i][j] = j;</span><br><span class="line">                <span class="keyword">if</span> (mat[i][j] == <span class="string">&#x27;F&#x27;</span>) h[i][j] = h[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (int j = m; j &gt;= <span class="number">1</span>; --j)</span><br><span class="line">                <span class="keyword">while</span> (h[i][ri[i][j] + <span class="number">1</span>] &gt;= h[i][j])</span><br><span class="line">                    ri[i][j] = ri[i][ri[i][j] + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (h[i][le[i][j] - <span class="number">1</span>] &gt;= h[i][j])</span><br><span class="line">                    le[i][j] = le[i][le[i][j] - <span class="number">1</span>];</span><br><span class="line">                ans = max (ans, (ri[i][j] - le[i][j] + <span class="number">1</span>) * h[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf (<span class="string">&quot;%d\n&quot;</span>, ans * <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="City-Game"><a href="#City-Game" class="headerlink" title="City Game"></a>City Game</h1><p>Problem Description</p>
<p>Bob is a strategy game programming specialist. In his new city building game the gaming environment is as follows: a city is built up by areas, in which there are streets, trees,factories and buildings. There is still some space in the area that is unoccupied. The strategic task of his game is to win as much rent money from these free spaces. To win rent money you must erect buildings, that can only be rectangular, as long and wide as you can. Bob is trying to find a way to build the biggest possible building in each area. But he comes across some problems – he is not allowed to destroy already existing buildings, trees, factories and streets in the area he is building in.<br>Each area has its width and length. The area is divided into a grid of equal square units.The rent paid for each unit on which you’re building stands is 3$.<br>Your task is to help Bob solve this problem. The whole city is divided into K areas. Each one of the areas is rectangular and has a different grid size with its own length M and width N.The existing occupied units are marked with the symbol R. The unoccupied units are marked with the symbol F.<br>Input</p>
<p>The first line of the input contains an integer K – determining the number of datasets. Next lines contain the area descriptions. One description is defined in the following way: The first line contains two integers-area length M&lt;&#x3D;1000 and width N&lt;&#x3D;1000, separated by a blank space. The next M lines contain N symbols that mark the reserved or free grid units,separated by a blank space. The symbols used are:<br>R – reserved unit<br>F – free unit<br>In the end of each area description there is a separating line.<br>Output</p>
<p>For each data set in the input print on a separate line, on the standard output, the integer that represents the profit obtained by erecting the largest building in the area encoded by the data set.<br>Sample Input</p>
<p>2 5 6 R F F F F F F F F F F F R R R F F F F F F F F F F F F F F F 5 5 R R R R R R R R R R R R R R R R R R R R R R R R R<br>Sample Output</p>
<p>45 0</p>
<h1 id="City-Game-1"><a href="#City-Game-1" class="headerlink" title="City Game"></a>City Game</h1><p>Problem Description</p>
<p>Bob is a strategy game programming specialist. In his new city building game the gaming environment is as follows: a city is built up by areas, in which there are streets, trees,factories and buildings. There is still some space in the area that is unoccupied. The strategic task of his game is to win as much rent money from these free spaces. To win rent money you must erect buildings, that can only be rectangular, as long and wide as you can. Bob is trying to find a way to build the biggest possible building in each area. But he comes across some problems – he is not allowed to destroy already existing buildings, trees, factories and streets in the area he is building in.<br>Each area has its width and length. The area is divided into a grid of equal square units.The rent paid for each unit on which you’re building stands is 3$.<br>Your task is to help Bob solve this problem. The whole city is divided into K areas. Each one of the areas is rectangular and has a different grid size with its own length M and width N.The existing occupied units are marked with the symbol R. The unoccupied units are marked with the symbol F.<br>Input</p>
<p>The first line of the input contains an integer K – determining the number of datasets. Next lines contain the area descriptions. One description is defined in the following way: The first line contains two integers-area length M&lt;&#x3D;1000 and width N&lt;&#x3D;1000, separated by a blank space. The next M lines contain N symbols that mark the reserved or free grid units,separated by a blank space. The symbols used are:<br>R – reserved unit<br>F – free unit<br>In the end of each area description there is a separating line.<br>Output</p>
<p>For each data set in the input print on a separate line, on the standard output, the integer that represents the profit obtained by erecting the largest building in the area encoded by the data set.<br>Sample Input</p>
<p>2 5 6 R F F F F F F F F F F F R R R F F F F F F F F F F F F F F F 5 5 R R R R R R R R R R R R R R R R R R R R R R R R R<br>Sample Output</p>
<p>45 0</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1506 Largest Rectangle in a Histogram(DP·单调栈)</title>
    <url>/posts/oj/dp/HDU%201506%20Largest%20Rectangle%20in%20a%20Histogram(DP%C2%B7%E5%8D%95%E8%B0%83%E6%A0%88)/</url>
    <content><![CDATA[<p>题意 求条形图中最大矩形的面积 输入给你条的个数 每个条的高度hi （以下等于也视为高）</p>
<p>只要知道第i个条左边连续多少个（a）比他高 右边连续多少个（b）比他高 那么以这个条为最大高度的面积就是<strong>hi&#x2F;*(a+b+1);</strong></p>
<p>但是直接枚举每一个的话肯定会超时的 超时代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">100005</span>;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll h[N]; int n,wide[N];</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (scanf (<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            scanf (<span class="string">&quot;%I64d&quot;</span>, &amp;h[i]);</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            wide[i] = <span class="number">1</span>;</span><br><span class="line">            int k = i;</span><br><span class="line">            <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; h[--k] &gt;= h[i]) ++wide[i];</span><br><span class="line">            k = i;</span><br><span class="line">            <span class="keyword">while</span> (k &lt; n &amp;&amp; h[++k] &gt;= h[i]) ++wide[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (h[i]*wide[i] &gt; ans) ans = h[i] * wide[i];</span><br><span class="line">        printf (<span class="string">&quot;%I64d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现 当第i-1个比第i个高的时候 比第i-1个高的所有也一定比第i个高</p>
<p>于是可以用到动态规划的思想</p>
<p>令left[i]表示包括i在内比i高的连续序列中最左边一个的下标 right[i]为最右边一个的下标</p>
<p>那么有 当**h[left[i]-1]&gt;&#x3D;h[i]]<strong>时</strong>left[i]&#x3D;left[left[i]-1]**从前往后可以递推出left[i]</p>
<p>同理 当**h[right[i]+1]&gt;&#x3D;h[i]]<strong>时</strong>right[i]&#x3D;right[right[i]+1]**从后往前可递推出righ[i]</p>
<p>最后答案就等于**max{(right[i]-left[i]+1)&#x2F;*h[i]}**了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">100005</span>;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll h[N];</span><br><span class="line">int n, left[N], right[N];</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (scanf (<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            scanf (<span class="string">&quot;%I64d&quot;</span>, &amp;h[i]), left[i] = right[i] = i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        h[<span class="number">0</span>] = h[n + <span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)      <span class="comment">//求left[i]</span></span><br><span class="line">            <span class="keyword">while</span> (h[left[i] - <span class="number">1</span>] &gt;= h[i])</span><br><span class="line">                left[i] = left[left[i] - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = n; i &gt;= <span class="number">1</span>; --i)      <span class="comment">//求right[i]</span></span><br><span class="line">            <span class="keyword">while</span> (h[right[i] + <span class="number">1</span>] &gt;= h[i])</span><br><span class="line">                right[i] = right[right[i] + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (h[i] * (right[i] - left[i] + <span class="number">1</span>) &gt; ans) ans = h[i] * ll (right[i] - left[i] + <span class="number">1</span>);</span><br><span class="line">        printf (<span class="string">&quot;%I64d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后还有单调栈写法 比DP操作起来更容易</p>
<p>通过单调栈可以在 O(n) 时间内找到数组中在 h[i] 左边(右边)离 h[i] 最近的大于 h[i] 那个数(或者下标) 这里是取下标 知道 h[i] 左边最近和右边最近的高度小于 h[i] 的两个下标后 那么就知道以这个矩形高度为基准的大矩形的面积了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll h[N], s[N], le[N], ri[N];</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, top;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%I64d&quot;</span>, &amp;h[i]);</span><br><span class="line"></span><br><span class="line">        top = <span class="number">0</span>, s[<span class="number">0</span>] = <span class="number">0</span>;   <span class="comment">//le[i]保存i左边第一个小于h[i]的下标</span></span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(top &amp;&amp; h[s[top]] &gt;= h[i]) --top;</span><br><span class="line">            le[i] = s[top];</span><br><span class="line">            s[++top] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        top = <span class="number">0</span>, s[<span class="number">0</span>] = n + <span class="number">1</span>;  <span class="comment">//ri[i]保存i右边最后一个大于等于h[i]的下标</span></span><br><span class="line">        <span class="keyword">for</span>(int i = n; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(top &amp;&amp; h[s[top]] &gt;= h[i]) --top;</span><br><span class="line">            ri[i] = s[top] - <span class="number">1</span>;</span><br><span class="line">            s[++top] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ll ans = h[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(h[i] * (ri[i] - le[i]) &gt; ans)</span><br><span class="line">                ans =  h[i] * (ri[i] - le[i]);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%I64d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Largest-Rectangle-in-a-Histogram"><a href="#Largest-Rectangle-in-a-Histogram" class="headerlink" title="Largest Rectangle in a Histogram"></a>Largest Rectangle in a Histogram</h1><p>Problem Description</p>
<p>A histogram is a polygon composed of a sequence of rectangles aligned at a common base line. The rectangles have equal widths but may have different heights. For example, the figure on the left shows the histogram that consists of rectangles with the heights 2, 1, 4, 5, 1, 3, 3, measured in units where 1 is the width of the rectangles:<br><img src="/../images/cn-data-images-1506-1.gif.png"><br>Usually, histograms are used to represent discrete distributions, e.g., the frequencies of characters in texts. Note that the order of the rectangles, i.e., their heights, is important. Calculate the area of the largest rectangle in a histogram that is aligned at the common base line, too. The figure on the right shows the largest aligned rectangle for the depicted histogram.<br>Input</p>
<p>The input contains several test cases. Each test case describes a histogram and starts with an integer n, denoting the number of rectangles it is composed of. You may assume that 1 &lt;&#x3D; n &lt;&#x3D; 100000. Then follow n integers h1, …, hn, where 0 &lt;&#x3D; hi &lt;&#x3D; 1000000000. These numbers denote the heights of the rectangles of the histogram in left-to-right order. The width of each rectangle is 1. A zero follows the input for the last test case.<br>Output</p>
<p>For each test case output on a single line the area of the largest rectangle in the specified histogram. Remember that this rectangle must be aligned at the common base line.<br>Sample Input</p>
<p>7 2 1 4 5 1 3 3 4 1000 1000 1000 1000 0<br>Sample Output</p>
<p>8 4000<br>#</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1789 Doing Homework again（贪心）</title>
    <url>/posts/oj/dp/HDU%201789%20Doing%20Homework%20again%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89/</url>
    <content><![CDATA[<p>题意 某大参加ACM竞赛回来落下很多作业 每个作业都有最后期限 没在最后期限之内做完期末就要扣掉对应的分 求最少扣多少分</p>
<p>把所有作业按扣分大小从大到小排序 然后就贪阿 能完成前面的就完成前面的 实在不能的就扣分吧~</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1005</span>;</span><br><span class="line">int dli[N], red[N], k[N], cas, ans, n;</span><br><span class="line">bool vis[N];</span><br><span class="line"></span><br><span class="line">bool cmp (int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> red[i] &gt; red[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    scanf (<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span> (cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        memset (vis, <span class="number">0</span>, sizeof (vis));</span><br><span class="line">        scanf (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            scanf (<span class="string">&quot;%d&quot;</span>, &amp;dli[i]), k[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            scanf (<span class="string">&quot;%d&quot;</span>, &amp;red[j]);</span><br><span class="line">            </span><br><span class="line">        sort (k + <span class="number">1</span>, k + n + <span class="number">1</span>, cmp);</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>, j; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = dli[k[i]]; j &gt;= <span class="number">1</span>; --j)</span><br><span class="line">                <span class="keyword">if</span> (!vis[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) ans += red[k[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        printf (<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;&lt;span style=<span class="string">&quot;font-family:Comic Sans MS;&quot;</span>&gt;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<h1 id="Doing-Homework-again"><a href="#Doing-Homework-again" class="headerlink" title="Doing Homework again"></a>Doing Homework again</h1><p>Problem Description</p>
<p>Ignatius has just come back school from the 30th ACM&#x2F;ICPC. Now he has a lot of homework to do. Every teacher gives him a deadline of handing in the homework. If Ignatius hands in the homework after the deadline, the teacher will reduce his score of the final test. And now we assume that doing everyone homework always takes one day. So Ignatius wants you to help him to arrange the order of doing homework to minimize the reduced score.<br>Input</p>
<p>The input contains several test cases. The first line of the input is a single integer T that is the number of test cases. T test cases follow.<br>Each test case start with a positive integer N(1&lt;&#x3D;N&lt;&#x3D;1000) which indicate the number of homework.. Then 2 lines follow. The first line contains N integers that indicate the deadlines of the subjects, and the next line contains N integers that indicate the reduced scores.<br>Output</p>
<p>For each test case, you should output the smallest total reduced score, one line per test case.<br>Sample Input</p>
<p>3 3 3 3 3 10 5 1 3 1 3 1 6 2 3 7 1 4 6 4 2 4 3 3 2 1 7 6 5 4<br>Sample Output</p>
<p>0 3 5</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1978 How many ways(DP)</title>
    <url>/posts/oj/dp/HDU%201978%20How%20many%20ways(DP)/</url>
    <content><![CDATA[<p>题意 中文 但要注意小于你能量的点也是能到达的</p>
<p>令d[i][j]表示到达第i行第j列的方法数 初始化为0 d[1][1]为1 输入一个点的能量t后 枚举这个点能到的所有点(i+x,j+y)(x+y&lt;&#x3D;t) 有d[i+x][j+y]+&#x3D;d[i][j] 因为只能向右走和向下走 可以保证每次更新后均为当前最优解 输入最后一个点后 就得到答案了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">105</span>, <span class="variable constant_">MOD</span> = <span class="number">10000</span>;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int d[N][N], n, m, cas, t;</span><br><span class="line">    scanf (<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span> (cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        memset (d, <span class="number">0</span>, sizeof (d)), d[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                scanf (<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">                <span class="keyword">for</span> (int x = <span class="number">0</span>; x &lt;= t &amp;&amp; i + x &lt;= n; ++x)</span><br><span class="line">                    <span class="keyword">for</span> (int y = <span class="number">0</span>; x + y &lt;= t &amp;&amp; j + y &lt;= m; ++y)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                        d[i + x][j + y] = (d[i][j] + d[i + x][j + y]) % <span class="variable constant_">MOD</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        printf (<span class="string">&quot;%d\n&quot;</span>, d[n][m]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="How-many-ways"><a href="#How-many-ways" class="headerlink" title="How many ways"></a>How many ways</h1><p>Problem Description</p>
<p>这是一个简单的生存游戏，你控制一个机器人从一个棋盘的起始点(1,1)走到棋盘的终点(n,m)。游戏的规则描述如下：<br>1.机器人一开始在棋盘的起始点并有起始点所标有的能量。<br>2.机器人只能向右或者向下走，并且每走一步消耗一单位能量。<br>3.机器人不能在原地停留。<br>4.当机器人选择了一条可行路径后，当他走到这条路径的终点时，他将只有终点所标记的能量。<br><img src="/../images/cn-data-images-C113-1003-1.gif.png"><br>如上图，机器人一开始在(1,1)点，并拥有4单位能量，蓝色方块表示他所能到达的点，如果他在这次路径选择中选择的终点是(2,4)<br>点，当他到达(2,4)点时将拥有1单位的能量，并开始下一次路径选择，直到到达(6,6)点。<br>我们的问题是机器人有多少种方式从起点走到终点。这可能是一个很大的数，输出的结果对10000取模。<br>Input</p>
<p>第一行输入一个整数T,表示数据的组数。<br>对于每一组数据第一行输入两个整数n,m(1 &lt;&#x3D; n,m &lt;&#x3D; 100)。表示棋盘的大小。接下来输入n行,每行m个整数e(0 &lt;&#x3D; e &lt; 20)。<br>Output</p>
<p>对于每一组数据输出方式总数对10000取模的结果.<br>Sample Input</p>
<p>1 6 6 4 5 6 6 4 3 2 2 3 1 7 2 1 1 4 6 2 7 5 8 4 3 9 5 7 6 6 2 1 5 3 1 1 3 7 2<br>Sample Output</p>
<p>3948</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 2059 龟兔赛跑（DP）</title>
    <url>/posts/oj/dp/HDU%202059%20%E9%BE%9F%E5%85%94%E8%B5%9B%E8%B7%91%EF%BC%88DP%EF%BC%89/</url>
    <content><![CDATA[<p>题意 中文</p>
<p>简单的多阶段决策DP 令p[0]&#x3D;0 p[n]&#x3D;l d[i]表示乌龟从起点到第i个加油站所需的最小时间 那么有d[i]&#x3D;min(d[i],d[j]+t(j,i)) t(j,i)表示 在第j个加油站加满油 然后直接开到第i个加油站 当然第0个加油站是起点就不用加油了 这样推到最后d[n]就是乌龟所需的最小时间了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">105</span>,<span class="variable constant_">INF</span>=<span class="number">999999</span>;</span><br><span class="line">double d[N],ti;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, c, t, vr, v1, v2, l, p[N];</span><br><span class="line">    <span class="keyword">while</span> (~scanf (<span class="string">&quot;%d&quot;</span>, &amp;l))</span><br><span class="line">    &#123;</span><br><span class="line">        scanf (<span class="string">&quot;%d%d%d%d%d%d&quot;</span>, &amp;n, &amp;c, &amp;t, &amp;vr, &amp;v1, &amp;v2);</span><br><span class="line">        ++n,p[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            scanf (<span class="string">&quot;%d&quot;</span>, &amp;p[i]); p[n] = l;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            d[i]=<span class="variable constant_">INF</span>;</span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                int len = p[i] - p[j];</span><br><span class="line">                <span class="keyword">if</span> (len &gt; c) ti = c * <span class="number">1.0</span> / v1 + (len - c) * <span class="number">1.0</span> / v2;</span><br><span class="line">                <span class="keyword">else</span> ti = len * <span class="number">1.0</span> / v1;</span><br><span class="line">                <span class="keyword">if</span> (j) ti += t;</span><br><span class="line">                d[i]=<span class="title function_">min</span>(d[i],d[j]+ti);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (d[n] &lt; l * <span class="number">1.0</span> / vr)</span><br><span class="line">            printf (<span class="string">&quot;What a pity rabbit!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> printf (<span class="string">&quot;Good job,rabbit!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="龟兔赛跑"><a href="#龟兔赛跑" class="headerlink" title="龟兔赛跑"></a>龟兔赛跑</h1><p>Problem Description</p>
<p>据说在很久很久以前，可怜的兔子经历了人生中最大的打击——赛跑输给乌龟后，心中郁闷，发誓要报仇雪恨，于是躲进了杭州下沙某农业园卧薪尝胆潜心修炼，终于练成了绝技，能够毫不休息得以恒定的速度(VR m&#x2F;s)一直跑。兔子一直想找机会好好得教训一下乌龟，以雪前耻。<br>最近正值HDU举办50周年校庆，社会各大名流齐聚下沙，兔子也趁此机会向乌龟发起挑战。虽然乌龟深知获胜希望不大，不过迫于舆论压力，只能接受挑战。<br>比赛是设在一条笔直的道路上，长度为L米，规则很简单，谁先到达终点谁就算获胜。<br>无奈乌龟自从上次获胜以后，成了名龟，被一些八卦杂志称为“动物界的刘翔”，广告不断，手头也有了不少积蓄。为了能够再赢兔子，乌龟不惜花下血本买了最先进的武器——“”小飞鸽”牌电动车。这辆车在有电的情况下能够以VT1 m&#x2F;s的速度“飞驰”，可惜电池容量有限，每次充满电最多只能行驶C米的距离，以后就只能用脚来蹬了，乌龟用脚蹬时的速度为VT2 m&#x2F;s。更过分的是，乌龟竟然在跑道上修建了很多很多（N个)的供电站，供自己给电动车充电。其中，每次充电需要花费T秒钟的时间。当然，乌龟经过一个充电站的时候可以选择去或不去充电。<br>比赛马上开始了，兔子和带着充满电的电动车的乌龟并列站在起跑线上。你的任务就是写个程序，判断乌龟用最佳的方案进军时，能不能赢了一直以恒定速度奔跑的兔子。<br>Input</p>
<p>本题目包含多组测试，请处理到文件结束。每个测试包括四行：<br>第一行是一个整数L代表跑道的总长度<br>第二行包含三个整数N，C，T，分别表示充电站的个数，电动车冲满电以后能行驶的距离以及每次充电所需要的时间<br>第三行也是三个整数VR，VT1，VT2，分别表示兔子跑步的速度，乌龟开电动车的速度，乌龟脚蹬电动车的速度<br>第四行包含了N(N&lt;&#x3D;100)个整数p1,p2…pn,分别表示各个充电站离跑道起点的距离，其中0&lt;p1&lt;p2&lt;…&lt;pn&lt;L<br>其中每个数都在32位整型范围之内。<br>Output</p>
<p>当乌龟有可能赢的时候输出一行 “What a pity rabbit!”。否则输出一行”Good job,rabbit!”;<br>题目数据保证不会出现乌龟和兔子同时到达的情况。<br>Sample Input</p>
<p>100 3 20 5 5 8 2 10 40 60 100 3 60 5 5 8 2 10 40 60<br>Sample Output</p>
<p>Good job,rabbit! What a pity rabbit!</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 2089 不要62(数位DP·记忆化搜索)</title>
    <url>/posts/oj/dp/HDU%202089%20%E4%B8%8D%E8%A6%8162(%E6%95%B0%E4%BD%8DDP%C2%B7%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2)/</url>
    <content><![CDATA[<p>题意 中文</p>
<p>最基础的数位DP 这题好像也可以直接暴力来做 令dp[i][j]表示以 j 开头的 i 位数有多少个满足条件</p>
<p>那么很容易有状态转移方程<strong>dp[i][j] &#x3D; sum{ dp[i-1][k] }, k &#x3D; 0…9, j !&#x3D; 4 &amp;&amp; !( j &#x3D;&#x3D; 6 &amp;&amp; k &#x3D;&#x3D; 2)</strong></p>
<p>最后统计个数就行了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int dp[<span class="number">8</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">int <span class="title function_">dfs</span>(int i, int j) <span class="comment">//记忆化搜索统计以 j 开头的 i 位数满足条件的个数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[i][j] &gt; -<span class="number">1</span>) <span class="keyword">return</span> dp[i][j];</span><br><span class="line"></span><br><span class="line">    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int k = <span class="number">0</span>; k &lt; <span class="number">10</span>; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">4</span> || (j == <span class="number">6</span> &amp;&amp; k == <span class="number">2</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        dp[i][j] += <span class="title function_">dfs</span>(i - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">getNum</span>(int a) <span class="comment">//统计[0,a)这个区间满足条件的数的个数</span></span><br><span class="line">&#123;</span><br><span class="line">    int s[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    int i = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a)</span><br><span class="line">    &#123;</span><br><span class="line">        s[i++] = a % <span class="number">10</span>;</span><br><span class="line">        a /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; s[i]; ++j)</span><br><span class="line">            <span class="keyword">if</span>(!(j == <span class="number">2</span> &amp;&amp; s[i + <span class="number">1</span>] == <span class="number">6</span>))</span><br><span class="line">                ret += <span class="title function_">dfs</span>(i + <span class="number">1</span>, j);</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="number">4</span> || (s[i] == <span class="number">2</span> &amp;&amp; s[i + <span class="number">1</span>] == <span class="number">6</span>))</span><br><span class="line">            <span class="keyword">break</span>;    <span class="comment">//已经不满足条件了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">memset</span>(dp, -<span class="number">1</span>, <span class="title function_">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) dp[<span class="number">1</span>][i] = (i != <span class="number">4</span>); <span class="comment">//边界</span></span><br><span class="line"></span><br><span class="line">    int n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m), n || m)</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="title function_">getNum</span>(m + <span class="number">1</span>) - <span class="title function_">getNum</span>(n));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Last modified :   2015-07-22 15:22</span></span><br></pre></td></tr></table></figure>

<h1 id="不要62"><a href="#不要62" class="headerlink" title="不要62"></a>不要62</h1><p>Problem Description</p>
<p>杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。<br>杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。<br>不吉利的数字为所有含有4或62的号码。例如：<br>62315 73418 88914<br>都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。<br>你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。<br>Input</p>
<p>输入的都是整数对n、m（0&lt;n≤m&lt;1000000），如果遇到都是0的整数对，则输入结束。<br>Output</p>
<p>对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。<br>Sample Input</p>
<p>1 100 0 0<br>Sample Output</p>
<p>80</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 2159 FATE（二维完全背包）</title>
    <url>/posts/oj/dp/HDU%202159%20FATE%EF%BC%88%E4%BA%8C%E7%BB%B4%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%EF%BC%89/</url>
    <content><![CDATA[<p>中文题目就不用解释了 就是裸的二维完全背包</p>
<p>d[i][j]表示消耗i忍耐杀j个怪最多可获得的经验 然后就用完全背包来做了 二维背包背包不过是多了一重循环</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;span style=<span class="string">&quot;font-family:Arial Black;&quot;</span>&gt;#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">105</span>;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//还需的经验值n，保留的忍耐度m，怪的种数k,最多的杀怪数s</span></span><br><span class="line">    int n, m, k, s, d[N][N], exp[N], cos[N];</span><br><span class="line">    <span class="keyword">while</span> (~scanf (<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k, &amp;s))</span><br><span class="line">    &#123;</span><br><span class="line">        memset (d, <span class="number">0</span>, sizeof (d));</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">            scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;exp[i], &amp;cos[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int u = <span class="number">1</span>; u &lt;= k; ++u)</span><br><span class="line">            <span class="keyword">for</span> (int i = cos[u]; i &lt;= m; ++i)</span><br><span class="line">                <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= s; ++j)</span><br><span class="line">                    d[i][j] = max (d[i][j], d[i - cos[u]][j - <span class="number">1</span>] + exp[u]);</span><br><span class="line"></span><br><span class="line">        int i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            <span class="keyword">if</span> (d[i][s] &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= m) printf (<span class="string">&quot;%d\n&quot;</span>, m - i);</span><br><span class="line">        <span class="keyword">else</span> printf (<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<h1 id="FATE"><a href="#FATE" class="headerlink" title="FATE"></a>FATE</h1><p>Problem Description</p>
<p>最近xhd正在玩一款叫做FATE的游戏，为了得到极品装备，xhd在不停的杀怪做任务。久而久之xhd开始对杀怪产生的厌恶感，但又不得不通过杀怪来升完这最后一级。现在的问题是，xhd升掉最后一级还需n的经验值，xhd还留有m的忍耐度，每杀一个怪xhd会得到相应的经验，并减掉相应的忍耐度。当忍耐度降到0或者0以下时，xhd就不会玩这游戏。xhd还说了他最多只杀s只怪。请问他能升掉这最后一级吗？<br>Input</p>
<p>输入数据有多组，对于每组数据第一行输入n，m，k，s(0 &lt; n,m,k,s &lt; 100)四个正整数。分别表示还需的经验值，保留的忍耐度，怪的种数和最多的杀怪数。接下来输入k行数据。每行数据输入两个正整数a，b(0 &lt; a,b &lt; 20)；分别表示杀掉一只这种怪xhd会得到的经验值和会减掉的忍耐度。(每种怪都有无数个)<br>Output</p>
<p>输出升完这级还能保留的最大忍耐度，如果无法升完这级输出-1。<br>Sample Input</p>
<p>10 10 1 10 1 1 10 10 1 9 1 1 9 10 2 10 1 1 2 2<br>Sample Output</p>
<p>0 -1 1</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 2602 Bone Collector（01背包经典）</title>
    <url>/posts/oj/dp/HDU%202602%20Bone%20Collector%EF%BC%8801%E8%83%8C%E5%8C%85%E7%BB%8F%E5%85%B8%EF%BC%89/</url>
    <content><![CDATA[<p>很裸的01背包 大家都懂得</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1005</span>;</span><br><span class="line">int n, v, d[N], val[N], vol[N], cas;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    scanf (<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span> (cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        memset (d, <span class="number">0</span>, sizeof (d));</span><br><span class="line">        scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;v);</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            scanf (<span class="string">&quot;%d&quot;</span>, &amp;val[i]);</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf (<span class="string">&quot;%d&quot;</span>, &amp;vol[i]);</span><br><span class="line">            <span class="keyword">for</span> (int j = v; j &gt;= vol[i]; --j)</span><br><span class="line">                d[j] = max (d[j], d[j - vol[i]] + val[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf (<span class="string">&quot;%d\n&quot;</span>, d[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Bone-Collector"><a href="#Bone-Collector" class="headerlink" title="Bone Collector"></a>Bone Collector</h1><p>Problem Description</p>
<p>Many years ago , in Teddy’s hometown there was a man who was called “Bone Collector”. This man like to collect varies of bones , such as dog’s , cow’s , also he went to the grave … The bone collector had a big bag with a volume of V ,and along his trip of collecting there are a lot of bones , obviously , different bone has different value and different volume, now given the each bone’s value along his trip , can you calculate out the maximum of the total value the bone collector can get ?  <img src="/../images/cn-data-images-C154-1003-1.jpg.png"><br>Input</p>
<p>The first line contain a integer T , the number of cases. Followed by T cases , each case three lines , the first line contain two integer N , V, (N &lt;&#x3D; 1000 , V &lt;&#x3D; 1000 )representing the number of bones and the volume of his bag. And the second line contain N integers representing the value of each bone. The third line contain N integers representing the volume of each bone.<br>Output</p>
<p>One integer per line representing the maximum of the total value (this number will be less than 231).<br>Sample Input</p>
<p>1 5 10 1 2 3 4 5 5 4 3 2 1<br>Sample Output</p>
<p>14
﻿﻿</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 2602 Bone Collector（01背包）</title>
    <url>/posts/oj/dp/HDU%202602%20Bone%20Collector%EF%BC%8801%E8%83%8C%E5%8C%85%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Bone-Collector"><a href="#Bone-Collector" class="headerlink" title="Bone Collector"></a>Bone Collector</h1><p>Problem Description</p>
<p>Many years ago , in Teddy’s hometown there was a man who was called “Bone Collector”. This man like to collect varies of bones , such as dog’s , cow’s , also he went to the grave …<br>The bone collector had a big bag with a volume of V ,and along his trip of collecting there are a lot of bones , obviously , different bone has different value and different volume, now given the each bone’s value along his trip , can you calculate out the maximum of the total value the bone collector can get ?<br>  <img src="/../images/cn-data-images-C154-1003-1.jpg.png"><br>Input</p>
<p>The first line contain a integer T , the number of cases.<br>Followed by T cases , each case three lines , the first line contain two integer N , V, (N &lt;&#x3D; 1000 , V &lt;&#x3D; 1000 )representing the number of bones and the volume of his bag. And the second line contain N integers representing the value of each bone. The third line contain N integers representing the volume of each bone.<br>Output</p>
<p>One integer per line representing the maximum of the total value (this number will be less than 231).<br>Sample Input</p>
<p>1 5 10 1 2 3 4 5 5 4 3 2 1<br>Sample Output</p>
<p>14</p>
<p>裸的01背包啦啦啦啦</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1005</span>;</span><br><span class="line">int n, v, d[N], val[N], vol[N], cas;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    scanf (<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span> (cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        memset (d, <span class="number">0</span>, sizeof (d));</span><br><span class="line">        scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;v);</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            scanf (<span class="string">&quot;%d&quot;</span>, &amp;val[i]);</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf (<span class="string">&quot;%d&quot;</span>, &amp;vol[i]);</span><br><span class="line">            <span class="keyword">for</span> (int j = v; j &gt;= vol[i]; --j)</span><br><span class="line">                d[j] = max (d[j], d[j - vol[i]] + val[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf (<span class="string">&quot;%d\n&quot;</span>, d[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 2830 Matrix Swapping II （DP,最大全1矩阵）</title>
    <url>/posts/oj/dp/HDU%202830%20Matrix%20Swapping%20II%20%EF%BC%88DP,%E6%9C%80%E5%A4%A7%E5%85%A81%E7%9F%A9%E9%98%B5%EF%BC%89/</url>
    <content><![CDATA[<p>题意 给你一个n&#x2F;*m矩阵 每列都可以随便交换位置 求最优交换后最大的全1子矩阵</p>
<p>又是HDU 1505 1506的变种 但这个更容易了 因为每列都可以交换位置了 那么这一行中所有比i高的都可以与i相邻了 只需要统计这一行有多少个比i高就行了 可以在算出每一行后 把高度大的放前面去 用num[i]记录排序后的列原来的数 这样就有j列比h[i][num[j]]高了 最后的答案也就是max(j&#x2F;*h[i][num[j]])</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1005</span>;</span><br><span class="line">char mat[N][N];</span><br><span class="line">int num[N], h[N][N], n, m, i;</span><br><span class="line"></span><br><span class="line">bool cmp (int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> h[i][a] &gt; h[i][b];</span><br><span class="line">&#125;<span class="comment">//cmp不能有=</span></span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (~scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        int ans = <span class="number">0</span>;</span><br><span class="line">        memset (h, <span class="number">0</span>, sizeof (h));</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            scanf (<span class="string">&quot;%s&quot;</span>, mat[i] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (mat[i][j] == <span class="string">&#x27;1&#x27;</span>)  h[i][j] = h[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                num[j] = j;</span><br><span class="line">            &#125;</span><br><span class="line">            sort (num + <span class="number">1</span>, num + m + <span class="number">1</span>, cmp);</span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">                ans = max (ans, j * h[i][num[j]]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf (<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Matrix-Swapping-II"><a href="#Matrix-Swapping-II" class="headerlink" title="Matrix Swapping II"></a>Matrix Swapping II</h1><p>Problem Description</p>
<p>Given an N &#x2F;* M matrix with each entry equal to 0 or 1. We can find some rectangles in the matrix whose entries are all 1, and we define the maximum area of such rectangle as this matrix’s goodness.<br>We can swap any two columns any times, and we are to make the goodness of the matrix as large as possible.<br>Input</p>
<p>There are several test cases in the input. The first line of each test case contains two integers N and M (1 ≤ N,M ≤ 1000). Then N lines follow, each contains M numbers (0 or 1), indicating the N &#x2F;* M matrix<br>Output</p>
<p>Output one line for each test case, indicating the maximum possible goodness.<br>Sample Input</p>
<p>3 4 1011 1001 0001 3 4 1010 1001 0001<br>Sample Output</p>
<p>4 2 Note: Huge Input, scanf() is recommended.</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 2844 Coins (组合背包)</title>
    <url>/posts/oj/dp/HDU%202844%20Coins%20(%E7%BB%84%E5%90%88%E8%83%8C%E5%8C%85)/</url>
    <content><![CDATA[<p>题意 给你n种面额不同的金币和每种金币的个数 求这些金币能组合成的面额在m内有多少种</p>
<p>还是明显的背包问题 d[i]表示这些金币在i内能组合成的最大面额 初始化d为负无穷 d[0]&#x3D;0 这样就可以保证d[i]恰好为i时才能为正值</p>
<p>原因可以自己想想 然后就用背包背吧 直接多重背包也可以过 但是分成多重背包和完全背包要快一点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">105</span>, M = <span class="number">100005</span>;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, m, val[N], num[N], d[M], ans;</span><br><span class="line">    <span class="keyword">while</span> (scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m), n &amp;&amp; m)</span><br><span class="line">    &#123;</span><br><span class="line">        memset (d, <span class="number">0x8f</span>, sizeof (d));</span><br><span class="line">        d[<span class="number">0</span>] = ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            scanf (<span class="string">&quot;%d&quot;</span>, &amp;val[i]);</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            scanf (<span class="string">&quot;%d&quot;</span>, &amp;num[i]);</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[i]*val[i] &gt;= m)</span><br><span class="line">                <span class="keyword">for</span> (int j = val[i]; j &lt;= m; ++j)</span><br><span class="line">                    d[j] = max (d[j], d[j - val[i]] + val[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (int k = <span class="number">1</span>; k &lt;= num[i]; k *= <span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (int j = m; j &gt;= k * val[i]; --j)</span><br><span class="line">                        d[j] = max (d[j], d[j - k * val[i]] + k * val[i]);</span><br><span class="line">                    num[i] -= k;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (num[i] &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">for</span> (int j = m; j &gt;= num[i]*val[i]; --j)</span><br><span class="line">                        d[j] = max (d[j], d[j - num[i] * val[i]] + num[i] * val[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            <span class="keyword">if</span> (d[i] &gt; <span class="number">0</span>) ++ans;</span><br><span class="line">        printf (<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Coins"><a href="#Coins" class="headerlink" title="Coins"></a>Coins</h1><p>Problem Description</p>
<p>Whuacmers use coins.They have coins of value A1,A2,A3…An Silverland dollar. One day Hibix opened purse and found there were some coins. He decided to buy a very nice watch in a nearby shop. He wanted to pay the exact price(without change) and he known the price would not more than m.But he didn’t know the exact price of the watch.<br>You are to write a program which reads n,m,A1,A2,A3…An and C1,C2,C3…Cn corresponding to the number of Tony’s coins of value A1,A2,A3…An then calculate how many prices(form 1 to m) Tony can pay use these coins.<br>Input</p>
<p>The input contains several test cases. The first line of each test case contains two integers n(1 ≤ n ≤ 100),m(m ≤ 100000).The second line contains 2n integers, denoting A1,A2,A3…An,C1,C2,C3…Cn (1 ≤ Ai ≤ 100000,1 ≤ Ci ≤ 1000). The last test case is followed by two zeros.<br>Output</p>
<p>For each test case output the answer on a single line.<br>Sample Input</p>
<p>3 10 1 2 4 2 1 1 2 5 1 4 2 1 0 0<br>Sample Output</p>
<p>8 4</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 2845 Beans(DP,最大不连续和)</title>
    <url>/posts/oj/dp/HDU%202845%20Beans(DP,%E6%9C%80%E5%A4%A7%E4%B8%8D%E8%BF%9E%E7%BB%AD%E5%92%8C)/</url>
    <content><![CDATA[<p>题意 吃豆子游戏 当你吃了一个格子的豆子 该格子左右两个和上下两行就不能吃了 输入每个格子的豆子数 求你最多能吃多少颗豆子</p>
<p>可以先求出每行你最多可以吃多少颗豆子 然后每行就压缩成只有一个格子了 里面的豆子数就是那一行最多可以吃的豆子数 然后问题就变成求一列最多可以吃多少颗豆子了 和处理每一行一样处理 那么问题就简化成求一行数字的最大不连续和问题了</p>
<p>令d[i]表示某一行前i个豆子的最大和 有两种情况 吃第i个格子中的豆子和不吃第i个格子中的豆子 a[i]为第i个格子中的豆子数</p>
<p>吃 d[i]&#x3D;d[i-2]+a[i] 不吃 d[i]&#x3D;d[i-1]</p>
<p>所以有转移方程 d[i]&#x3D;max(d[i-2]+a[i],d[i-1])</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N=<span class="number">2014</span>;</span><br><span class="line">int d[N],row[N],col[N],mat[N][N],n,m;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (~scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">                scanf (<span class="string">&quot;%d&quot;</span>, &amp;mat[i][j]);</span><br><span class="line">        memset (row, <span class="number">0</span>, sizeof (row));</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            memset (d, <span class="number">0</span>, sizeof (d));</span><br><span class="line">            d[<span class="number">1</span>] = mat[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">2</span>; j &lt;= m; ++j)</span><br><span class="line">                d[j] = max (d[j - <span class="number">1</span>], d[j - <span class="number">2</span>] + mat[i][j]);</span><br><span class="line">            row[i] = max (row[i], d[m]);</span><br><span class="line">        &#125;</span><br><span class="line">        memset (col, <span class="number">0</span>, sizeof (col));</span><br><span class="line">        col[<span class="number">1</span>] = row[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            col[i] = max (col[i - <span class="number">1</span>], col[i - <span class="number">2</span>] + row[i]);</span><br><span class="line">        printf (<span class="string">&quot;%d\n&quot;</span>, col[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Beans"><a href="#Beans" class="headerlink" title="Beans"></a>Beans</h1><p>Problem Description</p>
<p>Bean-eating is an interesting game, everyone owns an M&#x2F;*N matrix, which is filled with different qualities beans. Meantime, there is only one bean in any 1&#x2F;*1 grid. Now you want to eat the beans and collect the qualities, but everyone must obey by the following rules: if you eat the bean at the coordinate(x, y), you can’t eat the beans anyway at the coordinates listed (if exiting): (x, y-1), (x, y+1), and the both rows whose abscissas are x-1 and x+1.<br>  <img src="/../images/cn-data-images-convip1-1001-1.JPG.png">  Now, how much qualities can you eat and then get ?<br>Input</p>
<p>There are a few cases. In each case, there are two integer M (row number) and N (column number). The next M lines each contain N integers, representing the qualities of the beans. We can make sure that the quality of bean isn’t beyond 1000, and 1&lt;&#x3D;M&#x2F;*N&lt;&#x3D;200000.<br>Output</p>
<p>For each case, you just output the MAX qualities you can eat and then get.<br>Sample Input</p>
<p>4 6 11 0 7 5 13 9 78 4 81 6 22 4 1 40 9 34 16 10 11 22 0 33 39 6<br>Sample Output</p>
<p>242<br>其实上面的代码还是有 bug的 题目说的是N&#x2F;*M&lt;&#x3D;200000 并没有说N和M的具体范围 这里给出一位数组读入的版本</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">200010</span>;</span><br><span class="line">int d[N], row[N], col[N], mat[N], n, m;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (~scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">                scanf (<span class="string">&quot;%d&quot;</span>, &amp;mat[i * m + j]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            d[<span class="number">0</span>] = mat[i * m + <span class="number">0</span>], d[<span class="number">1</span>] = max (mat[i * m + <span class="number">1</span>], d[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">2</span>; j &lt; m; ++j)</span><br><span class="line">                d[j] = max (d[j - <span class="number">1</span>], d[j - <span class="number">2</span>] + mat[i * m + j]);</span><br><span class="line">            row[i] = d[m - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        col[<span class="number">0</span>] = row[<span class="number">0</span>], col[<span class="number">1</span>] = max (row[<span class="number">0</span>], row[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">2</span>; i &lt; n; ++i)</span><br><span class="line">            col[i] = max (col[i - <span class="number">1</span>], col[i - <span class="number">2</span>] + row[i]);</span><br><span class="line">        printf (<span class="string">&quot;%d\n&quot;</span>, col[n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 2870 Largest Submatrix(DP)</title>
    <url>/posts/oj/dp/HDU%202870%20Largest%20Submatrix(DP)/</url>
    <content><![CDATA[<p>题意 求最大相同字符子矩阵 其中一些字符可以转换</p>
<p>其实就是HDU1505 1506的加强版 但是分了a,b,c三种情况 看哪次得到的面积最大</p>
<p>对于某一个情况 可以把该字符和可以转换为该字符的位置赋值0 其它位置赋值１　这样就转化成了求最大全0矩阵的问题了</p>
<p>对于转换后矩阵中的每个点　看他向上有多少个连续0　把这个值存在ｈ数组中　再用l数组和ｒ数组记录ｈ连续大于等于该位置的最左边位置和最右位置　这样包含(i,j)点的最大矩阵面积就是(r[i][j]-l[i][j]+1)&#x2F;*h[i][j]　面积最大的点就是最大全0矩阵了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1005</span>;</span><br><span class="line">char s[N][N];</span><br><span class="line">int mat[N][N], l[N][N], r[N][N], h[N][N], n, m, ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> makeMat (char a, char b, char c)</span><br><span class="line">&#123;</span><br><span class="line">    memset (mat, <span class="number">0</span>, sizeof (mat));</span><br><span class="line">    memset (l, <span class="number">0</span>, sizeof (l));</span><br><span class="line">    memset (r, <span class="number">0</span>, sizeof (r));</span><br><span class="line">    memset (h, <span class="number">0</span>, sizeof (h));</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        h[i][<span class="number">0</span>] = h[i][m + <span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            l[i][j] = r[i][j] = j;</span><br><span class="line">            <span class="keyword">if</span> (s[i][j] == a || s[i][j] == b || s[i][j] == c)  mat[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (mat[i][j] == <span class="number">0</span>) h[i][j] = h[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int solve (char a, char b, char c)</span><br><span class="line">&#123;</span><br><span class="line">    makeMat (a, b, c);</span><br><span class="line">    int aans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (int j = m; j &gt;= <span class="number">1</span>; --j)</span><br><span class="line">            <span class="keyword">while</span> (h[i][r[i][j] + <span class="number">1</span>] &gt;= h[i][j])</span><br><span class="line">                r[i][j] = r[i][r[i][j] + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (h[i][l[i][j] - <span class="number">1</span>] &gt;= h[i][j])</span><br><span class="line">                l[i][j] = l[i][l[i][j] - <span class="number">1</span>];</span><br><span class="line">            aans = max (aans, (r[i][j] - l[i][j] + <span class="number">1</span>) * h[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> aans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (~scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            scanf (<span class="string">&quot;%s&quot;</span>, s[i] + <span class="number">1</span>);</span><br><span class="line">        ans = max (solve (<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>), solve (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;c&#x27;</span>));</span><br><span class="line">        ans = max (ans, solve (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;w&#x27;</span>));</span><br><span class="line">        printf (<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Largest-Submatrix"><a href="#Largest-Submatrix" class="headerlink" title="Largest Submatrix"></a>Largest Submatrix</h1><p>Problem Description</p>
<p>Now here is a matrix with letter ‘a’,’b’,’c’,’w’,’x’,’y’,’z’ and you can change ‘w’ to ‘a’ or ‘b’, change ‘x’ to ‘b’ or ‘c’, change ‘y’ to ‘a’ or ‘c’, and change ‘z’ to ‘a’, ‘b’ or ‘c’. After you changed it, what’s the largest submatrix with the same letters you can make?<br>Input</p>
<p>The input contains multiple test cases. Each test case begins with m and n (1 ≤ m, n ≤ 1000) on line. Then come the elements of a matrix in row-major order on m lines each with n letters. The input ends once EOF is met.<br>Output</p>
<p>For each test case, output one line containing the number of elements of the largest submatrix of all same letters.<br>Sample Input</p>
<p>2 4 abcw wxyz<br>Sample Output</p>
<p>3</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 3008 Warcraft (DP)</title>
    <url>/posts/oj/dp/HDU%203008%20Warcraft%20(DP)/</url>
    <content><![CDATA[<p>题意 你去打boss 开始你的蓝和血还有boss的血都是100 每秒你先打boss一下 然后boss打你一下你减少q点血 你有n个技能 第i个技能耗蓝a[i] 对boss的伤害为b[i] 普攻伤害为1 而且你每秒回复t点蓝（恢复后不超过100） 求你最少可以多少次打死boss</p>
<p>你最多能打100&#x2F;q或者100&#x2F;q+1次 令d[i][j]表示第i秒所剩蓝量为j时boss剩下的最少血量 m为j还未恢复蓝之前的蓝量 j &#x3D; min (100, m + t) 那么有 d[i][j] &#x3D; min (d[i][j], d[i - 1][m + a[k]] - b[k]);</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">105</span>;</span><br><span class="line">int a[N], b[N], d[N][N];</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, t, q, ans, ti;</span><br><span class="line">    <span class="keyword">while</span> (scanf (<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;t, &amp;q), n)</span><br><span class="line">    &#123;</span><br><span class="line">        ++n;</span><br><span class="line">        ti = (<span class="number">100</span> % q) ? (<span class="number">100</span> / q + <span class="number">1</span>) : (<span class="number">100</span> / q);</span><br><span class="line">        a[<span class="number">1</span>] = <span class="number">0</span>, b[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;a[i], &amp;b[i]);</span><br><span class="line">            </span><br><span class="line">        memset (d, <span class="number">0x3f</span>, sizeof (d));</span><br><span class="line">        d[<span class="number">0</span>][<span class="number">100</span>] = <span class="number">100</span>; ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= ti; ++i)</span><br><span class="line">            <span class="keyword">for</span> (int m = <span class="number">0</span>; m &lt;= <span class="number">100</span>; ++m)</span><br><span class="line">            &#123;</span><br><span class="line">                int j = min (<span class="number">100</span>, m + t);</span><br><span class="line">                <span class="keyword">for</span> (int k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">                    <span class="keyword">if</span> (m + a[k] &lt;= <span class="number">100</span>)</span><br><span class="line">                        d[i][j] = min (d[i][j], d[i - <span class="number">1</span>][m + a[k]] - b[k]);</span><br><span class="line">                <span class="keyword">if</span> (d[i][j] &lt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans = i, i = ti;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">0</span>) printf (<span class="string">&quot;My god\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> printf (<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Warcraft"><a href="#Warcraft" class="headerlink" title="Warcraft"></a>Warcraft</h1><p>Problem Description</p>
<p>Have you ever played the Warcraft?It doesn’t matter whether you have played it !We will give you such an experience.There are so many Heroes in it,but you could only choose one of them.Each Hero has his own skills.When such a Skill is used ,it costs some MagicValue,but hurts the Boss at the same time.Using the skills needs intellegence,one should hurt the enemy to the most when using certain MagicValue.<br>Now we send you to complete such a duty to kill the Boss(So cool~~).To simplify the problem:you can assume the LifeValue of the monster is 100, your LifeValue is 100,but you have also a 100 MagicValue!You can choose to use the ordinary Attack(which doesn’t cost MagicValue),or a certain skill(in condition that you own this skill and the MagicValue you have at that time is no less than the skill costs),there is no free lunch so that you should pay certain MagicValue after you use one skill!But we are good enough to offer you a “ResumingCirclet”(with which you can resume the MagicValue each seconds),But you can’t own more than 100 MagicValue and resuming MagicValue is always after you attack.The Boss is cruel , be careful!<br>Input</p>
<p>There are several test cases,intergers n ,t and q (0&lt;n&lt;&#x3D;100，1&lt;&#x3D;t&lt;&#x3D;5，q&gt;0) in the first line which mean you own n kinds of skills ,and the “ResumingCirclet” helps you resume t points of MagicValue per second and q is of course the hurt points of LifeValue the Boss attack you each time(we assume when fighting in a second the attack you show is before the Boss).Then n lines follow,each has 2 intergers ai and bi(0&lt;ai,bi&lt;&#x3D;100).which means using i skill costs you ai MagicValue and costs the Boss bi LifeValue.The last case is n&#x3D;t&#x3D;q&#x3D;0.<br>Output</p>
<p>Output an interger min (the minimun time you need to kill the Boss)in one line .But if you die(the LifeValue is no more than 0) ,output “My god”!<br>Sample Input</p>
<p>4 2 25 10 5 20 10 30 28 76 70 4 2 25 10 5 20 10 30 28 77 70 0 0 0<br>Sample Output</p>
<p>4 My god</p>
<p><em>Hint</em> Hint: When fighting,you can only choose one kind of skill or just to use the ordinary attack in the whole second,the ordinary attack costs the Boss 1 points of LifeValue,the Boss can only use ordinary attack which costs a whole second at a time.Good Luck To You!</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 4882 ZCC Loves Codefires(贪心)</title>
    <url>/posts/oj/dp/HDU%204882%20ZCC%20Loves%20Codefires(%E8%B4%AA%E5%BF%83)/</url>
    <content><![CDATA[<p>﻿﻿</p>
<p>题意 有n个题目 完成第i个题目需要的时间为e[i] 第i个题目的系数为k[i] 你可以按任意顺序完成题目 比赛开始到完成第i个题目消耗的总时间为t[i] 那么完成第i个题目要扣掉k[i]&#x2F;*t[i]分 求完成所有题目至少扣多少分</p>
<p>考虑任意相邻两题i,j 改变i,j时 i,j之前和之后所有的题目对结果都没有影响 只是i,j两题的扣分和由原来的(t+e[i])&#x2F;*k[i]+(t+e[i]+e[j])&#x2F;*k[j]变成了(t+e[i]+e[j])&#x2F;*k[i]+(t+e[j])&#x2F;*k[j]<br>比较可以发现只是e[i]&#x2F;*k[j]变成了e[j]&#x2F;*k[i] 所以 若e[i]&#x2F;*k[j]&lt;e[j]&#x2F;*k[i] 那么i就应该在j之前完成 以此进行排序即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;span style=<span class="string">&quot;font-size:14px;&quot;</span>&gt;#include&lt;cstdio&gt;  </span><br><span class="line">#include&lt;algorithm&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line">typedef long long ll;  </span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">100050</span>;  </span><br><span class="line">ll k[N], o[N], t[N], e[N], n;  </span><br><span class="line">  </span><br><span class="line">bool cmp (int i, int j)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">return</span> (e[i] * k[j] &lt; e[j] * k[i]);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">while</span> (scanf (<span class="string">&quot;%I64d&quot;</span>, &amp;n) != <span class="variable constant_">EOF</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)  </span><br><span class="line">            scanf (<span class="string">&quot;%I64d&quot;</span>, &amp;e[i]);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)  </span><br><span class="line">        &#123;  </span><br><span class="line">            o[i] = i;  </span><br><span class="line">            scanf (<span class="string">&quot;%I64d&quot;</span>, &amp;k[i]);  </span><br><span class="line">        &#125;  </span><br><span class="line">        sort (o + <span class="number">1</span>, o + n + <span class="number">1</span>, cmp);  </span><br><span class="line">        ll ans=<span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)  </span><br><span class="line">        &#123;  </span><br><span class="line">            int j=o[i];  </span><br><span class="line">            t[j]=t[o[i-<span class="number">1</span>]]+e[j];  </span><br><span class="line">            ans += k[j] * t[j];  </span><br><span class="line">        &#125;  </span><br><span class="line">        printf (<span class="string">&quot;%I64d\n&quot;</span>, ans);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; &lt;/span&gt;</span><br></pre></td></tr></table></figure>

<p>Though ZCC has many Fans, ZCC himself is a crazy Fan of a coder, called “Memset137”.<br>It was on Codefires(CF), an online competitive programming site, that ZCC knew Memset137, and immediately became his fan.<br>But why?<br>Because Memset137 can solve all problem in rounds, without unsuccessful submissions; his estimation of time to solve certain problem is so accurate, that he can surely get an Accepted the second he has predicted. He soon became IGM, the best title of Codefires. Besides, he is famous for his coding speed and the achievement in the field of Data Structures.<br>After become IGM, Memset137 has a new goal: He wants his score in CF rounds to be as large as possible.<br>What is score? In Codefires, every problem has 2 attributes, let’s call them Ki and Bi(Ki, Bi＞0). if Memset137 solves the problem at Ti-th second, he gained Bi-Ki&#x2F;*Ti score. It’s guaranteed Bi-Ki&#x2F;*Ti is always positive during the round time.<br>Now that Memset137 can solve every problem, in this problem, Bi is of no concern. Please write a program to calculate the minimal score he will lose.(that is, the sum of Ki&#x2F;*Ti).<br>Input</p>
<p>The first line contains an integer N(1≤N≤10^5), the number of problem in the round.<br>The second line contains N integers Ei(1≤Ei≤10^4), the time(second) to solve the i-th problem.<br>The last line contains N integers Ki(1≤Ki≤10^4), as was described.<br>Output</p>
<p>One integer L, the minimal score he will lose.<br>Sample Input</p>
<p>3 10 10 20 1 2 3<br>Sample Output</p>
<p>150</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 5087 Revenge of LIS II(次长上升子序列)</title>
    <url>/posts/oj/dp/HDU%205087%20Revenge%20of%20LIS%20II(%E6%AC%A1%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97)/</url>
    <content><![CDATA[<p>题意 求一个序列的所有上升子序列中第二长的那个的长度</p>
<p>简单的dp d[i]表示以第i个数结尾的最长上升子序列的长度 c[i]表示到达d[i]的方法数 如序列1 1 2 d[3]&#x3D;2,c[3]&#x3D;2 因为选1 3位置和 2 3位置的都可以得到d[3]&#x3D;2 递推过程很简单 d[i]&#x3D;max｛d[j]+1｝其中a[i]&gt;a[j]&amp;&amp;i&gt;j</p>
<p>最后看d[1~n]中最大的数出现了几次 出现了不止一次就直接输出否则就减一输出咯</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1005</span>;</span><br><span class="line">int n, a[N];</span><br><span class="line">int d[N], c[N], cas, ans;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span> (cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        int sum = ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">            d[i] = <span class="number">1</span>, c[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[j] &gt;= a[i]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (d[j] + <span class="number">1</span> &gt; d[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    d[i] = d[j] + <span class="number">1</span>;</span><br><span class="line">                    c[i] = c[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (d[j] + <span class="number">1</span> == d[i])    c[i] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(d[i] &gt; ans) ans = d[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (d[i] == ans)  sum += c[i];</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum &gt; <span class="number">1</span> ? ans : ans - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Revenge-of-LIS-II"><a href="#Revenge-of-LIS-II" class="headerlink" title="Revenge of LIS II"></a>Revenge of LIS II</h1><p>Problem Description</p>
<p>In computer science, the longest increasing subsequence problem is to find a subsequence of a given sequence in which the subsequence’s elements are in sorted order, lowest to highest, and in which the subsequence is as long as possible. This subsequence is not necessarily contiguous, or unique.<br>—Wikipedia<br>Today, LIS takes revenge on you, again. You mission is not calculating the length of longest increasing subsequence, but the length of the second longest increasing subsequence.<br>Two subsequence is different if and only they have different length, or have at least one different element index in the same place. And second longest increasing subsequence of sequence S indicates the second largest one while sorting all the increasing subsequences of S by its length.<br>Input</p>
<p>The first line contains a single integer T, indicating the number of test cases.<br>Each test case begins with an integer N, indicating the length of the sequence. Then N integer Ai follows, indicating the sequence.<br>[Technical Specification]</p>
<ol>
<li>1 &lt;&#x3D; T &lt;&#x3D; 100</li>
<li>2 &lt;&#x3D; N &lt;&#x3D; 1000</li>
<li>1 &lt;&#x3D; Ai &lt;&#x3D; 1 000 000 000<br>Output</li>
</ol>
<p>For each test case, output the length of the second longest increasing subsequence.<br>Sample Input</p>
<p>3 2 1 1 4 1 2 3 4 5 1 1 2 2 2<br>Sample Output</p>
<p>1 3 2</p>
<p>HintFor the first sequence, there are two increasing subsequence: [1], [1]. So the length of the second longest increasing subsequence is also 1, same with the length of LIS.</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1157 Little shop of flowers(DP,最优搭配)</title>
    <url>/posts/oj/dp/POJ%201157%20Little%20shop%20of%20flowers(DP,%E6%9C%80%E4%BC%98%E6%90%AD%E9%85%8D)/</url>
    <content><![CDATA[<p>﻿﻿ 题意 你有f束花和v个花瓶 每束花放在不同的花瓶中都会有不同的价值 并且花的相对顺序不能改变 也就是说第i束花放在第j个花瓶中 那么第i+1朵花要放在j以后的花瓶中 令d[i][j]表示第i朵花放在第[j]个瓶子中前i朵花的最大价值 有状态转移方程 d[i][j]&#x3D;max{d[i-1][1~j-1]}+val[i][j]; 题目有几个坑点 可能所有价值都为负数 必须所有花都放完  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;  </span><br><span class="line">#include&lt;cstring&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line">#define M <span class="number">205</span>  </span><br><span class="line">int val[M][M],d[M][M],pre[M][M],f,v,key;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span>(<span class="params">int i,int j</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span>(pre[i][j])  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="title function_">print</span>(i-<span class="number">1</span>,pre[i][j]);  </span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot; %d&quot;</span>,j);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d&quot;</span>,j);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;f,&amp;v);  </span><br><span class="line">    <span class="title function_">memset</span>(d,<span class="number">0x8f</span>,<span class="title function_">sizeof</span>(d));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>; i&lt;=f; ++i)  </span><br><span class="line">        <span class="keyword">for</span>(int j=<span class="number">1</span>; j&lt;=v; ++j)  </span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val[i][j]);  </span><br><span class="line">  </span><br><span class="line">    int ans=d[<span class="number">0</span>][<span class="number">0</span>];  </span><br><span class="line">    <span class="comment">//注意要把ans初始化为负无穷 可能所有的val都为负；这里wa了好久；  </span></span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;  </span><br><span class="line">    <span class="comment">//0朵花价值当然为0了；  </span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>; i&lt;=f; ++i)  </span><br><span class="line">        <span class="keyword">for</span>(int j=<span class="number">1</span>; j&lt;=v; ++j)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">for</span>(int k=<span class="number">0</span>; k&lt;j; ++k)  </span><br><span class="line">                <span class="keyword">if</span>(d[i-<span class="number">1</span>][k]+val[i][j]&gt;d[i][j])  </span><br><span class="line">                &#123;  </span><br><span class="line">                    d[i][j]=d[i-<span class="number">1</span>][k]+val[i][j];  </span><br><span class="line">                    pre[i][j]=k;  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    <span class="keyword">for</span>(int j=<span class="number">1</span>; j&lt;=v; ++j)  </span><br><span class="line">        <span class="keyword">if</span>(d[f][j]&gt;ans)  </span><br><span class="line">        &#123;  </span><br><span class="line">            ans=d[f][j];  </span><br><span class="line">            key=j;  </span><br><span class="line">        &#125;  </span><br><span class="line">    <span class="comment">//这里要在最后一层更新ans 因为要保证所有花都放进去；  </span></span><br><span class="line">  </span><br><span class="line">    <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);  </span><br><span class="line">    <span class="title function_">print</span>(f,key);  </span><br><span class="line">    <span class="title function_">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Little shop of flowers</strong></p>
<hr>
<p><strong>PROBLEM</strong></p>
<hr>
<p>You want to arrange the window of your flower shop in a most pleasant way. You have<em>F</em>bunches of flowers, each being of a different kind, and at least as many vases ordered in a row. The vases are glued onto the shelf and are numbered consecutively 1 through<em>V</em>, where<em>V</em>is the number of vases, from left to right so that the vase 1 is the leftmost, and the vase<em>V</em>is the rightmost vase. The bunches are moveable and are uniquely identified by integers between 1 and<em>F</em>. These id-numbers have a significance: They determine the required order of appearance of the flower bunches in the row of vases so that the bunch<em>i</em>must be in a vase to the left of the vase containing bunch<em>j</em>whenever<em>i</em>&lt;<em>j</em>. Suppose, for example, you have bunch of azaleas (id-number&#x3D;1), a bunch of begonias (id-number&#x3D;2) and a bunch of carnations (id-number&#x3D;3). Now, all the bunches must be put into the vases keeping their id-numbers in order. The bunch of azaleas must be in a vase to the left of begonias, and the bunch of begonias must be in a vase to the left of carnations. If there are more vases than bunches of flowers then the excess will be left empty. A vase can hold only one bunch of flowers.</p>
<p>Each vase has a distinct characteristic (just like flowers do). Hence, putting a bunch of flowers in a vase results in a certain aesthetic value, expressed by an integer. The aesthetic values are presented in a table as shown below. Leaving a vase empty has an aesthetic value of 0.</p>
<hr>
<p><strong>V A S E S</strong> ****</p>
<p><strong>1</strong></p>
<hr>
<p><strong>2</strong></p>
<hr>
<p><strong>3</strong></p>
<hr>
<p><strong>4</strong></p>
<hr>
<p><strong>5</strong> ****</p>
<p><strong>Bunches</strong></p>
<hr>
<p><strong>1 (azaleas)</strong></p>
<p>7</p>
<p>23</p>
<p>-5</p>
<p>-24</p>
<p>16 ****</p>
<p><strong>2 (begonias)</strong></p>
<p>5</p>
<p>21</p>
<p>-4</p>
<p>10</p>
<p>23 ****</p>
<p><strong>3 (carnations)</strong></p>
<p>-21</p>
<p>5</p>
<p>-4</p>
<p>-20</p>
<p>20</p>
<p>According to the table, azaleas, for example, would look great in vase 2, but they would look awful in vase 4.</p>
<p>To achieve the most pleasant effect you have to maximize the sum of aesthetic values for the arrangement while keeping the required ordering of the flowers. If more than one arrangement has the maximal sum value, any one of them will be acceptable. You have to produce exactly one arrangement.</p>
<hr>
<p>ASSUMPTIONS</p>
<p>1 ≤<em>F</em>≤ 100 where<em>F</em>is the number of the bunches of flowers. The bunches are numbered 1 through<em>F</em>.</p>
<p>**</p>
<p><em>F</em>≤<em>V</em>≤ 100 where<em>V</em>is the number of vases.</p>
<p>-50£<em>Aij</em>£50 where<em>Aij</em>is the aesthetic value obtained by putting the flower bunch<em>i</em>into the vase<em>j</em>.</p>
<hr>
<p>Input</p>
<p>The first line contains two numbers:<em>F</em>,<em>V</em>.</p>
<p>The following<em>F</em>lines: Each of these lines contains<em>V</em>integers, so that<em>Aij</em>is given as the<em>j</em>’th number on the (<em>i</em>+1)’st line of the input file.</p>
<hr>
<p>Output</p>
<p>The first line will contain the sum of aesthetic values for your arrangement.</p>
<p>The second line must present the arrangement as a list of<em>F</em>numbers, so that the<em>k</em>’th number on this line identifies the vase in which the bunch<em>k</em>is put.</p>
<p>Sample Input<br>3 5 7 23 -5 -24 16 5 21 -4 10 23 -21 5 -4 -20 20</p>
<p>Sample Output<br>53 2 4 5</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1205 Water Treatment Plants(递推)</title>
    <url>/posts/oj/dp/POJ%201205%20Water%20Treatment%20Plants(%E9%80%92%E6%8E%A8)/</url>
    <content><![CDATA[<p>题意 建设一条河岸的污水处理系统 河岸有n个城市 每个城市都可以自己处理污水 V 也可以把污水传到相邻的城市处理 &gt;或&lt; 除了你传给我我也传给你这种情况 其它都是合法的 两端的城市不能传到不存在的城市</p>
<p>令d[i]表示有i个城市时的处理方法数 最后一个城市的处理方法有</p>
<p>1.V 自己处理自己的 与前i-1个城市的处理方法无关 有d[i-1]种方法</p>
<p>2.&lt; 给左边的城市去处理 也与前i-1个城市的处理方法无关 把自己的污水给第i-1个城市就行了 有d[i-1]种方法</p>
<p>3.&gt;V 左边有污水传过来 和自己的一起处理 这时第i-1个城市可以向右传了 如果这种情况发生的话 那么第i-1个城市肯定不可能是向左传的 但前i-2个城市的处理方法没有影响 所以第i-1个城市向左传的方法有d[i-2]种 然后第i-1个城市不向左传就有d[i-1]-d[i-2]种方法了</p>
<p>所以有递推公式d[i]&#x3D;3&#x2F;*d[i-1]-d[i-2];</p>
<p>增长速度很快要用大数处理 大数就用java了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.<span class="property">util</span>.*;</span><br><span class="line"><span class="keyword">import</span> java.<span class="property">math</span>.*;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	public <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span> args[]</span>) &#123;</span><br><span class="line">		<span class="title class_">Scanner</span> <span class="keyword">in</span> = <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="title class_">System</span>.<span class="property">in</span>);</span><br><span class="line">		<span class="title class_">BigInteger</span> d[] = <span class="keyword">new</span> <span class="title class_">BigInteger</span>[<span class="number">105</span>];</span><br><span class="line">		d[<span class="number">1</span>] = <span class="title class_">BigInteger</span>.<span class="property">ONE</span>;</span><br><span class="line">		d[<span class="number">2</span>] = <span class="title class_">BigInteger</span>.<span class="title function_">valueOf</span>(<span class="number">3</span>);</span><br><span class="line">		<span class="keyword">for</span> (int i = <span class="number">3</span>; i &lt;= <span class="number">100</span>; ++i)</span><br><span class="line">			d[i] = d[i - <span class="number">1</span>].<span class="title function_">multiply</span>(d[<span class="number">2</span>]).<span class="title function_">subtract</span>(d[i - <span class="number">2</span>]);</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">in</span>.<span class="title function_">hasNext</span>())</span><br><span class="line">			<span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(d[<span class="keyword">in</span>.<span class="title function_">nextInt</span>()]);</span><br><span class="line">		<span class="keyword">in</span>.<span class="title function_">close</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&lt;span style=<span class="string">&quot;font-family:Microsoft YaHei;&quot;</span>&gt;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<p>还有没加大数模版的c++代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">105</span>;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int d[N] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>&#125;, n;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">3</span>; i &lt;= <span class="number">100</span>; ++i)</span><br><span class="line">        d[i] = <span class="number">3</span> * d[i - <span class="number">1</span>] - d[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span> (~scanf (<span class="string">&quot;%d&quot;</span>, &amp;n))</span><br><span class="line">        printf (<span class="string">&quot;%d\n&quot;</span>, d[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Water Treatment Plants</p>
<p>Description</p>
<p>River polution control is a major challenge that authorities face in order to ensure future clean water supply. Sewage treatment plants are used to clean-up the dirty water comming from cities before being discharged into the river.<br>As part of a coordinated plan, a pipeline is setup in order to connect cities to the sewage treatment plants distributed along the river. It is more efficient to have treatment plants running at maximum capacity and less-used ones switched off for a period. So, each city has its own treatment plant by the river and also a pipe to its neighbouring city upstream and a pipe to the next city downstream along the riverside. At each city’s treatment plant there are three choices:</p>
<p><img src="/../images/es-1205_1.jpg.png"><br>The choices above ensure that:<br>every city must have its water treated somewhere and<br>at least one city must discharge the cleaned water into the river.<br>Let’s represent a city discharging water into the river as “V” (a downwards flow), passing water onto its neighbours as “&gt;” (to the next city on its right) or else “&lt;” (to the left). When we have several cities along the river bank, we assign a symbol to each (V, &lt; or &gt;) and list the cities symbols in order. For example, two cities, A and B, can<br>each treat their own sewage and each discharges clean water into the river. So A’s action is denoted V as is B’s and we write “VV” ;<br>or else city A can send its sewage along the pipe (to the right) to B for treatment and discharge, denoted “&gt;V”;<br>or else city B can send its sewage to (the left to) A, which treats it with its own dirty water and discharges (V) the cleaned water into the river. So A discharges (V) and B passes water to the left (&lt;), and we denote this situation as “V&lt;”.<br>We could not have “&gt;&lt;” since this means A sends its water to B and B sends its own to A, so both are using the same pipe and this is not allowed. Similarly “&lt;&lt;” is not possible since A’s “&lt;” means it sends its water to a non-existent city on its left.<br>So we have just 3 possible set-ups that fit the conditions:<br> A B A &gt; B A &lt; B V V V V RIVER~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~RIVER “VV” “&gt;V” “V&lt;”<br>If we now consider three cities, we can determine 8 possible set-ups.<br>Your task is to produce a program that given the number of cities NC (or treatment plants) in the river bank, determines the number of possible set-ups, NS, that can be made according to the rules define above.<br>You need to be careful with your design as the number of cities can be as large as 100.</p>
<p>Input</p>
<p>The input consists of a sequence of values, one per line, where each value represents the number of cities.</p>
<p>Output</p>
<p>Your output should be a sequence of values, one per line, where each value represents the number of possible set-ups for the corresponding number of cities read in the same input line.</p>
<p>Sample Input</p>
<p>2 3 20</p>
<p>Sample Output</p>
<p>3 8 102334155</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1692 Crossed Matchings(DP)</title>
    <url>/posts/oj/dp/POJ%201692%20Crossed%20Matchings(DP)/</url>
    <content><![CDATA[<p>题意 有两行数a[n1] b[n2] 分别有n1 n2个数 当第一行一个数和第二行一个数相等时 他们就可以连起来 每个数只能连一个 求最有多少条线使得每条都至少有一条和它相交</p>
<p>令d[i][j]表示 a的前i个数和j的前j个数最多可以连接多少条</p>
<p>当a[i]&#x3D;&#x3D;b[j]时 将们连起来是肯定不与其它线相交的 所以d[i][j]&#x3D;max(d[i-1][j],d[i][j-1])</p>
<p>当a[i]!&#x3D;b[j]时 如果可以在第一行找一个数x&lt;i 第二行找一个数y&lt;j 使得a[x]&#x3D;&#x3D;b[j] b[y]&#x3D;&#x3D;a[i] 那么有d[i][j]&#x3D;max(d[x][y]+2,d[i-1][j],d[i][j-1]) 如果找不到d[i][j]&#x3D;max(d[i-1][j],d[i][j-1])</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">105</span>;</span><br><span class="line">int a[N], b[N], d[N][N], la, lb, cas;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    scanf (<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span> (cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;la, &amp;lb);</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= la; ++i)</span><br><span class="line">            scanf (<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= lb; ++j)</span><br><span class="line">            scanf (<span class="string">&quot;%d&quot;</span>, &amp;b[j]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= la; ++i)</span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= lb; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                d[i][j] = max (d[i][j - <span class="number">1</span>], d[i - <span class="number">1</span>][j]);</span><br><span class="line">                int x, y;</span><br><span class="line">                <span class="keyword">for</span> (x = i - <span class="number">1</span>; x &gt;= <span class="number">1</span>; --x)</span><br><span class="line">                    <span class="keyword">if</span> (a[x] == b[j]) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">for</span> (y = j - <span class="number">1</span>; y &gt;= <span class="number">1</span>; --y)</span><br><span class="line">                    <span class="keyword">if</span> (a[i] == b[y]) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (x &amp;&amp; y &amp;&amp; a[i] != b[j])</span><br><span class="line">                    d[i][j] = max (d[x - <span class="number">1</span>][y - <span class="number">1</span>] + <span class="number">2</span>, d[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        printf (<span class="string">&quot;%d\n&quot;</span>, d[la][lb]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Crossed Matchings</p>
<p>Description<br>There are two rows of positive integer numbers. We can draw one line segment between any two equal numbers, with values r, if one of them is located in the first row and the other one is located in the second row. We call this line segment an r-matching segment. The following figure shows a 3-matching and a 2-matching segment.<br>  <img src="/../images/es-1692_1.jpg.png">  We want to find the maximum number of matching segments possible to draw for the given input, such that:</p>
<ol>
<li>Each a-matching segment should cross exactly one b-matching segment, where a !&#x3D; b .</li>
<li>No two matching segments can be drawn from a number. For example, the following matchings are not allowed.  <img src="/../images/es-1692_2.jpg.png">  Write a program to compute the maximum number of matching segments for the input data. Note that this number is always even.</li>
</ol>
<p>Input</p>
<p>The first line of the input is the number M, which is the number of test cases (1 &lt;&#x3D; M &lt;&#x3D; 10). Each test case has three lines. The first line contains N1 and N2, the number of integers on the first and the second row respectively. The next line contains N1 integers which are the numbers on the first row. The third line contains N2 integers which are the numbers on the second row. All numbers are positive integers less than 100.</p>
<p>Output</p>
<p>Output should have one separate line for each test case. The maximum number of matching segments for each test case should be written in one separate line.</p>
<p>Sample Input</p>
<p>3 6 6 1 3 1 3 1 3 3 1 3 1 3 1 4 4 1 1 3 3 1 1 3 3 12 11 1 2 3 3 2 4 1 5 1 3 5 10 3 1 2 3 2 4 12 1 5 5 3</p>
<p>Sample Output</p>
<p>6 0 8</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3036 Honeycomb Walk(DP)</title>
    <url>/posts/oj/dp/POJ%203036%20Honeycomb%20Walk(DP)/</url>
    <content><![CDATA[<p>题意 求蜜蜂在蜂巢跑行n个格子回到原点的方法数</p>
<p>把每个格子抽象成一个点 最多走14步 把初始位置O的坐标设为(15,15) 保围着O的6个点如下图所示 他们到O的距离都是1</p>
<p><img src="/../images/null"></p>
<p>每个点周围都有这样的6个点 代表相邻的格子 这6个点到中间点的距离为1 令d[k][i][j]表示 从O点走k步到达(i,j)点的方法总数 那么很容易有转移方程 d[k][i][j]&#x3D;d[k-1][i-1][j-1]+d[k-1][i][j-1]+d[k-1][i+1][j]+d[k-1][i+1][j+1]+d[k-1][i][j+1]+d[k-1][i-1][j] 边界条件为d[0][15][15]&#x3D;0</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int L = <span class="number">15</span>, X = <span class="number">30</span>, Y = <span class="number">30</span>;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int d[L][X][Y]=&#123;<span class="number">0</span>&#125;, n, t;</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">15</span>][<span class="number">15</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (int k = <span class="number">1</span>; k &lt; L; ++k)</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt; X; ++i)</span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt; Y; ++j)</span><br><span class="line">                d[k][i][j] = d[k - <span class="number">1</span>][i - <span class="number">1</span>][j - <span class="number">1</span>] + d[k - <span class="number">1</span>][i][j - <span class="number">1</span>] + d[k - <span class="number">1</span>][i + <span class="number">1</span>][j] +</span><br><span class="line">                             d[k - <span class="number">1</span>][i + <span class="number">1</span>][j + <span class="number">1</span>] + d[k - <span class="number">1</span>][i][j + <span class="number">1</span>] + d[k - <span class="number">1</span>][i - <span class="number">1</span>][j];</span><br><span class="line">    scanf (<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        printf (<span class="string">&quot;%d\n&quot;</span>, d[n][<span class="number">15</span>][<span class="number">15</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Honeycomb Walk</p>
<p>Description</p>
<p><img src="/../images/es-3036_1.jpg.png"></p>
<p>A bee larva living in a hexagonal cell of a large honeycomb decides to creep for a walk. In each “step” the larva may move into any of the six adjacent cells and after<em>n</em>steps, it is to end up in its original cell.</p>
<p>Your program has to compute, for a given<em>n</em>, the number of different such larva walks.</p>
<p>Input</p>
<p>The first line contains an integer giving the number of test cases to follow. Each case consists of one line containing an integer<em>n</em>, where 1 ≤<em>n</em>≤ 14.</p>
<p>Output</p>
<p>For each test case, output one line containing the number of walks. Under the assumption 1 ≤<em>n</em>≤ 14, the answer will be less than 231.</p>
<p>Sample Input</p>
<p>2 2 4</p>
<p>Sample Output</p>
<p>6 90</p>
<p>﻿﻿</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3356 AGTC（最长公共子序列）</title>
    <url>/posts/oj/dp/POJ%203356%20AGTC%EF%BC%88%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%89/</url>
    <content><![CDATA[<p>AGTC</p>
<p>Description<br>Let <em>x</em> and <em>y</em> be two strings over some finite alphabet <em>A</em>. We would like to transform <em>x</em> into <em>y</em> allowing only operations given below:</p>
<p>Certainly, we would like to minimize the number of all possible operations.<br><strong>Illustration</strong></p>
<p>A G T A A G T &#x2F;* A G G C | | | | | | | A G T &#x2F;* C &#x2F;* T G A C G C</p>
<p><strong>Deletion:</strong> &#x2F;* in the bottom line<br><strong>Insertion:</strong> &#x2F;* in the top line<br><strong>Change:</strong> when the letters at the top and bottom are distinct</p>
<p>This tells us that to transform <em>x</em> &#x3D; AGTCTGACGC into <em>y</em> &#x3D; AGTAAGTAGGC we would be required to perform 5 operations (2 changes, 2 deletions and 1 insertion). If we want to minimize the number operations, we should do it like</p>
<p>A G T A A G T A G G C | | | | | | | A G T C T G &#x2F;* A C G C</p>
<p>and 4 moves would be required (3 changes and 1 deletion).</p>
<p>In this problem we would always consider strings <em>x</em> and <em>y</em> to be fixed, such that the number of letters in <em>x</em> is <em>m</em> and the number of letters in <em>y</em> is <em>n</em> where <em>n</em> ≥ <em>m</em>.</p>
<p>Assign 1 as the cost of an operation performed. Otherwise, assign 0 if there is no operation performed.</p>
<p>Write a program that would minimize the number of possible operations to transform any string <em>x</em> into a string <em>y</em>.</p>
<p>Input</p>
<p>The input consists of the strings <em>x</em> and <em>y</em> prefixed by their respective lengths, which are within 1000.</p>
<p>Output</p>
<p>An integer representing the minimum number of possible operations to transform any string <em>x</em> into a string <em>y</em>.</p>
<p>Sample Input</p>
<p>10 AGTCTGACGC 11 AGTAAGTAGGC</p>
<p>Sample Output</p>
<p>4</p>
<p>题意 给你两个DNA序列 求第一个第一个序列至少经过多次删除 、替换 或添加碱基得到第二个序列 其实分析一下可以发现 只要求出两个序列的最长公共子序列 这部分就可以不动了 然后较长序列的长度减去最长公共子序列的长度就是答案了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1005</span>;</span><br><span class="line">int la, lb, d[N][N];</span><br><span class="line">char a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lcs</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    memset (d, <span class="number">0</span>, sizeof (d));</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= la; ++i)</span><br><span class="line">        <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= lb; ++j)</span><br><span class="line">            <span class="keyword">if</span> (a[i] == b[j]) d[i][j] = d[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = max (d[i - <span class="number">1</span>][j], d[i][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (~scanf (<span class="string">&quot;%d%s%d%s&quot;</span>, &amp;la, a + <span class="number">1</span>, &amp;lb, b + <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">lcs</span>();</span><br><span class="line">        printf (<span class="string">&quot;%d\n&quot;</span>, max (la, lb) - d[la][lb]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3390 Print Words in Lines(DP)</title>
    <url>/posts/oj/dp/POJ%203390%20Print%20Words%20in%20Lines(DP)/</url>
    <content><![CDATA[<p>Print Words in Lines</p>
<p><strong>Time Limit:</strong> 1000MS  <strong>Memory Limit:</strong> 65536K <strong>Total Submissions:</strong> 1624  <strong>Accepted:</strong> 864</p>
<p>Description<br>We have a paragraph of text to print. A text is a sequence of words and each word consists of characters. When we print a text, we print the words from the text one at a time, according to the order the words appear in the text. The words are printed in lines, and we can print at most <em>M</em> characters in a line. If there is space available, we could print more than one word in a line. However, when we print more than one word in a line, we need to place exactly one space character between two adjacent words in a line. For example, when we are given a text like the following:<br>This is a text of fourteen words and the longest word has ten characters</p>
<p>Now we can print this text into lines of no more than 20 characters as the following.</p>
<p>This is<br>a text of<br>fourteen words<br>and the longest<br>word<br>has ten characters</p>
<p>However, when you print less than 20 characters in a line, you need to pay a penalty, which is equal to the square of the difference between 20 and the actual number of characters you printed in that line. For example in the first line we actually printed seven characters so the penalty is (20 − 7)2 &#x3D; 169. The total penalty is the sum of all penalties from all lines. Given the text and the number of maximum number of characters allowed in a line, compute the minimum penalty to print the text.</p>
<p>Input</p>
<p>The first line of the input is the number of test cases (<em>C</em>). The first line of a test case is the maximum number of characters allowed in a line (<em>M</em>). The second line of a test case is the number of words in the text (<em>N</em>). The following <em>N</em> lines are the length (in character) of each word in the text. It is guaranteed that no word will have more than <em>M</em> characters, <em>N</em> is at most 10000, and <em>M</em> is at most 100.</p>
<p>Output</p>
<p>The output has <em>C</em> lines. Each line has the minimum penalty one needs to pay in order to print the text in that test case.</p>
<p>Sample Input</p>
<p>2 20 14 4 2 1 4 2 8 5 3 3 7 4 3 3 10 30 14 4 2 1 4 2 8 5 3 3 7 4 3 3 10</p>
<p>Sample Output</p>
<p>33 146</p>
<p>Source</p>
<p><a href="http://poj.org/searchproblem?field=source&key=Kaohsiung+2006">Kaohsiung 2006</a></p>
<p>题意 把n个单词排版 每行最多m个字符 不同单词间有空格 每行最后一个单词后没空格 空格占一个字符 当一行的字符数与m的差为t时 就会扣t&#x2F;*t分 求最少扣分</p>
<p>令a[i]表示第i个单词的长度 s[i]表示从第一个单词到第i个单词单词长度和d[i]表示前i个单词排版后最少扣的分</p>
<p>则t&#x3D;m-(s[i] - s[j] + i - j - 1)表示把从第j+1个单词到第i个单词放在一行时这行的字符长度与m的差</p>
<p>那么当t&gt;&#x3D;0时 有转移方程 d[i]&#x3D;min(d[i],d[j]+t&#x2F;*t) ;</p>
<p>有了方程程序就好写了:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">10005</span>;</span><br><span class="line">int s[N], d[N], a[N], t, cas, m, n;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    scanf (<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span> (cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf (<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">            s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        memset (d, <span class="number">0x3f</span>, sizeof (d)); d[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (int j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">            &#123;</span><br><span class="line">                t = m - (s[i] - s[j] + i - j - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (t &gt;= <span class="number">0</span>)  d[i] = min (d[i], d[j] + t * t);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        printf (<span class="string">&quot;%d\n&quot;</span>, d[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3934 Queue(DP)</title>
    <url>/posts/oj/dp/POJ%203934%20Queue(DP)/</url>
    <content><![CDATA[<p>Queue</p>
<p>Description<br>Linda is a teacher in ACM kindergarten. She is in charge of n kids. Because the dinning hall is a little bit far away from the classroom, those n kids have to walk in line to the dinning hall every day. When they are walking in line, if and only if two kids can see each other, they will talk to each other. Two kids can see each other if and only if all kids between them are shorter then both of them, or there are no kids between them. Kids do not only look forward, they may look back and talk to kids behind them. Linda don’t want them to talk too much (for it’s not safe), but she also don’t want them to be too quiet(for it’s boring), so Linda decides that she must form a line in which there are exactly m pairs of kids who can see each other. Linda wants to know, in how many different ways can she form such a line. Can you help her?<br>Note: All kids are different in height.</p>
<p>Input</p>
<p>Input consists of multiple test cases. Each test case is one line containing two integers. The first integer is n, and the second one is m. (0 &lt; n &lt;&#x3D; 80, 0 &lt;&#x3D; m &lt;&#x3D; 10000).<br>Input ends by a line containing two zeros.</p>
<p>Output</p>
<p>For each test case, output one line containing the reminder of the number of ways divided by 9937.</p>
<p>Sample Input</p>
<p>1 0 2 0 3 2 0 0</p>
<p>Sample Output</p>
<p>1 0 4</p>
<p>题意 linda在一个幼儿园当老师 他要把n个学生排成一列 使只有m对学生能够讲话 当两个学生相邻或者他们之间的所有人都比他们矮时 他们就能够讲话</p>
<p>每个学生的身高都不同</p>
<p>令d[i][j]表示把i个学生排成一列使j对学生能够讲话的方法数</p>
<p>可以把i个学生分成i-1个学生和一个最矮的学生 把这个学生放在i-1个学生中任意两个学生之间都不会影响原来的结果 但是能讲话的学生对数增加了2 有i-2种放法</p>
<p>或者把这个最矮的学生放在两边 这样能讲话的对数只增加了1 有两种放法</p>
<p>所以有转移方程d[i][j]&#x3D;d[i-1][j-2]&#x2F;*i-2+d[i-1][j-1]&#x2F;*2(j&gt;&#x3D;2)</p>
<p>j&lt;2时只有d[1][0]&#x3D;1（学生数大于1就有相邻的就能讲话了） 和d[2][1]&#x3D;2(学生数大于2肯定不止一对能讲话了)两个有值 可以作为初始条件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">81</span>, M = <span class="number">10001</span>;</span><br><span class="line">int d[N][M], n, m;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    d[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>, d[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">        <span class="keyword">for</span> (int j = <span class="number">2</span>; j &lt; M; ++j)</span><br><span class="line">            d[i][j] = (d[i - <span class="number">1</span>][j - <span class="number">2</span>] * (i - <span class="number">2</span>) + <span class="number">2</span> * d[i - <span class="number">1</span>][j - <span class="number">1</span>]) % <span class="number">9937</span>;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">while</span> (scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m), n)</span><br><span class="line">        printf (<span class="string">&quot;%d\n&quot;</span>, d[n][m]);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ1505&amp;&amp;UVa714 Copying Books(DP)</title>
    <url>/posts/oj/dp/POJ1505&amp;&amp;UVa714%20Copying%20Books(DP)/</url>
    <content><![CDATA[<p>Copying Books</p>
<p><strong>Time Limit:</strong> 3000MS  <strong>Memory Limit:</strong> 10000K <strong>Total Submissions:</strong> 7109  <strong>Accepted:</strong> 2221</p>
<p>Description<br>Before the invention of book-printing, it was very hard to make a copy of a book. All the contents had to be re-written by hand by so called scribers. The scriber had been given a book and after several months he finished its copy. One of the most famous scribers lived in the 15th century and his name was Xaverius Endricus Remius Ontius Xendrianus (Xerox). Anyway, the work was very annoying and boring. And the only way to speed it up was to hire more scribers.<br>Once upon a time, there was a theater ensemble that wanted to play famous Antique Tragedies. The scripts of these plays were divided into many books and actors needed more copies of them, of course. So they hired many scribers to make copies of these books. Imagine you have m books (numbered 1, 2 … m) that may have different number of pages (p1, p2 … pm) and you want to make one copy of each of them. Your task is to divide these books among k scribes, k &lt;&#x3D; m. Each book can be assigned to a single scriber only, and every scriber must get a continuous sequence of books. That means, there exists an increasing succession of numbers 0 &#x3D; b0 &lt; b1 &lt; b2, … &lt; bk-1 &lt;&#x3D; bk &#x3D; m such that i-th scriber gets a sequence of books with numbers between bi-1+1 and bi. The time needed to make a copy of all the books is determined by the scriber who was assigned the most work. Therefore, our goal is to minimize the maximum number of pages assigned to a single scriber. Your task is to find the optimal assignment.</p>
<p>Input</p>
<p>The input consists of N cases. The first line of the input contains only positive integer N. Then follow the cases. Each case consists of exactly two lines. At the first line, there are two integers m and k, 1 &lt;&#x3D; k &lt;&#x3D; m &lt;&#x3D; 500. At the second line, there are integers p1, p2, … pm separated by spaces. All these values are positive and less than 10000000.</p>
<p>Output</p>
<p>For each case, print exactly one line. The line must contain the input succession p1, p2, … pm divided into exactly k parts such that the maximum sum of a single part should be as small as possible. Use the slash character (‘&#x2F;‘) to separate the parts. There must be exactly one space character between any two successive numbers and between the number and the slash.<br>If there is more than one solution, print the one that minimizes the work assigned to the first scriber, then to the second scriber etc. But each scriber must be assigned at least one book.</p>
<p>Sample Input</p>
<p>2 9 3 100 200 300 400 500 600 700 800 900 5 4 100 100 100 100 100</p>
<p>Sample Output</p>
<p>100 200 300 400 500 &#x2F; 600 700 &#x2F; 800 900 100 &#x2F; 100 &#x2F; 100 &#x2F; 100 100</p>
<p>Source</p>
<p><a href="http://poj.org/searchproblem?field=source&key=Central+Europe+1998">Central Europe 1998</a></p>
<p>题意 k个人复制m本书 求最小的时间 即把m个数分成k份 使和最大的那份最小</p>
<p>d[i][j]表示i个人完成前j本书需要的时间 有转移方程d[i][j]&#x3D;min(d[i][j],max(d[i-1][k],s[j]-s[k])) k表示i-1到j之间的所有数 s[k]表示从第一本书到第k本书需要时间的和 初始d[1][i]&#x3D;s[i];</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">550</span>, <span class="variable constant_">INF</span> = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">int a[N], flag[N], s[N],  d[N][N], t, cas, n, m, ans;</span><br><span class="line">int dp (int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (d[i][j] &gt; <span class="number">0</span>) <span class="keyword">return</span> d[i][j];</span><br><span class="line">    d[i][j] = <span class="variable constant_">INF</span>;</span><br><span class="line">    <span class="keyword">for</span> (int k = i - <span class="number">1</span>; k &lt; j; ++k)</span><br><span class="line">        d[i][j] = min (d[i][j], max (dp (i - <span class="number">1</span>, k), s[j] - s[k]));</span><br><span class="line">    <span class="keyword">return</span> d[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    scanf (<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span> (cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        memset (d, -<span class="number">1</span>, sizeof (d));  memset (flag, -<span class="number">1</span>, sizeof (flag));</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123; scanf (<span class="string">&quot;%d&quot;</span>, &amp;a[i]); d[<span class="number">1</span>][i] = s[i] = s[i - <span class="number">1</span>] + a[i]; &#125;</span><br><span class="line">        ans = dp (m, n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = n,t=<span class="number">0</span> ; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">            <span class="keyword">if</span> ( ( (t = t + a[i]) &gt; ans) || m &gt; i)</span><br><span class="line">                &#123;  t = a[i]; flag[i] = <span class="number">0</span>; --m; &#125;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            printf (flag[i] ? <span class="string">&quot;%d&quot;</span> : <span class="string">&quot;%d /&quot;</span>, a[i]);</span><br><span class="line">            printf (i == n ? <span class="string">&quot;\n&quot;</span> : <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UESTC 890 Card Trick(DP 纸牌魔术)</title>
    <url>/posts/oj/dp/UESTC%20890%20Card%20Trick(DP%20%E7%BA%B8%E7%89%8C%E9%AD%94%E6%9C%AF)/</url>
    <content><![CDATA[<p>题意 给你一些牌 全部正面朝下放桌子上 你选一个起点 翻开那张牌 牌上的数字是几就向前走几步 J,Q,K 都是向前走10步 A向前走11步 知道向前走对应的步数后超过了终点 输入n m 和n个数 代表你以第m张牌为起点 依次掀开了n张牌就不能再掀了 然后同样的牌 Alice以1-10张牌中的任意一个为起点 求Alice最后的终点与你的终点相同的概率</p>
<p>c[i]表示第i张牌的面值 没被掀开的牌的面值都是未知的c[i]&#x3D;0 可能为2-A中的任意一个 令d[i]表示从你的终点到达第i张牌的概率 那么所有掀开过的牌的概率都为1 然后从终点向前递推 当p[i]&#x3D;0时 p[i]&#x3D;sum{p[i+j]} j为2-A中任意一张牌 注意10,j,q,k的时候都是10 最后的答案就是1到10的结果加起来除以10了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1500</span>;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    char s[<span class="number">3</span>];</span><br><span class="line">    int n, m, l;</span><br><span class="line">    double p[N], ans;</span><br><span class="line">    <span class="keyword">while</span> (~scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        memset (p, <span class="number">0</span>, sizeof (p));</span><br><span class="line">        l = m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf (<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">            p[l] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[<span class="number">0</span>]&lt;<span class="string">&#x27;A&#x27;</span> &amp;&amp; s[<span class="number">1</span>]!=<span class="string">&#x27;0&#x27;</span>)  l += s[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span>)  l += <span class="number">11</span>;</span><br><span class="line">            <span class="keyword">else</span> l+= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (int i = l ; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (int j = <span class="number">2</span>; j &lt;= <span class="number">11</span>; ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    int t = (j == <span class="number">10</span> ? <span class="number">4</span> : <span class="number">1</span>);</span><br><span class="line">                    p[i] += t * p[i + j];</span><br><span class="line">                &#125;</span><br><span class="line">                p[i] /= <span class="number">13</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= <span class="number">10</span>) ans += p[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf (<span class="string">&quot;%.8f\n&quot;</span>, ans / <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Card-Trick"><a href="#Card-Trick" class="headerlink" title="Card Trick"></a>Card Trick</h1><h5 id="Time-Limit-2999-x2F-999MS-Java-x2F-Others-Memory-Limit-65432-x2F-65432KB-Java-x2F-Others"><a href="#Time-Limit-2999-x2F-999MS-Java-x2F-Others-Memory-Limit-65432-x2F-65432KB-Java-x2F-Others" class="headerlink" title="Time Limit: 2999&#x2F;999MS (Java&#x2F;Others) Memory Limit: 65432&#x2F;65432KB (Java&#x2F;Others)"></a>Time Limit: 2999&#x2F;999MS (Java&#x2F;Others) Memory Limit: 65432&#x2F;65432KB (Java&#x2F;Others)</h5><p>Submit   Status<br>I am learning magic tricks to impress my girlfriend Alice. My latest trick is a probabilistic one, i.e. it does work in most cases, but not in every case. To perform the trick, I first shuffle a set of many playing cards and put them all in one line with faces up on the table. Then Alice secretly selects one of the first ten cards (i.e. she choosesx0, a secret number between1and10inclusive) and skips cards repeatedly as follows: after having selected a card at positionxiwith a numberc(xi)on its face, she will select the card at positionxi+1&#x3D;xi+c(xi). Jack (</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">J</span><br></pre></td></tr></table></figure>
<p>), Queen (</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Q</span><br></pre></td></tr></table></figure>
<p>), and King (</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">K</span><br></pre></td></tr></table></figure>
<p>) count as10, Ace (</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">A</span><br></pre></td></tr></table></figure>
<p>) counts as11. You may assume that there are at least ten cards on the table.</p>
<p>Alice stops this procedure as soon as there is no card at positionxi+c(xi). I then perform the same procedure from a randomly selected starting position that may be different from the position selected by Alice. It turns out that often, I end up at the same position. Alice is very impressed by this trick.</p>
<p>However, I am more interested in the underlying math. Given my randomly selected starting position and the card faces of every selected card (including my final one), can you compute the probability that Alice chose a starting position ending up on the same final card? You may assume that her starting position is randomly chosen with uniform probability (between1and10inclusive). I forgot to note the cards that I skipped, so these cards are unknown. You may assume that the card face of every single of the unknown cards is independent of the other card faces and random with uniform probability out of the possible card faces (i.e.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<ul>
<li></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>,</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">J</span><br></pre></td></tr></table></figure>
<p>,</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Q</span><br></pre></td></tr></table></figure>
<p>,</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">K</span><br></pre></td></tr></table></figure>
<p>, and</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">A</span><br></pre></td></tr></table></figure>
<p>).</p>
<p><img src="/../images/u.cn-images-problem-890-2014052312220872010-.png" alt="title"></p>
<p>*Illustration of first sample input: my starting position is2, so I start selecting that card. Then I keep skipping cards depending on the card’s face. This process iterates until there are not enough cards to skip (in this sample:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Q</span><br></pre></td></tr></table></figure>
<p>). The final</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Q</span><br></pre></td></tr></table></figure>
<p>card is followed by0to9unknown cards, since</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Q</span><br></pre></td></tr></table></figure>
<p>counts as10.*</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>For each test case:</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each test case, print one line containing the probability that Alice chooses a starting position that leads to the same final card. Your output should have an absolute error of at most10−7.</p>
<h2 id="Sample-input-and-output"><a href="#Sample-input-and-output" class="headerlink" title="Sample input and output"></a>Sample input and output</h2><p>Sample Input Sample Output 5 2 2 3 5 3 Q 1 1 A 1 2 A 1 10 A 6 1 2 2 2 2 2 2 7 1 2 2 2 2 2 2 2 3 10 10 J K 0.4871377757023325348071573 0.1000000000000000000000000 0.1000000000000000000000000 0.1748923357025314239697490 0.5830713210321767445117468 0.6279229611115749556280350 0.3346565827603272001891974</p>
<p>﻿﻿</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA 10131 Is Bigger Smarter? （DP,最长条件子序列）</title>
    <url>/posts/oj/dp/UVA%2010131%20Is%20Bigger%20Smarter%EF%BC%88DP,%E6%9C%80%E9%95%BF%E6%9D%A1%E4%BB%B6%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%89/</url>
    <content><![CDATA[<p>题意 找出一个最长的序列，满足大象的体重增加时 智商是减小的<br>也是基础的DP d[i]表示以第i个大象为起点的最长序列 当满足(w[i]&gt;w[j])&amp;&amp;(s[i]&lt;s[j]时 d[i]&#x3D;max(d[i],dp(j)+1)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define M <span class="number">1005</span></span><br><span class="line">using namespace std;</span><br><span class="line">int w[M],s[M],d[M],pre[M],n,l;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">dp</span>(<span class="params">int i</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[i]&gt;<span class="number">0</span>) <span class="keyword">return</span> d[i];</span><br><span class="line">    d[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(int j=<span class="number">1</span>; j&lt;=n; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((w[i]&gt;w[j])&amp;&amp;(s[i]&lt;s[j]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i]&lt;<span class="title function_">dp</span>(j)+<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                d[i]=d[j]+<span class="number">1</span>;</span><br><span class="line">                pre[i]=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span>(<span class="params">int i</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">print</span>(pre[i]);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    n=<span class="number">0</span>;l=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="title function_">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;w[n],&amp;s[++n])!=<span class="variable constant_">EOF</span>);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_">dp</span>(i)&gt;<span class="title function_">dp</span>(l)) l=i;</span><br><span class="line">    <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>,d[l]);</span><br><span class="line">    <span class="title function_">print</span>(l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Is-Bigger-Smarter"><a href="#Is-Bigger-Smarter" class="headerlink" title="Is Bigger Smarter?"></a>Is Bigger Smarter?</h1><h2 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h2><p>Some people think that the bigger an elephant is, the smarter it is. To disprove this, you want to take the data on a collection of elephants and put as large a subset of this data as possible into a sequence so that the weights are increasing, but the IQ’s are decreasing.</p>
<p>The input will consist of data for a bunch of elephants, one elephant per line, terminated by the end-of-file. The data for a particular elephant will consist of a pair of integers: the first representing its size in kilograms and the second representing its IQ in hundredths of IQ points. Both integers are between 1 and 10000. The data will contain information for at most 1000 elephants. Two elephants may have the same weight, the same IQ, or even the same weight and IQ.</p>
<p>Say that the numbers on the i-th data line are W[i] and S[i]. Your program should output a sequence of lines of data; the first line should contain a number n; the remaining n lines should each contain a single positive integer (each one representing an elephant). If these nintegers are a[1], a[2],…, a[n] then it must be the case that<br>W[a[1]] &lt; W[a[2]] &lt; … &lt; W[a[n]]</p>
<p>and</p>
<p>S[a[1]] &gt; S[a[2]] &gt; … &gt; S[a[n]]</p>
<p>In order for the answer to be correct,nshould be as large as possible. All inequalities are strict: weights must be strictly increasing, and IQs must be strictly decreasing. There may be many correct outputs for a given input, your program only needs to find one.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>6008 1300 6000 2100 500 2000 1000 4000 1100 3000 6000 2000 8000 1400 6000 1200 2000 1900</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>4 4 5 9 7</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 10003 Cutting Sticks(DP 最优木棍切割)</title>
    <url>/posts/oj/dp/UVa%2010003%20Cutting%20Sticks(DP%20%E6%9C%80%E4%BC%98%E6%9C%A8%E6%A3%8D%E5%88%87%E5%89%B2)/</url>
    <content><![CDATA[<p>题意 要把一根长为l的木棍切成n+1段 切割的位置分别为c[1],c[2],…,c[n] 每次切割的成本为当前切割的那一段的长度 如长度100的切成两段成本为100 求完成切割的最小成本</p>
<p>和最优矩阵链乘那题很像 不用打印路径更简单了 在木棍上加两个点c[0]&#x3D;0 c[n+1]&#x3D;l d[i][j]表示把这段木棍的第i到j个点完成切割的最小成本 如果j&#x3D;i+1 不需要切割 成本为0 这是边界条件 j&gt;i+1时 可以在i和j间取一点k 那么有d[i][j]&#x3D;min{d[i][k]+d[k][j]+c[j]-c[i]} 即在k处切断 这个切割的成本为c[j]-c[i]</p>
<p>所以有转移方程d[i][j]&#x3D;min{d[i][k]+d[k][j]+c[j]-c[i]} i&lt;k&lt;j</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">55</span>, <span class="variable constant_">INF</span> = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">int d[N][N], c[N];</span><br><span class="line"></span><br><span class="line">int dp (int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (d[i][j] &lt; <span class="variable constant_">INF</span>)  <span class="keyword">return</span> d[i][j];</span><br><span class="line">    <span class="keyword">for</span> (int k = i+<span class="number">1</span>; k &lt; j; ++k)</span><br><span class="line">        d[i][j] = min (d[i][j], dp (i, k) + dp (k , j) + c[j] - c[i]);</span><br><span class="line">    <span class="keyword">return</span> d[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int l, n;</span><br><span class="line">    <span class="keyword">while</span> (scanf (<span class="string">&quot;%d&quot;</span>, &amp;l), l)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            scanf (<span class="string">&quot;%d&quot;</span>, &amp;c[i]);</span><br><span class="line">        c[++n] = l;</span><br><span class="line">        memset (d, <span class="number">0x3f</span>, sizeof (d));</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt;= n-<span class="number">1</span>; ++i) d[i][i+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        printf (<span class="string">&quot;The minimum cutting is %d.\n&quot;</span>, dp (<span class="number">0</span>, n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p>You have to cut a wood stick into pieces. The most affordable company, The Analog Cutting Machinery, Inc. (ACM), charges money according to the length of the stick being cut. Their procedure of work requires that they only make one cut at a time.</p>
<p>It is easy to notice that different selections in the order of cutting can led to different prices. For example, consider a stick of length 10 meters that has to be cut at 2, 4 and 7 meters from one end. There are several choices. One can be cutting first at 2, then at 4, then at 7. This leads to a price of 10 + 8 + 6 &#x3D; 24 because the first stick was of 10 meters, the resulting of 8 and the last one of 6. Another choice could be cutting at 4, then at 2, then at 7. This would lead to a price of 10 + 4 + 6 &#x3D; 20, which is a better price.</p>
<p>Your boss trusts your computer abilities to find out the minimum cost for cutting a given stick.</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>The input will consist of several input cases. The first line of each test case will contain a positive number<em>l</em>that represents the length of the stick to be cut. You can assume<em>l</em>&lt; 1000. The next line will contain the number<em>n</em>(<em>n</em>&lt; 50) of cuts to be made.</p>
<p>The next line consists of<em>n</em>positive numbers<em>c**i</em>(0 &lt;<em>c**i</em>&lt;<em>l</em>) representing the places where the cuts have to be done, given in strictly increasing order.</p>
<p>An input case with<em>l</em>&#x3D; 0 will represent the end of the input.</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>You have to print the cost of the optimal solution of the cutting problem, that is the minimum cost of cutting the given stick. Format the output as shown below.</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>100 3 25 50 75 10 4 4 5 7 8 0</p>
<h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><p>The minimum cutting is 200. The minimum cutting is 22.</p>
<p>﻿﻿</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 10051 Tower of Cubes(DP 最长立体堆叠)</title>
    <url>/posts/oj/dp/UVa%2010051%20Tower%20of%20Cubes(DP%20%E6%9C%80%E9%95%BF%E7%AB%8B%E4%BD%93%E5%A0%86%E5%8F%A0)/</url>
    <content><![CDATA[<p>﻿﻿</p>
<p>题意 给你n个立方体 立方体每面都涂有颜色 当一个立方体序号小于另一个立方体且这个立方体底面的颜色等于另一个立方体顶面的颜色 这个立方体就可以放在另一个立方体上面 求这些立方体堆起来的最大高度；</p>
<p>每个立方体有6种放置方式 为了便于控制 个人喜欢将一个立方体分解为6个 这样每个立方体只用考虑顶面和底面d[i]表示分解后以第i个立方体为基底可以达到的最大高度 j从1到i-1枚举 当满足top[i]&#x3D;&#x3D;bot[j]时 d[i]&#x3D;max(d[i],d[j]+1)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">3005</span>;</span><br><span class="line">int buf[<span class="number">6</span>], d[N], pre[N], n, m, ans;</span><br><span class="line">char face[<span class="number">6</span>][<span class="number">8</span>] = &#123;<span class="string">&quot;front&quot;</span>, <span class="string">&quot;back&quot;</span>, <span class="string">&quot;left&quot;</span>, <span class="string">&quot;right&quot;</span>, <span class="string">&quot;top&quot;</span>, <span class="string">&quot;bottom&quot;</span>&#125;;</span><br><span class="line">struct <span class="title class_">Cube</span>&#123;    int wei, bot, top;  &#125; cube[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> print (int i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pre[i])  print (pre[i]);</span><br><span class="line">    printf (<span class="string">&quot;%d %s\n&quot;</span>, cube[i].<span class="property">wei</span>, face[ (i - <span class="number">1</span>) % <span class="number">6</span>]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (scanf (<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = m = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (int k = <span class="number">0</span>; k &lt; <span class="number">6</span>; ++k)</span><br><span class="line">                scanf (<span class="string">&quot;%d&quot;</span>, &amp;buf[k]);</span><br><span class="line">            <span class="keyword">for</span> (int k = <span class="number">0</span>; k &lt; <span class="number">6</span>; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                cube[m].<span class="property">wei</span> = i;</span><br><span class="line">                cube[m].<span class="property">top</span> = buf[k];</span><br><span class="line">                cube[m++].<span class="property">bot</span> = (k % <span class="number">2</span> ? buf[k - <span class="number">1</span>] : buf[k + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memset (d, <span class="number">0</span>, sizeof (d));</span><br><span class="line">        memset (pre, <span class="number">0</span>, sizeof (pre));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = ans = <span class="number">1</span>; i &lt;= <span class="number">6</span> * n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (int j = d[i] = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">                <span class="keyword">if</span> (cube[j].<span class="property">wei</span> &lt; cube[i].<span class="property">wei</span> &amp;&amp; cube[j].<span class="property">bot</span> == cube[i].<span class="property">top</span> &amp;&amp; d[i] &lt; d[j] + <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    d[i] = d[j] + <span class="number">1</span>;</span><br><span class="line">                    pre[i] = j;</span><br><span class="line">                    <span class="keyword">if</span> (d[i] &gt; d[ans])</span><br><span class="line">                        ans = i;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">if</span> (cas) printf (<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        printf (<span class="string">&quot;Case #%d\n%d\n&quot;</span>, ++cas, d[ans]);</span><br><span class="line">        print (ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p>In this problem you are given <em>N</em> colorful cubes each having a distinct weight. Each face of a cube is colored with one color. Your job is to build a tower using the cubes you have subject to the following restrictions:</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>The input may contain multiple test cases. The first line of each test case contains an integer <em>N</em> ( <img src="/../images/dge.org-external-100-10051img2.gif.png" alt="$1 \le N \le 500$">) indicating the number of cubes you are given. The <em>i</em>th ( <img src="/../images/dge.org-external-100-10051img3.gif.png" alt="$1 \le i \le N$">) of the next <em>N</em> lines contains the description of the <em>i</em>th cube. A cube is described by giving the colors of its faces in the following order: front, back, left, right, top and bottom face. For your convenience colors are identified by integers in the range 1 to 100. You may assume that cubes are given in the increasing order of their weights, that is, cube 1 is the lightest and cube <em>N</em> is the heaviest.</p>
<p>The input terminates with a value 0 for <em>N</em>.</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>For each test case in the input first print the test case number on a separate line as shown in the sample output. On the next line print the number of cubes in the tallest tower you have built. From the next line describe the cubes in your tower from top to bottom with one description per line. Each description contains an integer (giving the serial number of this cube in the input) followed by a single whitespace character and then the identification string (front, back, left, right, top or bottom) of the top face of the cube in the tower. Note that there may be multiple solutions and any one of them is acceptable.</p>
<p>Print a blank line between two successive test cases.</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>3 1 2 2 2 1 2 3 3 3 3 3 3 3 2 1 1 1 1 10 1 5 10 3 6 5 2 6 7 3 6 9 5 7 3 2 1 9 1 3 3 5 8 10 6 6 2 2 4 4 1 2 3 4 5 6 10 9 8 7 6 5 6 1 2 3 4 7 1 2 3 3 2 1 3 2 1 1 2 3 0</p>
<h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><p>Case &#x2F;#1 2 2 front 3 front Case &#x2F;#2 8 1 bottom 2 back 3 right 4 left 6 top 8 front 9 front 10 top</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 10066 Twin Towers (DP 最长公共子序列)</title>
    <url>/posts/oj/dp/UVa%2010066%20Twin%20Towers%20(DP%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97)/</url>
    <content><![CDATA[<p>题意 求两串数字最长公共子序列的长度</p>
<p>裸的lcs没啥说的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;  </span><br><span class="line">#include&lt;cstring&gt;  </span><br><span class="line">#include&lt;algorithm&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line"><span class="keyword">const</span> int maxn=<span class="number">105</span>;  </span><br><span class="line">int a[maxn],b[maxn],d[maxn][maxn],na,nb;  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lcs</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="title function_">memset</span>(d,<span class="number">0</span>,<span class="title function_">sizeof</span>(d));  </span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>; i&lt;=na; ++i)  </span><br><span class="line">        <span class="keyword">for</span>(int j=<span class="number">1</span>; j&lt;=nb; ++j)  </span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[j]) d[i][j]=d[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;  </span><br><span class="line">            <span class="keyword">else</span> d[i][j]=<span class="title function_">max</span>(d[i-<span class="number">1</span>][j],d[i][j-<span class="number">1</span>]);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    int k=<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;na,&amp;nb),na||nb)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>; i&lt;=na; ++i)  </span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);  </span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>; i&lt;=nb; ++i)  </span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);  </span><br><span class="line">        <span class="title function_">lcs</span>();  </span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;Twin Towers #%d\nNumber of Tiles : %d\n\n&quot;</span>,k++,d[na][nb]);  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>The Twin Towers</strong></p>
<p><strong>Input:<strong>standard input</strong></strong></p>
<p>**Output:**standard output</p>
<p>Once upon a time, in an ancient Empire, there were two towers of dissimilar shapes in two different cities. The towers were built byputting circular tiles one upon another. Each of the tiles was of the same height and had integral radius. It is no wonder that though the two towers were of dissimilar shape, they had many tiles in common.</p>
<p>However, more than thousand years after they were built, the Emperor ordered his architects to remove some of the tiles from the two towers so that they have exactly the same shape and size, and at the same time remain as high as possible. The order of the tiles in the new towers must remain the same as they were in the original towers. The Emperor thought that, in this way the two towers might be able to stand as the symbol of harmony and equality between the two cities. He decided to name them the<em>Twin Towers</em>.</p>
<p>Now, about two thousand years later, you are challenged with an even simpler problem: given the descriptions of two dissimilar towers you are asked only to find out the number of tiles in the highest twin towers that can be built from them.</p>
<p><strong>Input</strong></p>
<p>The input file consists of several data blocks. Each data block describes a pair of towers.</p>
<p>The first line of a data block contains two integers N1 and N2 (1 &lt;&#x3D; N1, N2 &lt;&#x3D; 100) indicating the number of tiles respectively in the two towers. The next line contains N1 positive integers giving the radii of the tiles (from top to bottom) in the first tower. Then follows another line containing N2 integers giving the radii of the tiles (from top to bottom) in the second tower.</p>
<p>The input file terminates with two zeros for N1 and N2.</p>
<p><strong>Output</strong></p>
<p>For each pair of towers in the input first output the twin tower number followed by the number of tiles (in one tower) in the highest possible twin towers that can be built from them. Print a blank line after the output of each data set.****</p>
<hr>
<p><strong>Sample Input</strong></p>
<p>7 6<br>20 15 10 15 25 20 15<br>15 25 10 20 15 20<br>8 9<br>10 20 20 10 20 10 20 10<br>20 10 20 10 10 20 10 10 20<br>0 0</p>
<p><strong>Sample Output</strong></p>
<p>Twin Towers &#x2F;#1<br>Number of Tiles : 4<br>Twin Towers &#x2F;#2<br>Number of Tiles : 6
﻿﻿</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 10069 Distinct Subsequences（大数 DP）</title>
    <url>/posts/oj/dp/UVa%2010069%20Distinct%20Subsequences%EF%BC%88%E5%A4%A7%E6%95%B0%20DP%EF%BC%89/</url>
    <content><![CDATA[<p>﻿﻿</p>
<p>题意 求母串中子串出现的次数（长度不超过1后面100个0 显然要用大数了）<br>令a为子串 b为母串 d[i][j]表示子串前i个字母在母串前j个字母中出现的次数当a[i]&#x3D;&#x3D;b[j]&amp;&amp;d[i-1][j-1]!&#x3D;0时 d[i][j]&#x3D;d[i-1][j-1]+d[i][j-1]<br>(a[i]&#x3D;&#x3D;b[j]时 子串前i个字母在母串前j个字母中出现的次数 等于 子串前i-1个字母在母串前j-1个字母中出现的次数 加上 子串前i个字母在母串前j-1个字母中出现的次数<br>a[i]!&#x3D;b[j]时 子串前i个字母在母串前j个字母中出现的次数 等于 子串前i个字母在母串前j-1个字母中出现的次数)<br>懒得写大数模版就用java交的 ;</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.<span class="property">util</span>.*;</span><br><span class="line"><span class="keyword">import</span> java.<span class="property">math</span>.*;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	public <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span> args[]</span>) &#123;</span><br><span class="line">		<span class="title class_">BigInteger</span> d[][] = <span class="keyword">new</span> <span class="title class_">BigInteger</span>[<span class="number">105</span>][<span class="number">10005</span>];</span><br><span class="line">		<span class="title class_">Scanner</span> <span class="keyword">in</span> = <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="title class_">System</span>.<span class="property">in</span>);</span><br><span class="line">		int t = <span class="keyword">in</span>.<span class="title function_">nextInt</span>();</span><br><span class="line">		<span class="keyword">while</span> ((t--) != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="title class_">String</span> b = <span class="keyword">in</span>.<span class="title function_">next</span>();</span><br><span class="line">			<span class="title class_">String</span> a = <span class="keyword">in</span>.<span class="title function_">next</span>();</span><br><span class="line">			int la = a.<span class="title function_">length</span>();</span><br><span class="line">			int lb = b.<span class="title function_">length</span>();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; la; ++i)</span><br><span class="line">				<span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; lb; ++j)</span><br><span class="line">					d[i][j] = <span class="title class_">BigInteger</span>.<span class="property">ZERO</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (a.<span class="title function_">charAt</span>(<span class="number">0</span>) == b.<span class="title function_">charAt</span>(<span class="number">0</span>))</span><br><span class="line">				d[<span class="number">0</span>][<span class="number">0</span>] = <span class="title class_">BigInteger</span>.<span class="property">ONE</span>;</span><br><span class="line">			<span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt; lb; ++j) &#123;</span><br><span class="line">				<span class="keyword">if</span> (a.<span class="title function_">charAt</span>(<span class="number">0</span>) == b.<span class="title function_">charAt</span>(j))</span><br><span class="line">					d[<span class="number">0</span>][j] = d[<span class="number">0</span>][j - <span class="number">1</span>].<span class="title function_">add</span>(<span class="title class_">BigInteger</span>.<span class="property">ONE</span>);</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					d[<span class="number">0</span>][j] = d[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt; la; ++i)</span><br><span class="line">				<span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt; lb; ++j) &#123;</span><br><span class="line">					<span class="keyword">if</span> (a.<span class="title function_">charAt</span>(i) == b.<span class="title function_">charAt</span>(j)</span><br><span class="line">							&amp;&amp; d[i - <span class="number">1</span>][j - <span class="number">1</span>] != <span class="title class_">BigInteger</span>.<span class="property">ZERO</span>) &#123;</span><br><span class="line">						d[i][j] = d[i][j - <span class="number">1</span>].<span class="title function_">add</span>(d[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">					&#125; <span class="keyword">else</span></span><br><span class="line">						d[i][j] = d[i][j - <span class="number">1</span>];</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			<span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(d[la - <span class="number">1</span>][lb - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">in</span>.<span class="title function_">close</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有没加大数模版的C++代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char b[<span class="number">10005</span>], a[<span class="number">105</span>];</span><br><span class="line">int d[<span class="number">105</span>][<span class="number">10005</span>], la, lb, t;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dp</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">memset</span>(d, <span class="number">0</span>, <span class="title function_">sizeof</span>(d));</span><br><span class="line">    <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= lb; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">1</span>] == b[j]) d[<span class="number">1</span>][j] = d[<span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> d[<span class="number">1</span>][j] = d[<span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">2</span>; i &lt;= la; ++i)</span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= lb; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j] &amp;&amp; d[i - <span class="number">1</span>][j - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                d[i][j] = d[i][j - <span class="number">1</span>] + d[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = d[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, b + <span class="number">1</span>, a + <span class="number">1</span>);</span><br><span class="line">        la = <span class="title function_">strlen</span>(a + <span class="number">1</span>);</span><br><span class="line">        lb = <span class="title function_">strlen</span>(b + <span class="number">1</span>);</span><br><span class="line">        <span class="title function_">dp</span>();</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d[la][lb]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Distinct-Subsequences"><a href="#Distinct-Subsequences" class="headerlink" title="Distinct Subsequences"></a>Distinct Subsequences</h2><p>A subsequence of a given sequence is just the given sequence with some elements (possibly none) left out. Formally, given a sequence <em>*<em>X</em> &#x3D; <em>x</em>1*x</em>2…<em>xm</em>**, another sequence <em>*<em>Z</em> &#x3D; <em>z</em>1*z</em>2…<em>zk</em>** is a subsequence of <em><strong>X</strong></em> if there exists a strictly increasing sequence <strong>&lt;*i*1,*i*2, …, *ik*&gt;</strong> of indices of <em><strong>X</strong></em> such that for all <em>j</em> &#x3D; 1, 2, …, <em>k</em>, we have <em><strong>xij* &#x3D; *zj</strong></em>. For example, <em><strong>Z* &#x3D; *bcdb</strong></em> is a subsequence of <em><strong>X* &#x3D;*abcbdab</strong></em> with corresponding index sequence <strong>&lt; 2, 3, 5, 7 &gt;</strong>.</p>
<p>In this problem your job is to write a program that counts the number of occurrences of <em><strong>Z</strong></em> in <em><strong>X</strong></em> as a subsequence such that each has a distinct index sequence.</p>
<hr>
<p><strong>Input</strong></p>
<p>The first line of the input contains an integer <em><strong>N</strong></em> indicating the number of test cases to follow.</p>
<p>The first line of each test case contains a string <em><strong>X</strong></em>, composed entirely of lowercase alphabetic characters and having length no greater than 10,000. The second line contains another string <em><strong>Z</strong></em> having length no greater than 100 and also composed of only lowercase alphabetic characters. Be assured that neither <em><strong>Z</strong></em> nor any prefix or suffix of <em><strong>Z</strong></em> will have more than 10100 distinct occurrences in <em><strong>X</strong></em> as a subsequence.</p>
<hr>
<p><strong>Output</strong></p>
<p>For each test case in the input output the number of distinct occurrences of <em><strong>Z</strong></em> in <em><strong>X</strong></em> as a subsequence. Output for each input set must be on a separate line.****</p>
<hr>
<p><strong>Sample Input</strong></p>
<p>2<br>babgbag<br>bag<br>rabbbit<br>rabbit</p>
<hr>
<p><strong>Sample Output</strong></p>
<p>5<br>3</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 10130 SuperSale(DP 01背包)</title>
    <url>/posts/oj/dp/UVa%2010130%20SuperSale(DP%2001%E8%83%8C%E5%8C%85)/</url>
    <content><![CDATA[<p>题意 商畅做活动买东西 每个人每个商品只能拿一件 要拿价值尽量高的商品</p>
<p>很简单的01背包题目 求出每个人可以拿的最大值 加起来就是结果了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;  </span><br><span class="line">#include&lt;cstring&gt;  </span><br><span class="line">#include&lt;algorithm&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line">#define maxn <span class="number">1005</span>  </span><br><span class="line">int p[maxn],w[maxn],d[maxn],pe,t,n,g;  </span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);  </span><br><span class="line">    <span class="keyword">while</span> (t--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);  </span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;++i)  </span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;p[i],&amp;w[i]);  </span><br><span class="line">  </span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;g);  </span><br><span class="line">        int ans=<span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span>(int k=<span class="number">1</span>;k&lt;=g;++k)  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="title function_">memset</span>(d,<span class="number">0</span>,<span class="title function_">sizeof</span>(d));  </span><br><span class="line">                <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;pe);  </span><br><span class="line">                <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;++i)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    <span class="keyword">for</span>(int j=pe;j&gt;=w[i];j--)  </span><br><span class="line">                        d[j]=<span class="title function_">max</span>(d[j],d[j-w[i]]+p[i]);  </span><br><span class="line">                &#125;  </span><br><span class="line">                ans+=d[pe];  </span><br><span class="line">            &#125;  </span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SuperSale"><a href="#SuperSale" class="headerlink" title="SuperSale"></a>SuperSale</h2><p>There is a SuperSale in a SuperHiperMarket. Every person can take only one object of each kind, i.e. one TV, one carrot, but for extra low price. We are going with a whole family to that SuperHiperMarket. Every person can take as many objects, as he&#x2F;she can carry out from the SuperSale. We have given list of objects with prices and their weight. We also know, what is the maximum weight that every person can stand. What is the maximal value of objects we can buy at SuperSale?</p>
<p>The input consists ofTtest cases. The number of them (1&lt;&#x3D;T&lt;&#x3D;1000) is given on the first line of the input file.</p>
<p>Each test case begins with a line containing a single integer numberNthat indicates the number of objects (1 &lt;&#x3D; N &lt;&#x3D; 1000). Then follows<em>N</em>lines, each containing two integers: P and W. The first integer (1&lt;&#x3D;P&lt;&#x3D;100) corresponds to the price of object. The secondinteger (1&lt;&#x3D;W&lt;&#x3D;30) corresponds to the weight of object. Next line contains one integer (1&lt;&#x3D;G&lt;&#x3D;100)it’s the number of people in our group. Next G lines contains maximal weight (1&lt;&#x3D;MW&lt;&#x3D;30) that can stand this i*-th*person from our family (1&lt;&#x3D;i&lt;&#x3D;G).</p>
<p>For every test case your program has to determine one integer. Print out the maximal value of goods which we can buy with that family.</p>
<p>2</p>
<p>3</p>
<p>72 17</p>
<p>44 23</p>
<p>31 24</p>
<p>1</p>
<p>26</p>
<p>6</p>
<p>64 26</p>
<p>85 22</p>
<p>52 4</p>
<p>99 18</p>
<p>39 13</p>
<p>54 9</p>
<p>4</p>
<p>23</p>
<p>20</p>
<p>20</p>
<p>26</p>
<p>72</p>
<p>514</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 10192 Vacation （DP 最长公共子序列）</title>
    <url>/posts/oj/dp/UVa%2010192%20Vacation%20%EF%BC%88DP%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%89/</url>
    <content><![CDATA[<p>﻿﻿</p>
<p>题意：假期你要出去旅游 你爸爸和你妈妈对你去的城市有不同的意见 为了不让他们中的任何一个不开心 你得选出同时符合两人的方案 也就是最长公共子序列 这个大白上有很详细的讲解 直接用增量法就些 注意输入数据有空格 不能用scanf读入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define M <span class="number">110</span></span><br><span class="line">using namespace std;</span><br><span class="line">char a[M],b[M];</span><br><span class="line">int d[M][M],n,m;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">LCS</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">memset</span>(d,<span class="number">0</span>,<span class="title function_">sizeof</span>(d));</span><br><span class="line">    n=<span class="title function_">strlen</span>(a+<span class="number">1</span>);</span><br><span class="line">    m=<span class="title function_">strlen</span>(b+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(int j=<span class="number">1</span>; j&lt;=m; ++j)</span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[j]) d[i][j]=d[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j]=<span class="title function_">max</span>(d[i-<span class="number">1</span>][j],d[i][j-<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">gets</span>(a+<span class="number">1</span>)!=<span class="variable constant_">NULL</span>,a[<span class="number">1</span>]!=<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ++t;</span><br><span class="line">        <span class="title function_">gets</span>(b+<span class="number">1</span>);</span><br><span class="line">        <span class="title function_">LCS</span>();</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;Case #%d: you can visit at most %d cities.\n&quot;</span>,t,d[n][m]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于本题没要求打印方案 故还可用滚动数组以达到空间上的优化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define M <span class="number">110</span></span><br><span class="line">using namespace std;</span><br><span class="line">char a[M],b[M];</span><br><span class="line">int d[M],n,m,r,temp;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">LCS</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">memset</span>(d,<span class="number">0</span>,<span class="title function_">sizeof</span>(d));</span><br><span class="line">    n=<span class="title function_">strlen</span>(a+<span class="number">1</span>);</span><br><span class="line">    m=<span class="title function_">strlen</span>(b+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int j=<span class="number">1</span>; j&lt;=m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[j]) temp=r+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> temp=<span class="title function_">max</span>(d[j],d[j-<span class="number">1</span>]);</span><br><span class="line">            r=d[j];</span><br><span class="line">            d[j]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">gets</span>(a+<span class="number">1</span>)!=<span class="variable constant_">NULL</span>,a[<span class="number">1</span>]!=<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ++t;</span><br><span class="line">        <span class="title function_">gets</span>(b+<span class="number">1</span>);</span><br><span class="line">        <span class="title function_">LCS</span>();</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;Case #%d: you can visit at most %d cities.\n&quot;</span>,t,d[m]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p><a href="http://vjudge.net/">Problem E: Vacation</a></p>
<h2 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a><a href="http://vjudge.net/">The Problem</a></h2><p>You are planning to take some rest and to go out on vacation, but you really don’t know which cities you should visit. So, you ask your parents for help. Your mother says “My son, you MUST visit Paris, Madrid, Lisboa and London. But it’s only fun in this order.” Then your father says: “Son, if you’re planning to travel, go first to Paris, then to Lisboa, then to London and then, at last, go to Madrid. I know what I’m talking about.”</p>
<p>Now you’re a bit confused, as you didn’t expected this situation. You’re afraid that you’ll hurt your mother if you follow your father’s suggestion. But you’re also afraid to hurt your father if you follow you mother’s suggestion. But it can get worse, because you can hurt both of them if you simply ignore their suggestions!</p>
<p>Thus, you decide that you’ll try to follow their suggestions in the better way that you can. So, you realize that the “Paris-Lisboa-London” order is the one which better satisfies both your mother and your father. Afterwards you can say that you could not visit Madrid, even though you would’ve liked it very much.</p>
<p>If your father have suggested the “London-Paris-Lisboa-Madrid” order, then you would have two orders, “Paris-Lisboa” and “Paris-Madrid”, that would better satisfy both of your parent’s suggestions. In this case, you could only visit 2 cities.</p>
<p>You want to avoid problems like this one in the future. And what if their travel suggestions were bigger? Probably you would not find the better way very easy. So, you decided to write a program to help you in this task. You’ll represent each city by one character, using uppercase letters, lowercase letters, digits and the space. Thus, you can have at most 63 different cities to visit. But it’s possible that you’ll visit some city more than once.</p>
<p>If you represent Paris with “a”, Madrid with “b”, Lisboa with “c” and London with “d”, then your mother’s suggestion would be “abcd” and you father’s suggestion would be “acdb” (or “dacb”, in the second example).</p>
<p>The program will read two travel sequences and it must answer how many cities you can travel to such that you’ll satisfy both of your parents and it’s maximum.</p>
<h2 id="The-Input"><a href="#The-Input" class="headerlink" title="The Input"></a><a href="http://vjudge.net/">The Input</a></h2><p>The input will consist on an arbitrary number of city sequence pairs. The end of input occurs when the first sequence starts with an “&#x2F;#”character (without the quotes). Your program should not process this case. Each travel sequence will be on a line alone and will be formed by legal characters (as defined above). All travel sequences will appear in a single line and will have at most 100 cities.</p>
<h2 id="The-Output"><a href="#The-Output" class="headerlink" title="The Output"></a><a href="http://vjudge.net/">The Output</a></h2><p>For each sequence pair, you must print the following message in a line alone:<br>Case &#x2F;#d: you can visit at most K cities. Where d stands for the test case number (starting from 1) and K is the maximum number of cities you can visit such that you’ll satisfy both you father’s suggestion and you mother’s suggestion.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a><a href="http://vjudge.net/">Sample Input</a></h2><p>abcd acdb abcd dacb &#x2F;#</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a><a href="http://vjudge.net/">Sample Output</a></h2><p>Case &#x2F;#1: you can visit at most 3 cities. Case &#x2F;#2: you can visit at most 2 cities.</p>
<p>© 2001 Universidade do Brasil (UFRJ). Internal Contest Warmup 2001.</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 1025 A Spy in the Metro(DP)</title>
    <url>/posts/oj/dp/UVa%201025%20A%20Spy%20in%20the%20Metro(DP)/</url>
    <content><![CDATA[<p>题意 某城市的地铁有n个车站 编号1到n 有m1辆车向右开 给出m1个从车站1出发的时间 m2辆车向左开 给出m2个从车站n出发的时间 t[i]为火车从第i个车站开到第i+1（或相反）个车站需要的时间 Maria在车站1 她需要恰在时刻T到达第n个车站 求她的最小总车站等待时间</p>
<p>基础的多阶段决策DP 令d[i][j]表示时刻j在i号车站剩下的最小总等待时间 每种状态有3种选择</p>
<ol>
<li><p>等一个单位时间<strong>d[i][j+1]+1;</strong></p>
</li>
<li><p>当前站此时有往左的车并搭乘<strong>d[i-1][j+t[i-1]];</strong></p>
</li>
</ol>
<p>3.当前站此时有往右的车并搭乘<strong>d[i+1][j+t[i]].</strong></p>
<p>每个点三种选择选最优的就行了 边界条件为<strong>d[n][T]&#x3D;0</strong> 其它状态均初始化为INF</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">55</span>, M = <span class="number">205</span>;</span><br><span class="line">int t[N], d[N][M];  <span class="comment">//j时刻在i号车站剩下的最小总等待时间</span></span><br><span class="line">bool l[N][M], r[N][M];  <span class="comment">//j时刻在i号车站是否有往左(右)的车</span></span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, m, ti, cur, cas = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;ti);</span><br><span class="line">        <span class="title function_">memset</span>(l, <span class="number">0</span>, <span class="title function_">sizeof</span>(l)), <span class="title function_">memset</span>(r, <span class="number">0</span>, <span class="title function_">sizeof</span>(r));</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; n; ++i) <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t[i]);</span><br><span class="line"></span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);  <span class="comment">//cur时刻车站j是否有往右的车</span></span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cur);</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">                r[j][cur] = <span class="number">1</span>, cur += t[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);  <span class="comment">//cur时刻车站j是否有往左的车</span></span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cur);</span><br><span class="line">            <span class="keyword">for</span>(int j = n; j &gt;= <span class="number">1</span>; --j)</span><br><span class="line">                l[j][cur] = <span class="number">1</span>, cur += t[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">memset</span>(d, <span class="number">0x3f</span>, <span class="title function_">sizeof</span>(d));</span><br><span class="line">        d[n][ti] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int j = ti - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                d[i][j] = d[i][j + <span class="number">1</span>] + <span class="number">1</span>;   <span class="comment">//在i车站等1单位时间</span></span><br><span class="line">                <span class="keyword">if</span>(l[i][j]) d[i][j] = <span class="title function_">min</span>(d[i][j], d[i - <span class="number">1</span>][j + t[i - <span class="number">1</span>]]);  <span class="comment">//往左</span></span><br><span class="line">                <span class="keyword">if</span>(r[i][j]) d[i][j] = <span class="title function_">min</span>(d[i][j], d[i + <span class="number">1</span>][j + t[i]]);  <span class="comment">//往右</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;Case Number %d: &quot;</span>, ++cas);</span><br><span class="line">        <span class="keyword">if</span>(d[<span class="number">1</span>][<span class="number">0</span>] &gt; ti) <span class="title function_">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Secret agent Maria was sent to Algorithms City to carry out an especially dangerous mission. After several thrilling events we find her in the first station of Algorithms City Metro, examining the time table. The Algorithms City Metro consists of a single line with trains running both ways, so its time table is not complicated.</p>
<p>Maria has an appointment with a local spy at the last station of Algorithms City Metro. Maria knows that a powerful organization is after her. She also knows that while waiting at a station, she is at great risk of being caught. To hide in a running train is much safer, so she decides to stay in running trains as much as possible, even if this means traveling backward and forward. Maria needs to know a schedule with minimal waiting time at the stations that gets her to the last station in time for her appointment. You must write a program that finds the total waiting time in a best schedule for Maria.</p>
<p>The Algorithms City Metro system has <em>N</em> stations, consecutively numbered from 1 to <em>N</em>. Trains move in both directions: from the first station to the last station and from the last station back to the first station. The time required for a train to travel between two consecutive stations is fixed since all trains move at the same speed. Trains make a very short stop at each station, which you can ignore for simplicity. Since she is a very fast agent, Maria can always change trains at a station even if the trains involved stop in that station at the same time.</p>
<p><img src="/../images/dge.org-external-10-p2728.gif.png" alt="\epsfbox{p2728.eps}"></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>The input file contains several test cases. Each test case consists of seven lines with information as follows. <strong>Line 1.</strong> The integer <em>N</em> ( 2<img src="/../images/dge.org-external-10-2728img2.gif.png" alt="$ \le$"><em>N</em><img src="/../images/dge.org-external-10-2728img2.gif.png" alt="$ \le$">50), which is the number of stations. <strong>Line 2.</strong> The integer <em>T</em> ( 0<img src="/../images/dge.org-external-10-2728img2.gif.png" alt="$ \le$"><em>T</em><img src="/../images/dge.org-external-10-2728img2.gif.png" alt="$ \le$">200), which is the time of the appointment. <strong>Line 3.</strong> <em>N</em> - 1 integers: <em>t</em>1, <em>t</em>2,…, <em>t</em>N - 1 ( 1<img src="/../images/dge.org-external-10-2728img2.gif.png" alt="$ \le$"><em>t</em>i<img src="/../images/dge.org-external-10-2728img2.gif.png" alt="$ \le$">70), representing the travel times for the trains between two consecutive stations: <em>t</em>1 represents the travel time between the first two stations, <em>t</em>2 the time between the second and the third station, and so on. <strong>Line 4.</strong> The integer <em>M</em>1 ( 1<img src="/../images/dge.org-external-10-2728img2.gif.png" alt="$ \le$"><em>M</em>1<img src="/../images/dge.org-external-10-2728img2.gif.png" alt="$ \le$">50), representing the number of trains departing from the first station. <strong>Line 5.</strong> <em>M</em>1 integers: <em>d</em>1, <em>d</em>2,…, <em>d</em>M1 ( 0<img src="/../images/dge.org-external-10-2728img2.gif.png" alt="$ \le$"><em>d</em>i<img src="/../images/dge.org-external-10-2728img2.gif.png" alt="$ \le$">250 and <em>d</em>i &lt; <em>d</em>i + 1), representing the times at which trains depart from the first station. <strong>Line 6.</strong> The integer <em>M</em>2 ( 1<img src="/../images/dge.org-external-10-2728img2.gif.png" alt="$ \le$"><em>M</em>2<img src="/../images/dge.org-external-10-2728img2.gif.png" alt="$ \le$">50), representing the number of trains departing from the <em>N</em>-th station. <strong>Line 7.</strong> <em>M</em>2 integers: <em>e</em>1, <em>e</em>2,…, <em>e</em>M2 ( 0<img src="/../images/dge.org-external-10-2728img2.gif.png" alt="$ \le$"><em>e</em>i<img src="/../images/dge.org-external-10-2728img2.gif.png" alt="$ \le$">250 and <em>e</em>i &lt; <em>e</em>i + 1) representing the times at which trains depart from the <em>N</em>-th station.</p>
<p>The last case is followed by a line containing a single zero.</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>For each test case, print a line containing the case number (starting with 1) and an integer representing the total waiting time in the stations for a best schedule, or the word &#96; impossible ‘ in case Maria is unable to make the appointment. Use the format of the sample output.</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>4 55 5 10 15 4 0 5 10 20 4 0 5 10 15 4 18 1 2 3 5 0 3 6 10 12 6 0 3 5 7 12 15 2 30 20 1 20 7 1 3 5 7 11 13 17 0</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>Case Number 1: 5 Case Number 2: 0 Case Number 3: impossible</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 10285 Longest Run on a Snowboard(DP 二维最长递减子序列)</title>
    <url>/posts/oj/dp/UVa%2010285%20Longest%20Run%20on%20a%20Snowboard(DP%20%E4%BA%8C%E7%BB%B4%E6%9C%80%E9%95%BF%E9%80%92%E5%87%8F%E5%AD%90%E5%BA%8F%E5%88%97)/</url>
    <content><![CDATA[<p>题意 输入一个城市的滑雪地图 你可以从高的地方滑到伤下左右低的地方 求这个城市的最长滑雪线路长度 即在一个矩阵中找出最长递减连续序列</p>
<p>令d[i][j]为以格子map(i,j)为起点的最长序列 则有状态转移方程d[i][j]&#x3D;max{d[a][b]}+1 a,b为与i,j相邻且值比i,j小的所有点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;  </span><br><span class="line">#include&lt;cstring&gt;  </span><br><span class="line">#include&lt;algorithm&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line">#define maxn <span class="number">105</span>  </span><br><span class="line">#define a i+x[k]  </span><br><span class="line">#define b j+y[k]  </span><br><span class="line">int ma[maxn][maxn],d[maxn][maxn],r,c,n,ans;  </span><br><span class="line">int x[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;,y[<span class="number">4</span>]=&#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;  </span><br><span class="line">  </span><br><span class="line">int <span class="title function_">dp</span>(<span class="params">int i,int j</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span>(d[i][j]&gt;<span class="number">0</span>) <span class="keyword">return</span> d[i][j];  </span><br><span class="line">    d[i][j]=<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span>(int k=<span class="number">0</span>;k&lt;<span class="number">4</span>;++k)  </span><br><span class="line">    <span class="keyword">if</span>((ma[i][j]&gt;ma[a][b])&amp;&amp;(a&gt;<span class="number">0</span>&amp;&amp;a&lt;=r)&amp;&amp;(b&gt;<span class="number">0</span>&amp;&amp;b&lt;=c))  </span><br><span class="line">    &#123;  </span><br><span class="line">        d[i][j]=<span class="title function_">max</span>(d[i][j],<span class="title function_">dp</span>(a,b)+<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> d[i][j];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    char name[<span class="number">100</span>];  </span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);  </span><br><span class="line">    <span class="keyword">for</span>(int cas=<span class="number">1</span>;cas&lt;=n;++cas)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,name,&amp;r,&amp;c);  </span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=r;++i)  </span><br><span class="line">            <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=c;++j)  </span><br><span class="line">                <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;ma[i][j]);  </span><br><span class="line">  </span><br><span class="line">        <span class="title function_">memset</span>(d,<span class="number">0</span>,<span class="title function_">sizeof</span>(d));  </span><br><span class="line">        ans=<span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=r;++i)  </span><br><span class="line">            <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=c;++j)  </span><br><span class="line">                ans=<span class="title function_">max</span>(<span class="title function_">dp</span>(i,j),ans);  </span><br><span class="line">  </span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%s: %d\n&quot;</span>,name,ans);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Longest Run on a Snowboard</strong></p>
<p>Michael likes snowboarding. That’s not very surprising, since snowboarding is really great. The bad thing is that in order to gain speed, the area must slide downwards. Another disadvantage is that when you’ve reached the bottom of the hill you have to walk up again or wait for the ski-lift.</p>
<p>Michael would like to know how long the longest run in an area is. That area is given by a grid of numbers, defining the heights at those points. Look at this example:<br><strong>1 2 3 4 5</strong> <strong>16 17 18 19 6</strong> <strong>15 24 25 20 7</strong> <strong>14 23 22 21 8</strong> <strong>13 12 11 10 9</strong></p>
<p>One can slide down from one point to a connected other one if and only if the height decreases. One point is connected to another if it’s at left, at right, above or below it. In the sample map, a possible slide would be<strong>24-17-16-1</strong>(start at<strong>24</strong>, end at<strong>1</strong>). Of course if you would go<strong>25-24-23-…-3-2-1</strong>, it would be a much longer run. In fact, it’s the longest possible.</p>
<p><strong>Input</strong></p>
<p>The first line contains the number of test cases<strong>N</strong>. Each test case starts with a line containing the name (it’s a single string), the number of rows<strong>R</strong>and the number of columns<strong>C</strong>. After that follow<strong>R</strong>lines with<strong>C</strong>numbers each, defining the heights.<strong>R</strong>and C won’t be bigger than<strong>100</strong>,<strong>N</strong>not bigger than<strong>15</strong>and the heights are always in the range from<strong>0</strong>to<strong>100</strong>.</p>
<p>For each test case, print a line containing the name of the area, a colon, a space and the length of the longest run one can slide down in that area.<br><strong>Sample Input</strong> 2 Feldberg 10 5 56 14 51 58 88 26 94 24 39 41 24 16 8 51 51 76 72 77 43 10 38 50 59 84 81 5 23 37 71 77 96 10 93 53 82 94 15 96 69 9 74 0 62 38 96 37 54 55 82 38 Spiral 5 5 1 2 3 4 5 16 17 18 19 6 15 24 25 20 7 14 23 22 21 8 13 12 11 10 9</p>
<p><strong>Sample Output</strong><br>Feldberg: 7 Spiral: 25</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 103 Stacking Boxes 堆砌盒子(DP 最长条件子序列)</title>
    <url>/posts/oj/dp/UVa%20103%20Stacking%20Boxes%20%E5%A0%86%E7%A0%8C%E7%9B%92%E5%AD%90(DP%20%E6%9C%80%E9%95%BF%E6%9D%A1%E4%BB%B6%E5%AD%90%E5%BA%8F%E5%88%97)/</url>
    <content><![CDATA[<p>题意 盒子a的n边都小于盒子b时 盒子a就可以放在盒子b上 求这样最多能堆多高</p>
<p>DAG中不固定顶点的最长路径，小白P162有讲解，d(i)&#x3D;max{d(j)+1} j表示所有能装得下i的盒子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define M <span class="number">35</span></span><br><span class="line">int a[M][M],d[M],pre[M],k,n,m;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool <span class="title class_">Isnest</span>(int i,int j)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">sort</span>(a[i]+<span class="number">1</span>,a[i]+<span class="number">1</span>+n);</span><br><span class="line">    <span class="title function_">sort</span>(a[j]+<span class="number">1</span>,a[j]+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(int u=<span class="number">1</span>;u&lt;=n;++u)</span><br><span class="line">        <span class="keyword">if</span>(a[i][u]&lt;=a[j][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">dp</span>(<span class="params">int i</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[i]&gt;<span class="number">0</span>) <span class="keyword">return</span> d[i];</span><br><span class="line">    d[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=k;++j)</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Isnest</span>(i,j)&amp;&amp;<span class="title function_">dp</span>(j)+<span class="number">1</span>&gt;d[i])</span><br><span class="line">        &#123;</span><br><span class="line">            d[i]=d[j]+<span class="number">1</span>;</span><br><span class="line">            pre[i]=j;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> d[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span>(<span class="params">int i</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">print</span>(pre[i]);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot; %d&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;k,&amp;n)!=<span class="variable constant_">EOF</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=k;++i)</span><br><span class="line">            <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">        m=<span class="number">0</span>;</span><br><span class="line">        <span class="title function_">memset</span>(pre,<span class="number">0</span>,<span class="title function_">sizeof</span>(pre));</span><br><span class="line">        <span class="title function_">memset</span>(d,<span class="number">0</span>,<span class="title function_">sizeof</span>(d));</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=k;++i)</span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_">dp</span>(i)&gt;<span class="title function_">dp</span>(m))</span><br><span class="line">                m=i;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>,d[m]);</span><br><span class="line">        <span class="title function_">print</span>(m);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Some concepts in Mathematics and Computer Science are simple in one or two dimensions but become more complex when extended to arbitrary dimensions. Consider solving differential equations in several dimensions and analyzing the topology of an n-dimensional hypercube. The former is much more complicated than its one dimensional relative while the latter bears a remarkable resemblance to its &#96;&#96;lower-class’’ cousin.</p>
<h2 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h2><p>Consider an n-dimensional &#96;&#96;box’’ given by its dimensions. In two dimensions the box (2,3) might represent a box with length 2 units and width 3 units. In three dimensions the box (4,8,9) can represent a box <img src="/../images/dge.org-external-1-103img1.gif.png" alt="tex2html_wrap_inline40"> (length, width, and height). In 6 dimensions it is, perhaps, unclear what the box (4,5,6,7,8,9) represents; but we can analyze properties of the box such as the sum of its dimensions.</p>
<p>In this problem you will analyze a property of a group of n-dimensional boxes. You are to determine the longest nesting string of boxes, that is a sequence of boxes <img src="/../images/dge.org-external-1-103img2.gif.png" alt="tex2html_wrap_inline44"> such that each box <img src="/../images/dge.org-external-1-103img3.gif.png" alt="tex2html_wrap_inline46">nests in box <img src="/../images/dge.org-external-1-103img4.gif.png" alt="tex2html_wrap_inline48"> ( <img src="/../images/dge.org-external-1-103img5.gif.png" alt="tex2html_wrap_inline50"> .</p>
<p>A box D &#x3D; ( <img src="/../images/dge.org-external-1-103img6.gif.png" alt="tex2html_wrap_inline52"> ) nests in a box E &#x3D; ( <img src="/../images/dge.org-external-1-103img7.gif.png" alt="tex2html_wrap_inline54"> ) if there is some rearrangement of the <img src="/../images/dge.org-external-1-103img8.gif.png" alt="tex2html_wrap_inline56">such that when rearranged each dimension is less than the corresponding dimension in box E. This loosely corresponds to turning box D to see if it will fit in box E. However, since any rearrangement suffices, box D can be contorted, not just turned (see examples below).</p>
<p>For example, the box D &#x3D; (2,6) nests in the box E &#x3D; (7,3) since D can be rearranged as (6,2) so that each dimension is less than the corresponding dimension in E. The box D &#x3D; (9,5,7,3) does NOT nest in the box E &#x3D; (2,10,6,8) since no rearrangement of D results in a box that satisfies the nesting property, but F &#x3D; (9,5,7,1) does nest in box E since F can be rearranged as (1,9,5,7) which nests in E.</p>
<p>Formally, we define nesting as follows: box D &#x3D; ( <img src="/../images/dge.org-external-1-103img6.gif.png" alt="tex2html_wrap_inline52"> ) nests in box E &#x3D; ( <img src="/../images/dge.org-external-1-103img7.gif.png" alt="tex2html_wrap_inline54"> ) if there is a permutation <img src="/../images/dge.org-external-1-103img9.gif.png" alt="tex2html_wrap_inline62"> of <img src="/../images/dge.org-external-1-103img10.gif.png" alt="tex2html_wrap_inline64"> such that ( <img src="/../images/dge.org-external-1-103img11.gif.png" alt="tex2html_wrap_inline66"> ) &#96;&#96;fits’’ in ( <img src="/../images/dge.org-external-1-103img7.gif.png" alt="tex2html_wrap_inline54"> ) i.e., if<img src="/../images/dge.org-external-1-103img12.gif.png" alt="tex2html_wrap_inline70"> for all <img src="/../images/dge.org-external-1-103img13.gif.png" alt="tex2html_wrap_inline72"> .</p>
<h2 id="The-Input"><a href="#The-Input" class="headerlink" title="The Input"></a>The Input</h2><p>The input consists of a series of box sequences. Each box sequence begins with a line consisting of the the number of boxes k in the sequence followed by the dimensionality of the boxes, n (on the same line.)</p>
<p>This line is followed by k lines, one line per box with the n measurements of each box on one line separated by one or more spaces. The <img src="/../images/dge.org-external-1-103img14.gif.png" alt="tex2html_wrap_inline82"> line in the sequence ( <img src="/../images/dge.org-external-1-103img15.gif.png" alt="tex2html_wrap_inline84"> ) gives the measurements for the <img src="/../images/dge.org-external-1-103img14.gif.png" alt="tex2html_wrap_inline82"> box.</p>
<p>There may be several box sequences in the input file. Your program should process all of them and determine, for each sequence, which of the k boxes determine the longest nesting string and the length of that nesting string (the number of boxes in the string).</p>
<p>In this problem the maximum dimensionality is 10 and the minimum dimensionality is 1. The maximum number of boxes in a sequence is 30.</p>
<h2 id="The-Output"><a href="#The-Output" class="headerlink" title="The Output"></a>The Output</h2><p>For each box sequence in the input file, output the length of the longest nesting string on one line followed on the next line by a list of the boxes that comprise this string in order. The <code>smallest&#39;&#39; or </code>innermost’’ box of the nesting string should be listed first, the next box (if there is one) should be listed second, etc.</p>
<p>The boxes should be numbered according to the order in which they appeared in the input file (first box is box 1, etc.).</p>
<p>If there is more than one longest nesting string then any one of them can be output.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>5 2 3 7 8 10 5 2 9 11 21 18 8 6 5 2 20 1 30 10 23 15 7 9 11 3 40 50 34 24 14 4 9 10 11 12 13 14 31 4 18 8 27 17 44 32 13 19 41 19 1 2 3 4 5 6 80 37 47 18 21 9</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>5 3 1 2 4 5 4 7 2 5 6</p>
<p>﻿﻿</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 10404 Bachet&#39;s Game(DP)</title>
    <url>/posts/oj/dp/UVa%2010404%20Bachet&#39;s%20Game(DP)/</url>
    <content><![CDATA[<p>题意 给你n个小石头 和一个数组a[m] 然后两个人轮流取石头 stan先取 olive后取 他们都完美发挥 谁取完最后一个石头谁就是赢家 感觉不是很容易看出来是dp题 令d[i]表示只有i个石子时谁赢 1表示stan赢 0表示olive赢</p>
<p>i-a[j]表示从i个石子一次取走a[j]个还剩下的 所以有 当(i-a[j]&gt;0&amp;&amp;d[i-a[j]]&#x3D;0)时 d[i]&#x3D;1;</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;  </span><br><span class="line">#include&lt;cstring&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line">int d[<span class="number">1000005</span>],a[<span class="number">12</span>],ans,n,m;  </span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=<span class="variable constant_">EOF</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);  </span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=m;++i)  </span><br><span class="line">                <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);  </span><br><span class="line">        <span class="title function_">memset</span>(d,<span class="number">0</span>,<span class="title function_">sizeof</span>(d));  </span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;++i)  </span><br><span class="line">            <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=m;++j)  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">if</span>(i-a[j]&gt;=<span class="number">0</span>&amp;&amp;d[i-a[j]]==<span class="number">0</span>)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    d[i]=<span class="number">1</span>;  </span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        <span class="title function_">printf</span>(d[n]?<span class="string">&quot;Stan wins\n&quot;</span>:<span class="string">&quot;Ollie wins\n&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="Bachet’s-Game"><a href="#Bachet’s-Game" class="headerlink" title="Bachet’s Game"></a>Bachet’s Game</h2><p><img src="/../images/dge.org-external-104-p10404.jpg.png">Bachet’s game is probably known to all but probably not by this name. Initially there are<strong>n</strong>stones on the table. There are two players Stan and Ollie, who move alternately. Stan always starts. The legal moves consist in removing at least one but not more than<strong>k</strong>stones from the table. The winner is the one to take the last stone.</p>
<p>Here we consider a variation of this game. The number of stones that can be removed in a single move must be a member of a certain set of <strong>m</strong> numbers. Among the <strong>m</strong> numbers there is always 1 and thus the game never stalls.</p>
<p>The input consists of a number of lines. Each line describes one game by a sequence of positive numbers. The first number is<strong>n</strong>&lt;&#x3D; 1000000 the number of stones on the table; the second number is<strong>m</strong>&lt;&#x3D; 10 giving the number of numbers that follow; the last<strong>m</strong>numbers on the line specify how many stones can be removed from the table in a single move.</p>
<p>For each line of input, output one line saying eitherStan winsorOllie winsassuming that both of them play perfectly.</p>
<p>20 3 1 3 8 21 3 1 3 8 22 3 1 3 8 23 3 1 3 8 1000000 10 1 23 38 11 7 5 4 8 3 13 999996 10 1 23 38 11 7 5 4 8 3 13</p>
<p>Stan wins Stan wins Ollie wins Stan wins Stan wins Ollie wins</p>
<p>﻿﻿</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 10465 Homer Simpson(DP 完全背包)</title>
    <url>/posts/oj/dp/UVa%2010465%20Homer%20Simpson(DP%20%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85)/</url>
    <content><![CDATA[<p>﻿﻿</p>
<p>题意 霍默辛普森吃汉堡 有两种汉堡 一中吃一个需要m分钟 另一种吃一个需要n分钟 他共有t分钟时间要我们输出他在尽量用掉所有时间的前提下最多能吃多少个汉堡 如果时间无法用完 输出他吃的汉堡数和剩余喝酒的时间</p>
<p>很明显的完全背包问题 求两次 一次对个数 一次对时间就行了 时间用不完的情况下就输出时间的</p>
<p>d1为个数的 d2为时间的 dt保存时间</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define maxn <span class="number">10005</span></span><br><span class="line">using namespace std;</span><br><span class="line">int w[<span class="number">2</span>],t,d1[maxn],d2[maxn],dt[maxn];</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;w[<span class="number">0</span>],&amp;w[<span class="number">1</span>],&amp;t)!=<span class="variable constant_">EOF</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">memset</span>(d1,<span class="number">0x8f</span>,<span class="title function_">sizeof</span>(d1));</span><br><span class="line">        <span class="title function_">memset</span>(dt,<span class="number">0</span>,<span class="title function_">sizeof</span>(dt));</span><br><span class="line">        <span class="title function_">memset</span>(d2,<span class="number">0</span>,<span class="title function_">sizeof</span>(d2));</span><br><span class="line">        d1[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;<span class="number">2</span>; ++i)</span><br><span class="line">            <span class="keyword">for</span>(int j=w[i]; j&lt;=t; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                d1[j]=<span class="title function_">max</span>(d1[j],d1[j-w[i]]+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>((dt[j]&lt;dt[j-w[i]]+w[i])||((dt[j]==dt[j-w[i]]+w[i])&amp;&amp;(d2[j]&lt;d2[j-w[i]]+<span class="number">1</span>)))</span><br><span class="line">                &#123;</span><br><span class="line">                    dt[j]=dt[j-w[i]]+w[i];</span><br><span class="line">                    d2[j]=d2[j-w[i]]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(dt[t]==t)</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>,d1[t]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,d2[t],t-dt[t]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> Homer Simpson   <img src="/../images/dge.org-external-104-p10465.jpg.png"> Homer Simpson, a very smart guy, likes eating Krusty-burgers. It takes Homer m minutes to eat a Krusty- burger. However, there�s a new type of burger in Apu�s Kwik-e-Mart. Homer likes those too. It takes him n minutes to eat one of these burgers. Given t minutes, you have to find out the maximum number of burgers Homer can eat without wasting any time. If he must waste time, he can have beer.</p>
<p>Input<br>Input consists of several test cases. Each test case consists of three integers m, n, t (0 &lt; m,n,t &lt; 10000). Input is terminated by EOF.</p>
<p>Output<br>For each test case, print in a single line the maximum number of burgers Homer can eat without having beer. If homer must have beer, then also print the time he gets for drinking, separated by a single space. It is preferable that Homer drinks as little beer as possible.<br>Sample Input<br>3 5 54<br>3 5 55</p>
<p>Sample Output<br>18<br>17</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 10534 Wavio Sequence ( DP 二分 最长递增子序列 )</title>
    <url>/posts/oj/dp/UVa%2010534%20Wavio%20Sequence%20(%20DP%20%E4%BA%8C%E5%88%86%20%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%20)/</url>
    <content><![CDATA[<p>题意 求一个序列a某一位的最长递增序列(lis)和最长递减序列(lds)中最小值的最大值</p>
<p>开始直接用DP写了 然后就超时了 后来看到别人说要用二分把时间复杂度优化到O(n&#x2F;*logn) 果然如此 用一个栈s保存长度为i的LIS的最小尾部s[i] top为栈顶即当前LIS的长度 初始s[1]&#x3D;a[1] top&#x3D;1 遍历整个序列 当a[i]&gt;s[top]时 a[i]入栈 in[i]&#x3D;top 否则 在栈中查找（二分）第一个大于等于a[i]的下标pos 并替换 这样就增加了LIS增长的潜力 in[i]&#x3D;pos;</p>
<p>in[i]表示以a[i]为尾部的LIS的长度 求lds的过程也是类似</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">10005</span>;</span><br><span class="line">int a[N], <span class="keyword">in</span>[N], de[N], s[N], m, n, top, pos;</span><br><span class="line"></span><br><span class="line">int <span class="title class_">BinSearch</span> (int k, int le, int ri)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (le &lt;= ri)</span><br><span class="line">    &#123;</span><br><span class="line">        m = (le + ri) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[m] &gt;= k) ri = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> le = m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ri + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lis</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    memset (s, <span class="number">0</span>, sizeof (s));</span><br><span class="line">    memset (<span class="keyword">in</span>, <span class="number">0</span>, sizeof (<span class="keyword">in</span>));</span><br><span class="line">    s[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">in</span>[<span class="number">1</span>] = top = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[top] &lt; a[i])</span><br><span class="line">        &#123;</span><br><span class="line">            s[++top] = a[i];</span><br><span class="line">            <span class="keyword">in</span>[i] = top;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pos = <span class="title class_">BinSearch</span> (a[i], <span class="number">1</span>, top);</span><br><span class="line">            s[pos] = a[i];</span><br><span class="line">            <span class="keyword">in</span>[i] = pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lds</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    memset (s, <span class="number">0</span>, sizeof (s));</span><br><span class="line">    memset (de, <span class="number">0</span>, sizeof (de));</span><br><span class="line">    s[<span class="number">1</span>] = a[n];</span><br><span class="line">    de[n] = top = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (int i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[top] &lt; a[i])</span><br><span class="line">        &#123;</span><br><span class="line">            s[++top] = a[i];</span><br><span class="line">            de[i] = top;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pos = <span class="title class_">BinSearch</span> (a[i], <span class="number">1</span>, top);</span><br><span class="line">            s[pos] = a[i];</span><br><span class="line">            de[i] = pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (scanf (<span class="string">&quot;%d&quot;</span>, &amp;n) != <span class="variable constant_">EOF</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            scanf (<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        int ans = <span class="number">1</span>;</span><br><span class="line">        <span class="title function_">lis</span>();</span><br><span class="line">        <span class="title function_">lds</span>();</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (min (de[i], <span class="keyword">in</span>[i]) &gt; ans)</span><br><span class="line">                ans = min (de[i], <span class="keyword">in</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf (<span class="string">&quot;%d\n&quot;</span>, ans * <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有超时的DP版</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N=<span class="number">10005</span>;</span><br><span class="line">int a[N],c[N],d[N],n;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">dpde</span>(<span class="params">int i</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[i]) <span class="keyword">return</span> d[i];</span><br><span class="line">    d[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(int j=i;j&lt;=n;++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;a[j])</span><br><span class="line">            d[i]=<span class="title function_">max</span>(d[i],<span class="title function_">dpde</span>(j)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">dpin</span>(<span class="params">int i</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(c[i]) <span class="keyword">return</span> c[i];</span><br><span class="line">    c[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(int j=i;j&gt;=<span class="number">1</span>;--j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;a[j])</span><br><span class="line">            c[i]=<span class="title function_">max</span>(c[i],<span class="title function_">dpin</span>(j)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=<span class="variable constant_">EOF</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        int ans=<span class="number">1</span>;</span><br><span class="line">        <span class="title function_">memset</span>(d,<span class="number">0</span>,<span class="title function_">sizeof</span>(d));</span><br><span class="line">        <span class="title function_">memset</span>(c,<span class="number">0</span>,<span class="title function_">sizeof</span>(c));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_">min</span>(<span class="title function_">dpde</span>(i),<span class="title function_">dpin</span>(i))&gt;ans)</span><br><span class="line">                ans=<span class="title function_">min</span>(d[i],c[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans*<span class="number">2</span>-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Wavio Sequence</strong></p>
<p>Wavio is a sequence of integers. It has some interesting properties.</p>
<p>· Wavio is of odd length i.e. *<em>L &#x3D; 2&#x2F;<em>n + 1</em></em>.</p>
<p>· The first <strong>(n+1)</strong> integers of Wavio sequence makes a strictly increasing sequence.</p>
<p>· The last <strong>(n+1)</strong> integers of Wavio sequence makes a strictly decreasing sequence.</p>
<p>· No two adjacent integers are same in a Wavio sequence.</p>
<p>For example <strong>1, 2, 3, 4, 5, 4, 3, 2, 0</strong> is an Wavio sequence of length <strong>9</strong>. But <strong>1, 2, 3, 4, 5, 4, 3, 2, 2</strong> is not a valid wavio sequence. In this problem, you will be given a sequence of integers. You have to find out the length of the longest Wavio sequence which is a subsequence of the given sequence. Consider, the given sequence as :</p>
<p><strong>1 2 3 2 1 2 3 4 3 2 1 5 4 1 2 3 2 2 1</strong>.</p>
<p>Here the longest Wavio sequence is : <strong>1 2 3 4 5 4 3 2 1</strong>. So, the output will be <strong>9</strong>.</p>
<p>Input</p>
<p>The input file contains less than <strong>75</strong> test cases. The description of each test case is given below: Input is terminated by end of file.</p>
<p>Each set starts with a postive integer, <strong>N(1&lt;&#x3D;N&lt;&#x3D;10000)</strong>. In next few lines there will be <strong>N</strong> integers.</p>
<p>Output</p>
<p>For each set of input print the length of longest wavio sequence in a line.</p>
<h1 id="Sample-Input-Output-for-Sample-Input"><a href="#Sample-Input-Output-for-Sample-Input" class="headerlink" title="Sample Input Output for Sample Input"></a>Sample Input Output for Sample Input</h1><p><strong>10</strong> <strong>1 2 3 4 5 4 3 2 1 10</strong> <strong>19</strong> <strong>1 2 3 2 1 2 3 4 3 2 1 5 4 1 2 3 2 2 1</strong> <strong>5</strong> <strong>1 2 3 4 5</strong> **** <strong>9</strong> <strong>9</strong> <strong>1</strong></p>
<hr>
<p>Problemsetter: Md. Kamruzzaman, Member of Elite Problemsetters’ Panel</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 10651 Pebble Solitaire (DP 卵石游戏 记忆化搜索)</title>
    <url>/posts/oj/dp/UVa%2010651%20Pebble%20Solitaire%20(DP%20%E5%8D%B5%E7%9F%B3%E6%B8%B8%E6%88%8F%20%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2)/</url>
    <content><![CDATA[<p>﻿﻿</p>
<p>题意 给你一个长度为12的字符串 由字符’-‘和字符’o’组成 其中”-oo”和”oo-“分别可以通过一次转换变为”o–”和”–o” 可以发现每次转换o都少了一个 只需求出给你的字符串做多能转换多少次就行了</p>
<p>令d[s]表示字符串s最多可以转换的次数 若s可以通过一次转换变为字符串t 有d[s]&#x3D;max(d[s],d[t]+1)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">map&lt;string, int&gt; d;</span><br><span class="line">int n, ans;</span><br><span class="line">string t, S;</span><br><span class="line"></span><br><span class="line">int dp (string s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (d[s] &gt; <span class="number">0</span>) <span class="keyword">return</span> d[s];</span><br><span class="line">    d[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;o&#x27;</span> &amp;&amp; s[i + <span class="number">1</span>] == <span class="string">&#x27;o&#x27;</span> &amp;&amp; s[i + <span class="number">2</span>] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t = s;</span><br><span class="line">            t[i] = t[i + <span class="number">1</span>] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">            t[i + <span class="number">2</span>] = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">            d[s] = max (d[s], dp (t) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;-&#x27;</span> &amp;&amp; s[i + <span class="number">1</span>] == <span class="string">&#x27;o&#x27;</span> &amp;&amp; s[i + <span class="number">2</span>] == <span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t = s;</span><br><span class="line">            t[i] = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">            t[i + <span class="number">1</span>] = t[i + <span class="number">2</span>] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">            d[s] = max (d[s], dp (t) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[s];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">        cin &gt;&gt; S;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i)</span><br><span class="line">            <span class="keyword">if</span> (S[i] == <span class="string">&#x27;o&#x27;</span>) ans++;</span><br><span class="line">        ans -= dp (S);</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Pebble Solitaire</strong></p>
<p>Pebble solitaire is an interesting game. This is a game where you are given a board with an arrangement of small cavities, initially all but one occupied by a pebble each. The aim of the game is to remove as many pebbles as possible from the board. Pebbles disappear from the board as a result of a move. A move is possible if there is a straight line of three adjacent cavities, let us call them<strong>A</strong>,<strong>B</strong>, and<strong>C</strong>, with<strong>B</strong>in the middle, where<strong>A</strong>is vacant, but<strong>B</strong>and<strong>C</strong>each contain a pebble. The move constitutes of moving the pebble from<strong>C</strong>to<strong>A</strong>, and removing the pebble in<strong>B</strong>from the board. You may continue to make moves until no more moves are possible.</p>
<p>In this problem, we look at a simple variant of this game, namely a board with twelve cavities located along a line. In the beginning of each game, some of the cavities are occupied by pebbles. Your mission is to find a sequence of moves such that as few pebbles as possible are left on the board.</p>
<p>Input</p>
<p>The input begins with a positive integer<strong>n</strong>on a line of its own. Thereafter<strong>n</strong>different games follow. Each game consists of one line of input with exactly twelve characters, describing the twelve cavities of the board in order. Each character is either**’-‘<strong>or</strong>‘o’<strong>(The fifteenth character of English alphabet in lowercase). A</strong>‘-‘<strong>(minus) character denotes an empty cavity, whereas a</strong>‘o’**character denotes a cavity with a pebble in it. As you will find in the sample that there may be inputs where no moves is possible.</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each of the n games in the input, output the minimum number of pebbles left on the board possible to obtain as a result of moves, on a row of its own.</p>
<h1 id="Sample-InputOutput-for-Sample-Input"><a href="#Sample-InputOutput-for-Sample-Input" class="headerlink" title="Sample InputOutput for Sample Input"></a>Sample InputOutput for Sample Input</h1><p><strong>5</strong></p>
<p><strong>—oo——-</strong></p>
<p><strong>-o–o-oo—-</strong></p>
<p><strong>-o—-ooo—</strong></p>
<p><strong>oooooooooooo</strong></p>
<p><strong>oooooooooo-o</strong></p>
<p><strong>1</strong></p>
<p><strong>2</strong></p>
<p><strong>3</strong></p>
<p><strong>12</strong></p>
<p><strong>1</strong></p>
<hr>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 11134 Fabled Rooks（贪心）</title>
    <url>/posts/oj/dp/UVa%2011134%20Fabled%20Rooks%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89/</url>
    <content><![CDATA[<p>题意 在n&#x2F;*n的棋盘上的n个指定区间上各放1个’车’ 使他们相互不攻击 输出一种可能的方法</p>
<p>行和列可以分开看 就变成了n个区间上选n个点的贪心问题 看行列是否都有解就行</p>
<p>基础的贪心问题 对每个点k选择包含它的最优未使用区间 由于在给k找最优区间时1~k-1的最优区间都已经找好了 所有右界最小的区间肯定是最优区间</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">5005</span>;</span><br><span class="line">int xl[N], yl[N], xr[N], yr[N], x[N], y[N], n;</span><br><span class="line"></span><br><span class="line">bool <span class="title function_">solve</span>(<span class="params">int a[], int l[], int r[]</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cur, mr;</span><br><span class="line">    <span class="comment">//mr为包含k的区间最小右界，cur为放k的最优区间</span></span><br><span class="line">    <span class="title function_">memset</span>(a, -<span class="number">1</span>, <span class="title function_">sizeof</span>(int)*n);</span><br><span class="line">    <span class="keyword">for</span>(int k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        cur = -<span class="number">1</span>, mr = N;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(a[i] &lt; <span class="number">0</span> &amp;&amp; l[i] &lt;= k &amp;&amp; r[i] &lt; mr)</span><br><span class="line">                mr = r[cur = i];</span><br><span class="line">        <span class="keyword">if</span>(cur &lt; <span class="number">0</span> || k &gt; mr)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        a[cur] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;xl[i], &amp;yl[i], &amp;xr[i], &amp;yr[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_">solve</span>(x, xl, xr) &amp;&amp; <span class="title function_">solve</span>(y, yl, yr))</span><br><span class="line">            <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                <span class="title function_">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, x[i], y[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="title function_">puts</span>(<span class="string">&quot;IMPOSSIBLE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Fabled-Rooks"><a href="#Fabled-Rooks" class="headerlink" title="Fabled Rooks"></a>Fabled Rooks</h2><p><img src="/../images/dge.org-external-111-p11134.jpg.png"> We would like to place n rooks, 1 ≤ n ≤ 5000, on a n×n board subject to the following restrictions</p>
<p>The input consists of several test cases. The first line of each of them contains one integer number, <em>n</em>, the side of the board. <em>n</em> lines follow giving the rectangles where the rooks can be placed as described above. The <em>i</em>-th line among them gives<em>xli</em>, <em>yli</em>, <em>xri</em>, and <em>yri</em>. The input file is terminated with the integer &#96;0’ on a line by itself.</p>
<p>Your task is to find such a placing of rooks that the above conditions are satisfied and then output<em>n</em> lines each giving the position of a rook in order in which their rectangles appeared in the input. If there are multiple solutions, any one will do. Output IMPOSSIBLE if there is no such placing of the rooks.</p>
<p>8 1 1 2 2 5 7 8 8 2 2 5 5 2 2 5 5 6 3 8 6 6 3 8 5 6 3 8 8 3 6 7 8 8 1 1 2 2 5 7 8 8 2 2 5 5 2 2 5 5 6 3 8 6 6 3 8 5 6 3 8 8 3 6 7 8 0</p>
<p>1 1 5 8 2 4 4 2 7 3 8 5 6 6 3 7 1 1 5 8 2 4 4 2 7 3 8 5 6 6 3 7</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 11400 Lighting System Design(DP 照明系统设计)</title>
    <url>/posts/oj/dp/UVa%2011400%20Lighting%20System%20Design(DP%20%E7%85%A7%E6%98%8E%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1)/</url>
    <content><![CDATA[<p>题意 设计某个地方的照明系统 一共需要n种不同类型的灯泡 接着输入 每种灯泡的电压v 对应电压电源的价格k 每个灯泡的价格c 需要这种灯泡的数量l 电压低的灯泡可以用电压高的灯泡替换 每种灯泡只需要一个对应的电源 求完成这个照明系统的最少花费</p>
<p>比较简单的DP 容易知道 当要替换一种灯泡中的一个到令一种电压较高的灯泡时 只有全部替换这种灯泡为另一种时才可能使总花费变小 全部替换掉就省下了这种灯泡的电源花费 先把灯泡按照电压排序 那么每种灯泡都可以替换他前面的任意灯泡了 令s[i]表示前i种灯泡的总数 那么s[i]-s[j-1]表示的是第j种到第[i]种灯泡的总数</p>
<p>令d[i]表示前i种灯泡的最少花费 那么可以得到转移方程 d[i]&#x3D;min{d[j-1]+(s[i]-s[j-1])&#x2F;*c[i]+k[i]} j为1到i之间所有数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line">int d[N], s[N], v[N], k[N], c[N], l[N], o[N], n;</span><br><span class="line"></span><br><span class="line">bool cmp (int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> v[i] &lt; v[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (~scanf (<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf (<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;v[i], &amp;k[i], &amp;c[i], &amp;l[i]);</span><br><span class="line">            o[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        sort (o + <span class="number">1</span>, o + n + <span class="number">1</span>, cmp);</span><br><span class="line">        memset (d, <span class="number">0x3f</span>, sizeof (d));</span><br><span class="line">        d[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            s[i] = s[i - <span class="number">1</span>] + l[o[i]];</span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">                d[i] = min (d[i], d[j - <span class="number">1</span>] + (s[i] - s[j - <span class="number">1</span>]) * c[o[i]] + k[o[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf (<span class="string">&quot;%d\n&quot;</span>, d[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You are given the task to design a lighting system for a huge conference hall. After doing a lot of calculation &amp; sketching, you have figured out the requirements for an energy-efficient design that can properly illuminate the entire hall. According to your design, you need lamps of<strong>n</strong>different power ratings. For some strange current regulation method, all the lamps need to be fed with the same amount of current. So, each category of lamp has a corresponding voltage rating. Now, you know the number of lamps &amp; cost of every single unit of lamp for each category. But the problem is,you are to buy equivalent voltage sources for all the lamp categories. You can buy a single voltage source for each category (Each source is capable of supplying to infinite number of lamps of its voltage rating.) &amp; complete the design. But the accounts section of your company soon figures out that they might be able to reduce the total system cost by eliminating some of the voltage sources &amp; replacing the lamps of that category with higher rating lamps. Certainly you can never replace a lamp by a lower rating lamp as some portion of the hall might not be illuminated then. You are more concerned about money-saving than energy-saving. Find the minimum possible cost to design the system.</p>
<p><strong>Input</strong></p>
<hr>
<p>Each case in the input begins with n (1&lt;&#x3D;n&lt;&#x3D;1000), denoting the number of categories. Each of the following n lines describes a category. A category is described by 4 integers -<strong>V</strong>(1&lt;&#x3D;V&lt;&#x3D;132000), the voltage rating, K (1&lt;&#x3D;K&lt;&#x3D;1000), the cost of a voltage source of this rating, C (1&lt;&#x3D;C&lt;&#x3D;10), the cost of a lamp of this rating &amp; L (1&lt;&#x3D;L&lt;&#x3D;100), the number of lamps required in this category. The input terminateswitha test case where n &#x3D; 0. This case should not be processed.</p>
<p><strong>Output</strong></p>
<hr>
<p>For each test case, print the minimum possible cost to design the system.</p>
<p><strong>Sample Input Output for Sample Input</strong><br>3</p>
<p>100 500 10 20</p>
<p>120 600 8 16</p>
<p>220 400 7 18</p>
<p>0</p>
<p>778</p>
<p>﻿﻿</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 11584 Partitioning by Palindromes(DP 最少对称串)</title>
    <url>/posts/oj/dp/UVa%2011584%20Partitioning%20by%20Palindromes(DP%20%E6%9C%80%E5%B0%91%E5%AF%B9%E7%A7%B0%E4%B8%B2)/</url>
    <content><![CDATA[<p>题意 判断一个串最少可以分解为多少个对称串 一个串从左往后和从右往左是一样的 这个串就称为对沉串</p>
<p>令d[i]表示给定串的前i个字母至少可以分解为多少个对称串 那么对于j&#x3D;1~i 若(i,j)是一个对称串 那么有 d[i]&#x3D;min(d[i],d[j-1]+1) 然后就得到答案了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line">int d[N]; char s[N];</span><br><span class="line">bool isPal (int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (a &lt;= b &amp;&amp; s[a] == s[b])</span><br><span class="line">        ++a, --b;</span><br><span class="line">    <span class="keyword">return</span> a &gt;= b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas, l;</span><br><span class="line">    scanf (<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">for</span> (int ca = <span class="number">1</span>; ca &lt;= cas; ++ca)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf (<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">        l = strlen (s + <span class="number">1</span>);</span><br><span class="line">        memset (d, <span class="number">0x3f</span>, sizeof (d));</span><br><span class="line">        d[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= l; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">                <span class="keyword">if</span> (isPal (j, i))  d[i] = min (d[i], d[j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        printf (<span class="string">&quot;%d\n&quot;</span>, d[l]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Partitioning-by-Palindromes"><a href="#Partitioning-by-Palindromes" class="headerlink" title="Partitioning by Palindromes"></a>Partitioning by Palindromes</h2><p><img src="/../images/dge.org-external-115-p11584-.png" alt="Can you read upside-down?"></p>
<p>We say a sequence of characters is a <em>palindrome</em>if it is the same written forwards and backwards. For example, ‘racecar’ is a palindrome, but ‘fastcar’ is not.</p>
<p>A <em>partition</em> of a sequence of characters is a list of one or more disjoint non-empty groups of consecutive characters whose concatenation yields the initial sequence. For example, (‘race’, ‘car’) is a partition of ‘racecar’ into two groups.</p>
<p>Given a sequence of characters, we can always create a partition of these characters such that each group in the partition is a palindrome! Given this observation it is natural to ask: what is the minimum number of groups needed for a given string such that every group is a palindrome?</p>
<p>For example:</p>
<p>Input begins with the number <em>n</em> of test cases. Each test case consists of a single line of between 1 and 1000 lowercase letters, with no whitespace within.</p>
<p>For each test case, output a line containing the minimum number of groups required to partition the input into groups of palindromes.</p>
<p>3 racecar fastcar aaadbccb</p>
<p>1 7 3  Kevin Waugh</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 116 Unidirectional TSP(DP)</title>
    <url>/posts/oj/dp/UVa%20116%20Unidirectional%20TSP(DP)/</url>
    <content><![CDATA[<p>题意 一个n&#x2F;*m的环形矩阵(第一行和最后一行是相邻的) 从第一列任意位置出发 只能往右上,右,右下3个方向走 求走到第m列经过的的最小数字和</p>
<p>基础DP 横着的数塔问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">#define <span class="title function_">l</span>(x) d[x][j+<span class="number">1</span>]</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">105</span>;</span><br><span class="line">int n, m, g[N][N], d[N][N], fol[N][N];</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, m, u, b, t, k;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">                <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;g[i][j]);</span><br><span class="line"></span><br><span class="line">        <span class="title function_">memset</span>(d, <span class="number">0x3f</span>, <span class="title function_">sizeof</span>(d));</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i) d[i][m - <span class="number">1</span>] = g[i][m - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(int j = m - <span class="number">2</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                u = (i + n - <span class="number">1</span>) % n, b = (i + <span class="number">1</span>) % n, t = i;</span><br><span class="line">                <span class="keyword">if</span>(<span class="title function_">l</span>(u) &lt; <span class="title function_">l</span>(t) || (<span class="title function_">l</span>(u) == <span class="title function_">l</span>(t) &amp;&amp; u &lt; t)) t = u;</span><br><span class="line">                <span class="keyword">if</span>(<span class="title function_">l</span>(b) &lt; <span class="title function_">l</span>(t) || (<span class="title function_">l</span>(b) == <span class="title function_">l</span>(t) &amp;&amp; b &lt; t)) t = b;</span><br><span class="line">                d[i][j] = g[i][j] + d[t][j + <span class="number">1</span>], fol[i][j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(int i = k = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(d[i][<span class="number">0</span>] &lt; d[k][<span class="number">0</span>] || (d[i][<span class="number">0</span>] == d[k][<span class="number">0</span>] &amp;&amp; i &lt; k)) k = i;</span><br><span class="line">        int ans = d[k][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; m - <span class="number">1</span>; ++j) <span class="title function_">printf</span>(<span class="string">&quot;%d &quot;</span>, k + <span class="number">1</span>), k = fol[k][j];</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n%d\n&quot;</span>, k + <span class="number">1</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Problems that require minimum paths through some domain appear in many different areas of computer science. For example, one of the constraints in VLSI routing problems is minimizing wire length. The Traveling Salesperson Problem (TSP) – finding whether all the cities in a salesperson’s route can be visited exactly once with a specified limit on travel time – is one of the canonical examples of an NP-complete problem; solutions appear to require an inordinate amount of time to generate, but are simple to check.</p>
<p>This problem deals with finding a minimal path through a grid of points while traveling only from left to right.</p>
<h2 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h2><p>Given an <img src="/../images/dge.org-external-1-116img1.gif.png" alt="tex2html_wrap_inline352"> matrix of integers, you are to write a program that computes a path of minimal weight. A path starts anywhere in column 1 (the first column) and consists of a sequence of steps terminating in column <em>n</em> (the last column). A step consists of traveling from column <em>i</em> to column <em>i</em>+1 in an adjacent (horizontal or diagonal) row. The first and last rows (rows 1 and <em>m</em>) of a matrix are considered adjacent, i.e., the matrix &#96;&#96;wraps’’ so that it represents a horizontal cylinder. Legal steps are illustrated below.</p>
<p><img src="/../images/dge.org-external-1-116img2.gif.png" alt="picture25"></p>
<p>The <em>weight</em> of a path is the sum of the integers in each of the <em>n</em> cells of the matrix that are visited.</p>
<p>For example, two slightly different <img src="/../images/dge.org-external-1-116img3.gif.png" alt="tex2html_wrap_inline366"> matrices are shown below (the only difference is the numbers in the bottom row).</p>
<p><img src="/../images/dge.org-external-1-116img4.gif.png" alt="picture37"></p>
<p>The minimal path is illustrated for each matrix. Note that the path for the matrix on the right takes advantage of the adjacency property of the first and last rows.</p>
<h2 id="The-Input"><a href="#The-Input" class="headerlink" title="The Input"></a>The Input</h2><p>The input consists of a sequence of matrix specifications. Each matrix specification consists of the row and column dimensions in that order on a line followed by <img src="/../images/dge.org-external-1-116img5.gif.png" alt="tex2html_wrap_inline376"> integers where <em>m</em> is the row dimension and <em>n</em> is the column dimension. The integers appear in the input in row major order, i.e., the first <em>n</em> integers constitute the first row of the matrix, the second <em>n</em> integers constitute the second row and so on. The integers on a line will be separated from other integers by one or more spaces. Note: integers are not restricted to being positive. There will be one or more matrix specifications in an input file. Input is terminated by end-of-file.</p>
<p>For each specification the number of rows will be between 1 and 10 inclusive; the number of columns will be between 1 and 100 inclusive. No path’s weight will exceed integer values representable using 30 bits.</p>
<h2 id="The-Output"><a href="#The-Output" class="headerlink" title="The Output"></a>The Output</h2><p>Two lines should be output for each matrix specification in the input file, the first line represents a minimal-weight path, and the second line is the cost of a minimal path. The path consists of a sequence of <em>n</em> integers (separated by one or more spaces) representing the rows that constitute the minimal path. If there is more than one path of minimal weight the path that is<em>lexicographically</em> smallest should be output.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>5 6 3 4 1 2 8 6 6 1 8 2 7 4 5 9 3 9 9 5 8 4 1 3 2 6 3 7 2 8 6 4 5 6 3 4 1 2 8 6 6 1 8 2 7 4 5 9 3 9 9 5 8 4 1 3 2 6 3 7 2 1 2 3 2 2 9 10 9 10</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>1 2 3 4 4 5 16 1 2 1 5 4 5 11 1 1 19</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 12563 Jin Ge Jin Qu hao(01背包)</title>
    <url>/posts/oj/dp/UVa%2012563%20Jin%20Ge%20Jin%20Qu%20hao(01%E8%83%8C%E5%8C%85)/</url>
    <content><![CDATA[<p>题意 你在KTV还剩t秒钟的时间 你需要在n首歌中选择尽量多的歌使得歌的数量最多的前提下剩下的时间最小</p>
<p>至少要留一秒给劲歌金曲 所以是一个容量为t-1的01背包 d[i][j]表示恰用j秒时间在前i首歌中最多唱多少首 每个状态有两种选择 唱或不唱第i首歌</p>
<p>所以有转移方程<strong>d[i][j]&#x3D;max(d[i-1][j],d[i-1][j-c[i]]+1)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">55</span>, M = <span class="number">180</span>;</span><br><span class="line">int c[N], d[N * M], t, n;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas, ans;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">for</span>(int k = <span class="number">1</span>; k &lt;= cas; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">memset</span>(d, <span class="number">0x8f</span>, <span class="title function_">sizeof</span>(d));</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;t);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i) <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);</span><br><span class="line">        d[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(int j = t - <span class="number">1</span>; j &gt;= c[i]; --j)</span><br><span class="line">                d[j] = <span class="title function_">max</span>(d[j], d[j - c[i]] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(int j = ans = t - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) <span class="keyword">if</span>(d[j] &gt; d[ans]) ans = j;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;Case %d: %d %d\n&quot;</span>, k, d[ans] + <span class="number">1</span>, ans + <span class="number">678</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 1347 Tour(DP)</title>
    <url>/posts/oj/dp/UVa%201347%20Tour(DP)/</url>
    <content><![CDATA[<p>题意 二维坐标系上有n个点 从第一个点出发经过部分点到达第n个点 再从第n个点回到第一个点 除了第一个点 每个点都经过且仅经过一次 求最短路径长度</p>
<p>还是基础的DP 想出状态转移方程就容易了 d[i][j]表示去的时候经过第i个点回来经过第j个点且1~max(i,j)间的点都已经走过 显然d[i][j]&#x3D;d[j][i] 所以只用考虑i&gt;j的部分 i&lt;j的部分d[i][j]保存i,j两点之间的距离</p>
<p>第i+1个点要么去的时候走 要么回来的时候走</p>
<ol>
<li><p>去的时候走d[i+1][i] + d[i][i+1],d[i][i+1]保存的是距离</p>
</li>
<li><p>回来的时候走**d[i+1][j] + d[j][i+1].****d[i][i+1]**保存的是距离</p>
</li>
</ol>
<p>所以有状态转移方程<strong>d[i][j] &#x3D; min(d[i+1][i] + d[i][i+1],d[i+1][j] + d[j][j+1]).</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">#define <span class="title function_">l</span>(x) (x[i]-x[j])*(x[i]-x[j])</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">105</span>;</span><br><span class="line">int x[N], y[N];</span><br><span class="line">double d[N][N];</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x[i], &amp;y[i]);</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">                d[j][i] = <span class="title function_">sqrt</span>(<span class="title function_">l</span>(x) + <span class="title function_">l</span>(y));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) d[n - <span class="number">1</span>][i] = d[n - <span class="number">1</span>][n] + d[i][n];</span><br><span class="line">        <span class="keyword">for</span>(int i = n - <span class="number">2</span>; i &gt; <span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">                d[i][j] = <span class="title function_">min</span>(d[i + <span class="number">1</span>][j] + d[i][i + <span class="number">1</span>], d[i + <span class="number">1</span>][i] + d[j][i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, d[<span class="number">1</span>][<span class="number">2</span>] + d[<span class="number">2</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>John Doe, a skilled pilot, enjoys traveling. While on vacation, he rents a small plane and starts visiting beautiful places. To save money, John must determine the shortest closed tour that connects his destinations. Each destination is represented by a point in the plane <em>p</em>i &#x3D; &lt; *x*i, *y*i &gt; . John uses the following strategy: he starts from the leftmost point, then he goes strictly left to right to the rightmost point, and then he goes strictly right back to the starting point. It is known that the points have distinct <em>x</em> -coordinates.</p>
<p>Write a program that, given a set of <em>n</em> points in the plane, computes the shortest closed tour that connects the points according to John’s strategy.</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>The program input is from a text file. Each data set in the file stands for a particular set of points. For each set of points the data set contains the number of points, and the point coordinates in ascending order of the <em>x</em> coordinate. White spaces can occur freely in input. The input data are correct.</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>For each set of data, your program should print the result to the standard output from the beginning of a line. The tour length, a floating-point number with two fractional digits, represents the result.</p>
<p><strong>Note:</strong> An input&#x2F;output sample is in the table below. Here there are two data sets. The first one contains 3 points specified by their <em>x</em> and <em>y</em> coordinates. The second point, for example, has the <em>x</em>coordinate 2, and the <em>y</em> coordinate 3. The result for each data set is the tour length, (6.47 for the first data set in the given example).</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>3 1 1 2 3 3 1 4 1 1 2 3 3 1 4 2</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>6.47 7.89</p>
<hr>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 147 Dollars（DP完全背包）</title>
    <url>/posts/oj/dp/UVa%20147%20Dollars%EF%BC%88DP%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%EF%BC%89/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>很水的完全背包题 大家都会的 只是要注意把小数化为整数 不然精度丢失很严重；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long d[<span class="number">30005</span>];</span><br><span class="line">int val[<span class="number">12</span>]=&#123;<span class="number">10000</span>,<span class="number">5000</span>,<span class="number">2000</span>,<span class="number">1000</span>,<span class="number">500</span>,<span class="number">200</span>,<span class="number">100</span>,<span class="number">50</span>,<span class="number">20</span>,<span class="number">10</span>,<span class="number">5</span>&#125;,a;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    double fm;</span><br><span class="line">    d[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;<span class="number">11</span>;++i)</span><br><span class="line">        <span class="keyword">for</span>(int j=val[i];j&lt;=<span class="number">30000</span>;j+=<span class="number">5</span>)</span><br><span class="line">            d[j]+=d[j-val[i]];</span><br><span class="line">    <span class="keyword">while</span> (<span class="title function_">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;fm),a=<span class="title function_">int</span>(fm*<span class="number">100</span>+<span class="number">0.5</span>))</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%6.2lf%17lld\n&quot;</span>,fm,d[a]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><hr>
<p>New Zealand currency consists of $100, $50, $20, $10, and $5 notes and $2, $1, 50c, 20c, 10c and 5c coins. Write a program that will determine, for any given amount, in how many ways that amount may be made up. Changing the order of listing does not increase the count. Thus 20c may be made up in 4 ways: 1 <img src="/../images/dge.org-external-1-147img1.gif.png" alt="tex2html_wrap_inline25"> 20c, 2 <img src="/../images/dge.org-external-1-147img1.gif.png" alt="tex2html_wrap_inline25"> 10c, 10c+2 <img src="/../images/dge.org-external-1-147img1.gif.png" alt="tex2html_wrap_inline25"> 5c, and 4 <img src="/../images/dge.org-external-1-147img1.gif.png" alt="tex2html_wrap_inline25"> 5c.</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>Input will consist of a series of real numbers no greater than $300.00 each on a separate line. Each amount will be valid, that is will be a multiple of 5c. The file will be terminated by a line containing zero (0.00).</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>Output will consist of a line for each of the amounts in the input, each line consisting of the amount of money (with two decimal places and right justified in a field of width 6), followed by the number of ways in which that amount may be made up, right justified in a field of width 17.</p>
<h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><p>0.20 2.00 0.00</p>
<h2 id="-5"><a href="#-5" class="headerlink" title=""></a></h2><p>0.20 4 2.00 293</p>
<p>﻿﻿</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 348 Optimal Array Multiplication Sequence (DP 最优矩阵链乘)</title>
    <url>/posts/oj/dp/UVa%20348%20Optimal%20Array%20Multiplication%20Sequence%20(DP%20%E6%9C%80%E4%BC%98%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98)/</url>
    <content><![CDATA[<p>﻿﻿</p>
<p>题意 求给定数目矩阵的最优链乘 并输出路径</p>
<p>矩阵链乘在小白第二版 P277有讲解 也是经典的动态规划 有了转移方程题目就好做了 设d[i][j]为矩阵i到矩阵j的最优链乘 初始状态d[i][i]&#x3D;0 k为i，j之间的一个矩阵 x[i],y[i]分别表示第i个矩阵的行和列 则有d[i][j]&#x3D;min{d[i][k]+d[k+1][j]+x[i]&#x2F;*y[k]&#x2F;*y[j]}<br>感觉这题比较难的就是路径打印了 仔细观察一下结构 其实也不难 记录每个k值 直接递归就行了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;  </span><br><span class="line">#include&lt;cstring&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line">#define maxn <span class="number">11</span>  </span><br><span class="line">#define <span class="variable constant_">INF</span> <span class="number">0x3f3f3f3f</span>  </span><br><span class="line">#define t <span class="title function_">dp</span>(i,k)+<span class="title function_">dp</span>(k+<span class="number">1</span>,j)+x[i]*y[k]*y[j]  </span><br><span class="line">int d[maxn][maxn],pre[maxn][maxn],x[maxn],y[maxn],n;  </span><br><span class="line">int <span class="title function_">dp</span>(<span class="params">int i,int j</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span>(d[i][j]&lt;<span class="variable constant_">INF</span>) <span class="keyword">return</span> d[i][j];  </span><br><span class="line">    <span class="keyword">for</span>(int k=i; k&lt;j; ++k)  </span><br><span class="line">        <span class="keyword">if</span>(d[i][j]&gt;t)  </span><br><span class="line">        &#123;  </span><br><span class="line">            d[i][j]=t;  </span><br><span class="line">            pre[i][j]=k;  </span><br><span class="line">        &#125;  </span><br><span class="line">    <span class="keyword">return</span> d[i][j];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span>(<span class="params">int i,int j</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    int k=pre[i][j];  </span><br><span class="line">    <span class="keyword">if</span>(k)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;(&quot;</span>);  </span><br><span class="line">        <span class="title function_">print</span>(i,k);  </span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot; x &quot;</span>);  </span><br><span class="line">        <span class="title function_">print</span>(k+<span class="number">1</span>,j);  </span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;)&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;A%d&quot;</span>,i);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    int k=<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),n)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="title function_">memset</span>(d,<span class="number">0x3f</span>,<span class="title function_">sizeof</span>(d));  </span><br><span class="line">        <span class="title function_">memset</span>(pre,<span class="number">0</span>,<span class="title function_">sizeof</span>(pre));  </span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>; i&lt;=n; ++i)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x[i],&amp;y[i]);  </span><br><span class="line">            d[i][i]=<span class="number">0</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="title function_">dp</span>(<span class="number">1</span>,n);  </span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;Case %d: &quot;</span>,k);  </span><br><span class="line">        <span class="title function_">print</span>(<span class="number">1</span>,n);  </span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">        k++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p>Given two arrays <em>A</em> and <em>B</em>, we can determine the array <em>C</em> &#x3D; <em>A B</em> using the standard definition of matrix multiplication:</p>
<p><img src="/../images/dge.org-external-3-348img13.gif.png"></p>
<p>The number of columns in the <em>A</em> array must be the same as the number of rows in the <em>B</em> array. Notationally, let’s say that <em>rows</em>(<em>A</em>) and <em>columns</em>(<em>A</em>) are the number of rows and columns, respectively, in the <em>A</em> array. The number of individual multiplications required to compute the entire <em>C</em> array (which will have the same number of rows as <em>A</em> and the same number of columns as <em>B</em>) is then <em>rows</em>(<em>A</em>)<em>columns</em>(<em>B</em>) <em>columns</em>(<em>A</em>). For example, if <em>A</em> is a <img src="/../images/dge.org-external-3-348img1.gif.png" alt="tex2html_wrap_inline67"> array, and <em>B</em> is a <img src="/../images/dge.org-external-3-348img2.gif.png" alt="tex2html_wrap_inline71"> array, it will take<img src="/../images/dge.org-external-3-348img3.gif.png" alt="tex2html_wrap_inline73"> , or 3000 multiplications to compute the <em>C</em> array.</p>
<p>To perform multiplication of more than two arrays we have a choice of how to proceed. For example, if <em>X</em>, <em>Y</em>, and <em>Z</em> are arrays, then to compute <em>X Y Z</em> we could either compute (<em>X Y</em>) <em>Z</em> or <em>X</em> (<em>Y Z</em>). Suppose <em>X</em>is a <img src="/../images/dge.org-external-3-348img4.gif.png" alt="tex2html_wrap_inline103"> array, <em>Y</em> is a <img src="/../images/dge.org-external-3-348img1.gif.png" alt="tex2html_wrap_inline67"> array, and <em>Z</em> is a <img src="/../images/dge.org-external-3-348img5.gif.png" alt="tex2html_wrap_inline111"> array. Let’s look at the number of multiplications required to compute the product using the two different sequences:</p>
<p>(<em>X Y</em>) <em>Z</em></p>
<p><em>X</em> (<em>Y Z</em>)</p>
<p>Clearly we’ll be able to compute (<em>X Y</em>) <em>Z</em> using fewer individual multiplications.</p>
<p>Given the size of each array in a sequence of arrays to be multiplied, you are to determine an optimal computational sequence. Optimality, for this problem, is relative to the number of individual multiplications required.</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>For each array in the multiple sequences of arrays to be multiplied you will be given only the dimensions of the array. Each sequence will consist of an integer <em>N</em> which indicates the number of arrays to be multiplied, and then <em>N</em> pairs of integers, each pair giving the number of rows and columns in an array; the order in which the dimensions are given is the same as the order in which the arrays are to be multiplied. A value of zero for <em>N</em> indicates the end of the input. <em>N</em> will be no larger than 10.</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>Assume the arrays are named <img src="/../images/dge.org-external-3-348img12.gif.png" alt="tex2html_wrap_inline157"> . Your output for each input case is to be a line containing a parenthesized expression clearly indicating the order in which the arrays are to be multiplied. Prefix the output for each case with the case number (they are sequentially numbered, starting with 1). Your output should strongly resemble that shown in the samples shown below. If, by chance, there are multiple correct sequences, any of these will be accepted as a valid answer.</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>3 1 5 5 20 20 1 3 5 10 10 20 20 35 6 30 35 35 15 15 5 5 10 10 20 20 25 0</p>
<h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><p>Case 1: (A1 x (A2 x A3)) Case 2: ((A1 x A2) x A3) Case 3: ((A1 x (A2 x A3)) x ((A4 x A5) x A6))</p>
<p>﻿﻿</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 437 The Tower of Babylon(DP 最长条件子序列)</title>
    <url>/posts/oj/dp/UVa%20437%20The%20Tower%20of%20Babylon(DP%20%E6%9C%80%E9%95%BF%E6%9D%A1%E4%BB%B6%E5%AD%90%E5%BA%8F%E5%88%97)/</url>
    <content><![CDATA[<p>﻿﻿</p>
<p>题意 给你n种长方体 每种都有无穷个 当一个长方体的长和宽都小于另一个时 这个长方体可以放在另一个上面 要求输出这样累积起来的最大高度</p>
<p>因为每个长方体都有3种放法 比较不好控制 可以把一个长宽高分成三个长方体 高度是固定的 这样就比较好控制了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;  </span><br><span class="line">#include&lt;cstring&gt;  </span><br><span class="line">#include&lt;algorithm&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line">#define maxn <span class="number">105</span>  </span><br><span class="line">int x[maxn], y[maxn], z[maxn], d[maxn], n;  </span><br><span class="line">int <span class="title function_">dp</span>(<span class="params">int i</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span>(d[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> d[i];  </span><br><span class="line">    d[i] = z[i];  </span><br><span class="line">    <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= n; ++j)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>((x[i] &gt; x[j] &amp;&amp; y[i] &gt; y[j]) || (x[i] &gt; y[j] &amp;&amp; y[i] &gt; x[j]))  </span><br><span class="line">            d[i] = <span class="title function_">max</span>(d[i], <span class="title function_">dp</span>(j) + z[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> d[i];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    int a, b, c, cas = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">while</span> (<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)  </span><br><span class="line">    &#123;  </span><br><span class="line">        n *= <span class="number">3</span>;  </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n;)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);  </span><br><span class="line">            x[i] = a; y[i] = b; z[i++] = c;  </span><br><span class="line">            x[i] = a; y[i] = c; z[i++] = b;  </span><br><span class="line">            x[i] = b; y[i] = c; z[i++] = a;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        int ans = <span class="number">0</span>;  </span><br><span class="line">        <span class="title function_">memset</span>(d, <span class="number">0</span>, <span class="title function_">sizeof</span>(d));  </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)  </span><br><span class="line">            ans = <span class="title function_">max</span>(<span class="title function_">dp</span>(i), ans);  </span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;Case %d: maximum height = %d\n&quot;</span>, cas, ans);  </span><br><span class="line">  </span><br><span class="line">        cas++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p>Perhaps you have heard of the legend of the Tower of Babylon. Nowadays many details of this tale have been forgotten. So now, in line with the educational nature of this contest, we will tell you the whole story:</p>
<p>The babylonians had <em>n</em> types of blocks, and an unlimited supply of blocks of each type. Each type-<em>i</em> block was a rectangular solid with linear dimensions <img src="/../images/dge.org-external-4-437img1.gif.png" alt="tex2html_wrap_inline32"> . A block could be reoriented so that any two of its three dimensions determined the dimensions of the base and the other dimension was the height. They wanted to construct the tallest tower possible by stacking blocks. The problem was that, in building a tower, one block could only be placed on top of another block as long as the two base dimensions of the upper block were both strictly smaller than the corresponding base dimensions of the lower block. This meant, for example, that blocks oriented to have equal-sized bases couldn’t be stacked.</p>
<p>Your job is to write a program that determines the height of the tallest tower the babylonians can build with a given set of blocks.</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>The input file will contain one or more test cases. The first line of each test case contains an integer <em>n</em>, representing the number of different blocks in the following data set. The maximum value for <em>n</em> is 30. Each of the next <em>n</em> lines contains three integers representing the values <img src="/../images/dge.org-external-4-437img2.gif.png" alt="tex2html_wrap_inline40"> , <img src="/../images/dge.org-external-4-437img3.gif.png" alt="tex2html_wrap_inline42"> and <img src="/../images/dge.org-external-4-437img4.gif.png" alt="tex2html_wrap_inline44"> .</p>
<p>Input is terminated by a value of zero (0) for <em>n</em>.</p>
<p>For each test case, print one line containing the case number (they are numbered sequentially starting from 1) and the height of the tallest possible tower in the format “Case <em>case</em>: maximum height &#x3D; <em>height</em>“</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>1 10 20 30 2 6 8 10 5 5 5 7 1 1 1 2 2 2 3 3 3 4 4 4 5 5 5 6 6 6 7 7 7 5 31 41 59 26 53 58 97 93 23 84 62 64 33 83 27 0</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>Case 1: maximum height &#x3D; 40 Case 2: maximum height &#x3D; 21 Case 3: maximum height &#x3D; 28 Case 4: maximum height &#x3D; 342</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 531 Compromise （DP 最长公共子序列）</title>
    <url>/posts/oj/dp/UVa%20531%20Compromise%20%EF%BC%88DP%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%89/</url>
    <content><![CDATA[<p>题意 求两段文本的最长公共子单词序列</p>
<p>还是最长公共子序列 只是现在是单词不是一个字母了 用字符串数组保存 还是一样的处理 注意结果的打印和输入的处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define M <span class="number">105</span></span><br><span class="line">using namespace std;</span><br><span class="line">char a[M][<span class="number">32</span>],b[M][<span class="number">32</span>];</span><br><span class="line">int d[M][M],flag[M][M],la,lb;</span><br><span class="line">bool <span class="title class_">Isfirst</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lcs</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">memset</span>(d,<span class="number">0</span>,<span class="title function_">sizeof</span>(d));</span><br><span class="line">    <span class="title function_">memset</span>(flag,<span class="number">0</span>,<span class="title function_">sizeof</span>(flag));</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>; i&lt;=la; ++i)</span><br><span class="line">        <span class="keyword">for</span>(int j=<span class="number">1</span>; j&lt;=lb; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="title function_">strcmp</span>(a[i],b[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                d[i][j]=d[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                flag[i][j]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(d[i-<span class="number">1</span>][j]&gt;d[i][j-<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                d[i][j]=d[i-<span class="number">1</span>][j];</span><br><span class="line">                flag[i][j]=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                d[i][j]=d[i][j-<span class="number">1</span>];</span><br><span class="line">                flag[i][j]=<span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span>(<span class="params">int i,int j</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||j&lt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title class_">Isfirst</span>=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag[i][j]==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">print</span>(i-<span class="number">1</span>,j-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Isfirst</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;%s&quot;</span>,a[i]);</span><br><span class="line">            <span class="title class_">Isfirst</span>=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="title function_">printf</span>(<span class="string">&quot; %s&quot;</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(flag[i][j]==<span class="number">2</span>)</span><br><span class="line">        <span class="title function_">print</span>(i-<span class="number">1</span>,j);</span><br><span class="line">    <span class="keyword">else</span> <span class="title function_">print</span>(i,j-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    char t[M];</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>,a[<span class="number">1</span>])!=<span class="variable constant_">EOF</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        la=<span class="number">1</span>;</span><br><span class="line">        lb=<span class="number">0</span>;</span><br><span class="line">        bool <span class="title class_">Isfirst</span>=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>,t),t[<span class="number">0</span>]!=<span class="string">&#x27;#&#x27;</span>) <span class="title function_">strcpy</span>(a[++la],t);</span><br><span class="line">        <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>,t),t[<span class="number">0</span>]!=<span class="string">&#x27;#&#x27;</span>) <span class="title function_">strcpy</span>(b[++lb],t);</span><br><span class="line">        <span class="title function_">lcs</span>();</span><br><span class="line">        <span class="title function_">print</span>(la,lb);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>In a few months the European Currency Union will become a reality. However, to join the club, the Maastricht criteria must be fulfilled, and this is not a trivial task for the countries (maybe except for Luxembourg). To enforce that Germany will fulfill the criteria, our government has so many wonderful options (raise taxes, sell stocks, revalue the gold reserves,…) that it is really hard to choose what to do.</p>
<p>Therefore the German government requires a program for the following task:</p>
<p>Two politicians each enter their proposal of what to do. The computer then outputs the longest common subsequence of words that occurs in both proposals. As you can see, this is a totally fair compromise (after all, a common sequence of words is something what both people have in mind).</p>
<p>Your country needs this program, so your job is to write it for us.</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>The input file will contain several test cases.</p>
<p>Each test case consists of two texts. Each text is given as a sequence of lower-case words, separated by whitespace, but with no punctuation. Words will be less than 30 characters long. Both texts will contain less than 100 words and will be terminated by a line containing a single ‘&#x2F;#’.</p>
<p>Input is terminated by end of file.</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>For each test case, print the longest common subsequence of words occuring in the two texts. If there is more than one such sequence, any one is acceptable. Separate the words by one blank. After the last word, output a newline character.</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>die einkommen der landwirte sind fuer die abgeordneten ein buch mit sieben siegeln um dem abzuhelfen muessen dringend alle subventionsgesetze verbessert werden &#x2F;# die steuern auf vermoegen und einkommen sollten nach meinung der abgeordneten nachdruecklich erhoben werden dazu muessen die kontrollbefugnisse der finanzbehoerden dringend verbessert werden &#x2F;#</p>
<h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><p>die einkommen der abgeordneten muessen dringend verbessert werden</p>
<p>﻿﻿</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 620 Cellular Structure(DP)</title>
    <url>/posts/oj/dp/UVa%20620%20Cellular%20Structure(DP)/</url>
    <content><![CDATA[<p>题意 有A,B两种细胞 A细胞可由空生成 非空细胞链有两种增长方式 设O为原非空细胞链 则O可增长为OAB或BOA给你一个细胞链 若其是合法分裂的 要求判断最后一次分裂是哪种方式 无法得到的输出MUTANT</p>
<p>若给定的S是以AB结尾的 判断去掉AB的部分是否合法即可 若S是B开始A结束的 判断去掉首尾是否合法即可；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;  </span><br><span class="line">#include &lt;cstring&gt;  </span><br><span class="line">char s[<span class="number">10000</span>];  </span><br><span class="line">bool <span class="title function_">dp</span>(<span class="params">int i, int j</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span> (i == j)  </span><br><span class="line">        <span class="keyword">return</span> s[i] == <span class="string">&#x27;A&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s[j - <span class="number">1</span>] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[j] == <span class="string">&#x27;B&#x27;</span>)  </span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">dp</span>(i, j - <span class="number">2</span>);  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;B&#x27;</span> &amp;&amp; s[j] == <span class="string">&#x27;A&#x27;</span>)  </span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">dp</span>(i + <span class="number">1</span>, j - <span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    int t;  </span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);  </span><br><span class="line">    <span class="keyword">while</span> (t--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);  </span><br><span class="line">        int l = <span class="title function_">strlen</span>(s + <span class="number">1</span>);  </span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_">strcmp</span>(s, <span class="string">&quot;A&quot;</span>))  </span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;SIMPLE\n&quot;</span>);  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[l - <span class="number">1</span>] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[l] == <span class="string">&#x27;B&#x27;</span> &amp;&amp; <span class="title function_">dp</span>(<span class="number">1</span>, l - <span class="number">2</span>))  </span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;FULLY-GROWN\n&quot;</span>);  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">&#x27;B&#x27;</span> &amp;&amp; s[l] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; <span class="title function_">dp</span>(<span class="number">2</span>, l - <span class="number">1</span>))  </span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;MUTAGENIC\n&quot;</span>);  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;MUTANT\n&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p>A chain of connected cells of two types A and B composes a cellular structure of some microorganisms of species APUDOTDLS.</p>
<p>If no mutation had happened during growth of an organism, its cellular chain would take one of the following forms:</p>
<p>simple stage O &#x3D; A fully-grown stage O &#x3D; OAB mutagenic stage O &#x3D; BOA</p>
<p>Sample notation O &#x3D; OA means that if we added to chain of a healthy organism a cell A from the right hand side, we would end up also with a chain of a healthy organism. It would grow by one cell A.</p>
<p>A laboratory researches a cluster of these organisms. Your task is to write a program which could find out a current stage of growth and health of an organism, given its cellular chain sequence.</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>A integer<em>n</em>being a number of cellular chains to test, and then<em>n</em>consecutive lines containing chains of tested organisms.</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>For each tested chain give (in separate lines) proper answers:</p>
<p>SIMPLE for simple stage FULLY-GROWN for fully-grown stage MUTAGENIC for mutagenic stage MUTANT any other (in case of mutated organisms)</p>
<p>If an organism were in two stages of growth at the same time the first option from the list above should be given as an answer.</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>4 A AAB BAAB BAABA</p>
<h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><p>SIMPLE FULLY-GROWN MUTANT MUTAGENIC</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 624 CD （DP 01背包）</title>
    <url>/posts/oj/dp/UVa%20624%20CD%20%EF%BC%88DP%2001%E8%83%8C%E5%8C%85%EF%BC%89/</url>
    <content><![CDATA[<p>题意 你要把CD上的歌录到tape上 使得剩余磁带空间最小 很容易看出是01背包问题 输出路径也很容易 直接递归</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int s,n,val[<span class="number">30</span>],d[<span class="number">1000005</span>],pre[<span class="number">1000005</span>];</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span>(<span class="params">int i</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">print</span>(pre[i]);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d &quot;</span>,i-pre[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;s,&amp;n)!=<span class="variable constant_">EOF</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">memset</span>(d,<span class="number">0</span>,<span class="title function_">sizeof</span>(d));</span><br><span class="line">        <span class="title function_">memset</span>(pre,<span class="number">0</span>,<span class="title function_">sizeof</span>(pre));</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val[i]);</span><br><span class="line">            <span class="keyword">for</span>(int j=s; j&gt;=val[i]; --j)</span><br><span class="line">                <span class="keyword">if</span>(d[j-val[i]]+val[i]&gt;d[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    d[j]=d[j-val[i]]+val[i];</span><br><span class="line">                    pre[j]=j-val[i];</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">print</span>(d[s]);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;sum:%d\n&quot;</span>,d[s]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>You have a long drive by car ahead. You have a tape recorder, but unfortunately your best music is on CDs. You need to have it on tapes so the problem to solve is: you have a tapeNminutes long. How to choose tracks from CD to get most out of tape space and have as short unused space as possible.</p>
<p>Assumptions:</p>
<p>Program should find the set of tracks which fills the tape best and print it in the same sequence as the tracks are stored on the CD</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>Any number of lines. Each one contains valueN, (after space) number of tracks and durations of the tracks. For example from first line in sample data:N&#x3D;5, number of tracks&#x3D;3, first track lasts for 1 minute, second one 3 minutes, next one 4 minutes</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>Set of tracks (and durations) which are the correct solutions and string &#96;&#96;sum:” and sum of duration times.</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>5 3 1 3 4 10 4 9 8 4 2 20 4 10 5 7 4 90 8 10 23 1 2 3 4 5 7 45 8 4 10 44 43 12 9 8 2</p>
<h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><p>1 4 sum:5 8 2 sum:10 10 5 4 sum:19 10 23 1 2 3 4 5 7 sum:55 4 10 12 9 8 2 sum:45</p>
<p>Miguel A. Revilla<br>2000-01-10</p>
<p>﻿﻿</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>ZOJ 3450 Doraemon&#39;s Railgun (DP·分组背包)</title>
    <url>/posts/oj/dp/ZOJ%203450%20Doraemon&#39;s%20Railgun%20(DP%C2%B7%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85)/</url>
    <content><![CDATA[<p>题意 多啦A梦有一个超电磁炮 然后要打死n堆敌人 在同一条射线上的敌人只有先打死前面的一堆才能打后面的一堆 给你打死某堆敌人需要的时间和这堆敌人的人数 问你在T0时间内最多打死多少个敌人</p>
<p>分组背包问题 先要把同一条射线上的敌人放到一个分组里后面的敌人的时间和人数都要加上前面所有的 因为只有前面的都打完了才能打后面的 然后每组最多只能选择一个判断共线用向量处理 然后去背包就行了</p>
<p>注意给你的样例可能出现t&#x3D;0的情况 在分组时需要处理一下 被这里卡了好久</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">505</span>;</span><br><span class="line">int vis[N], dp[<span class="number">10086</span>];</span><br><span class="line"></span><br><span class="line">struct enemy</span><br><span class="line">&#123;</span><br><span class="line">    ll x, y;</span><br><span class="line">    int t, w;</span><br><span class="line">&#125; e[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bool <span class="title function_">cmp</span>(enemy a, enemy b)  <span class="comment">//按与原点的距离排序</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="property">x</span> * a.<span class="property">x</span> + a.<span class="property">y</span> * a.<span class="property">y</span> &lt; b.<span class="property">x</span> * b.<span class="property">x</span> + b.<span class="property">y</span> * b.<span class="property">y</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool <span class="title function_">aLine</span>(int i, int j) <span class="comment">//判断是否在同一条射线上·</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(e[i].<span class="property">x</span> * e[j].<span class="property">y</span> == e[i].<span class="property">y</span> * e[j].<span class="property">x</span>)</span><br><span class="line">        <span class="keyword">return</span> e[i].<span class="property">x</span> * e[j].<span class="property">x</span> &gt;= <span class="number">0</span> &amp;&amp;  e[i].<span class="property">y</span> * e[j].<span class="property">y</span> &gt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    ll x, y, x0, y0;</span><br><span class="line">    int n, t0;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%lld%lld%d%d&quot;</span>, &amp;x0, &amp;y0, &amp;n, &amp;t0))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%lld%lld%d%d&quot;</span>, &amp;x, &amp;y, &amp;e[i].<span class="property">t</span>, &amp;e[i].<span class="property">w</span>);</span><br><span class="line">            e[i].<span class="property">x</span> = x - x0;</span><br><span class="line">            e[i].<span class="property">y</span> = y - y0;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">sort</span>(e, e + n, cmp);  <span class="comment">//按与原点的距离排序</span></span><br><span class="line"></span><br><span class="line">        vector&lt;enemy&gt; em[N];  <span class="comment">//把在一条射线上的放到一个分组里</span></span><br><span class="line">        <span class="title function_">memset</span>(vis, <span class="number">0</span>, <span class="title function_">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;  <span class="comment">//i已经在别的组里了</span></span><br><span class="line">            em[i].<span class="title function_">push_back</span>(e[i]);</span><br><span class="line">            <span class="keyword">for</span>(int j = i + <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="title function_">aLine</span>(i, j)) <span class="keyword">continue</span>;</span><br><span class="line">                int k = em[i].<span class="title function_">size</span>() - <span class="number">1</span>;</span><br><span class="line">                vis[j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(e[j].<span class="property">t</span> == <span class="number">0</span>)  <span class="comment">//把耗时为0的敌人放到上一个里</span></span><br><span class="line">                &#123;</span><br><span class="line">                    em[i][k].<span class="property">w</span> += e[j].<span class="property">w</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                em[i].<span class="title function_">push_back</span>(e[j]);</span><br><span class="line">                em[i][k + <span class="number">1</span>].<span class="property">w</span> += em[i][k].<span class="property">w</span>;</span><br><span class="line">                em[i][k + <span class="number">1</span>].<span class="property">t</span> += em[i][k].<span class="property">t</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">memset</span>(dp, <span class="number">0</span>, <span class="title function_">sizeof</span>(dp)); <span class="comment">//分组背包</span></span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            int k = em[i].<span class="title function_">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(int v = t0; v &gt;= <span class="number">0</span>; --v)</span><br><span class="line">                <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; k &amp;&amp; em[i][j].<span class="property">t</span> &lt;= v; ++j)</span><br><span class="line">                    dp[v] = <span class="title function_">max</span>(dp[v], dp[v - em[i][j].<span class="property">t</span>] + em[i][j].<span class="property">w</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[t0]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  Doraemon’s Railgun    Time Limit:2 Seconds Memory Limit:65536 KB    <img src="/../images/cn-onlinejudge-showImage.do-name=toaru-dorano-railgun-.png" alt="toaru-dorano-railgun"></p>
<p>Doraemon’s city is being attacked again. This time Doraemon has built a powerful railgun in the city. So he will use it to attack enemy outside the city.</p>
<p>There are <em>N</em> groups of enemy. Now each group is staying outside of the city. Group <em>i</em> is located at different (<em>X</em>i, <em>Y</em>i) and contains <em>W</em>i soldiers. After T0 days, all the enemy will begin to attack the city. Before it, the railgun can fire artillery shells to them.</p>
<p>The railgun is located at (X0, Y0), which can fire one group at one time, The artillery shell will fly straightly to the enemy. But in case there are several groups in a straight line, the railgun can only eliminate the nearest one first if Doraemon wants to attack further one. It took <em>T</em>i days to eliminate group <em>i</em>. Now please calculate the maximum number of soldiers it can eliminate.</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>There are multiple cases. At the first line of each case, there will be four integers, X0, Y0, <em>N</em>, T0 (-1000000000 ≤ X0, Y0 ≤ 1000000000; 1 ≤ <em>N</em> ≤ 500; 1 ≤ T0 ≤ 10000). Next <em>N</em> lines follow, each line contains four integers, <em>X</em>i, <em>Y</em>i, <em>T</em>i, <em>W</em>i (-1000000000 ≤ <em>X</em>i, <em>Y</em>i ≤ 1000000000; 0 ≤ <em>T</em>i, <em>W</em>i ≤ 10000).</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>For each case, output one integer, which is the maximum number of soldiers the railgun can eliminate.</p>
<h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h4><p>0 0 5 10 0 5 2 3 0 10 2 8 3 2 4 6 6 7 3 9 4 4 10 2</p>
<h4 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h4><p>20</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>ZOJ 3699 Dakar Rally(贪心)</title>
    <url>/posts/oj/dp/ZOJ%203699%20Dakar%20Rally(%E8%B4%AA%E5%BF%83)/</url>
    <content><![CDATA[<p>题意 路上有 n 个加油站 每个加油站的价格可能不同 你的油箱容积为 v 问从起点开车到终点加油至少用多少钱</p>
<p>贪心 每次都让油箱里面便宜的油最多就行了 在每个站点 i 有两种情况</p>
<ol>
<li><p>i 点把油加满跑完都没有更便宜的 那么在 i 点肯定要加满 然后开到 i+1 点去</p>
</li>
<li><p>i 点把油加满能跑到第一个比 i 点更便宜的 j 点或者到了终点 j 那么只用把油加到能到 j 点 然后直接开到 j 点</p>
</li>
</ol>
<p>然后把每个点加油用的钱加起来就行了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">100005</span>;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll len[N], cost[N], pri[N], v;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int T, n;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>, &amp;n, &amp;v);</span><br><span class="line">        int flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;len[i], &amp;cost[i], &amp;pri[i]);</span><br><span class="line">            <span class="keyword">if</span>(len[i] * cost[i] &gt; v) flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">puts</span>(<span class="string">&quot;Impossible&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int i = <span class="number">0</span>, j;</span><br><span class="line">        ll r = <span class="number">0</span>, ans = <span class="number">0</span>, t;                 <span class="comment">//r记录到i点还剩多少油</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            j = i + <span class="number">1</span>, t = len[i] * cost[i];  <span class="comment">//t记录到下一个便宜的点用了多少油</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//往前走直到找到一个更便宜的站j  或者油箱跑完</span></span><br><span class="line">            <span class="keyword">while</span>( j &lt; n &amp;&amp; pri[j] &gt;= pri[i] &amp;&amp; v - t &gt;= cost[j] * len[j])</span><br><span class="line">            &#123;</span><br><span class="line">                t += len[j] * cost[j];</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( j &gt;= n || pri[j] &lt; pri[i])  <span class="comment">//j点油第一个比i点便宜  加到能到j</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(r &gt; t)  r -= t;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ans += (t - r)  * pri[i];</span><br><span class="line">                    r = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                i = j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">//油跑完都没更便宜的 加满 到下一站</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans +=  (v - r) * pri[i];</span><br><span class="line">                r = v - len[i] * cost[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  Dakar Rally    Time Limit:2 Seconds Memory Limit:65536 KB</p>
<h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>The <strong>Dakar Rally</strong> is an annual Dakar Series rally raid type of off-road race, organized by the Amaury Sport Organization. The off-road endurance race consists of a series of routes. In different routes, the competitors cross dunes, mud, camel grass, rocks, erg and so on.</p>
<p>Because of the various circumstances, the mileages consume of the car and the prices of gas vary from each other. Please help the competitors to minimize their payment on gas.</p>
<p>Assume that the car begins with an empty tank and each gas station has infinite gas. The racers need to finish all the routes in order as the test case descripts.</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>There are multiple test cases. The first line of input contains an integer <em>T</em> (<em>T</em> ≤ 50) indicating the number of test cases. Then <em>T</em> test cases follow.</p>
<p>The first line of each case contains two integers: <em>n</em> – amount of routes in the race; <em>capacity</em> – the capacity of the tank.</p>
<p>The following <em>n</em> lines contain three integers each: <em>mileagei</em> – the mileage of the <em>ith</em> route; <em>consumei</em> – the mileage consume of the car in the <em>ith</em> route , which means the number of gas unit the car consumes in 1 mile; pricei – the price of unit gas in the gas station which locates at the beginning of the <em>ith</em> route.</p>
<p>All integers are positive and no more than 105.</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>For each test case, print the minimal cost to finish all of the <em>n</em> routes. If it’s impossible, print “Impossible” (without the quotes).</p>
<h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h4><p>2 2 30 5 6 9 4 7 10 2 30 5 6 9 4 8 10</p>
<h4 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h4><p>550 Impossible</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 115 Distinct Subsequences (DP)</title>
    <url>/posts/oj/dp/leetcode-115-distinct-subsequences/</url>
    <content><![CDATA[<p>这里通过 LeetCode 中的一道动态规划题目（<a href="https://leetcode.com/problems/distinct-subsequences">115. Distinct Subsequences</a>）来复习一下动态规划中的正反向递推和滚动数组的使用。</p>
<span id="more"></span>

<p>题意：输出字符串 S 中等于字符串 T 的子序列的个数。</p>
<p>分析：这是一道比较典型的动态规划题目，考虑状态：</p>
<p> <code>dp[i][j]</code> 表示字符串 <code>s[:i]</code> 中等于子序列 <code>t[:j]</code> 的个数</p>
<p>其中 <code>s[:i]</code> 表示字符串 S 的前 i 个字符构成的子串，<code>t[:j]</code> 表示字符串 T 的前 j 个字符构成的子串。那么有初始状态 <code>dp[0][0] = 1</code></p>
<p>首先  <code>dp[i][j]</code>  肯定可以由 <code>dp[i-1][j]</code> 转移，因为 <code>s[:i-1]</code> 的子序列肯定是 <code>s[i]</code> 的子序列；特别地，若 <code>s[i-1] == t[j-1]</code>，<code>dp[i][j]</code> 还可以由 <code>dp[i-1][j-1]</code> 转移。</p>
<p>那么不难写出逆向递推的方案：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">numDistinct</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    ls = <span class="built_in">len</span>(s)</span><br><span class="line">    lt = <span class="built_in">len</span>(t)</span><br><span class="line">    <span class="comment"># dp[i][j] for numDistinct(s[:i], t[:j])</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (lt+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ls+<span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, ls+<span class="number">1</span>):</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        ri = <span class="built_in">min</span>(lt, i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, ri+<span class="number">1</span>):</span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j]</span><br><span class="line">            <span class="keyword">if</span>(s[i-<span class="number">1</span>] == t[j-<span class="number">1</span>]):</span><br><span class="line">                dp[i][j] += dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[ls][lt]</span><br></pre></td></tr></table></figure>

<p>还有正向递推的方案：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">numDistinct</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    ls = <span class="built_in">len</span>(s)</span><br><span class="line">    lt = <span class="built_in">len</span>(t)</span><br><span class="line">    <span class="comment"># dp[i][j] for numDistinct(s[:i], t[:j])</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (lt+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ls+<span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ls):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(lt+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> j &gt; i:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            dp[i+<span class="number">1</span>][j] += dp[i][j]</span><br><span class="line">            <span class="keyword">if</span> j &lt; lt <span class="keyword">and</span> s[i] == t[j]:</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] += dp[i][j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[ls][lt]</span><br></pre></td></tr></table></figure>

<p>考虑到 <code>dp[i][j]</code> 只依赖 <code>dp[i-1][j-1]</code> 和 <code>dp[i-1]][j]</code>，实际上没必要使用二维数组来存储状态。利用滚动数组的性质，只使用一维数组就可以。 j 从后往前递推时，可以让 <code>dp[j]</code> 在第 i 次循环中表示 <code>dp[i][j]</code>，而 <code>dp[j-1]</code> 则表示 <code>dp[i-1][j-1]</code>，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">numDistinct</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    ls = <span class="built_in">len</span>(s)</span><br><span class="line">    lt = <span class="built_in">len</span>(t)</span><br><span class="line">    <span class="comment"># dp[i][j] for numDistinct(s[:i], t[:j])</span></span><br><span class="line">    dp = [<span class="number">1</span>] + [<span class="number">0</span>] * lt  <span class="comment"># dp[0][0] = 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, ls+<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># if j &gt; i, dp[i][j] must be zero</span></span><br><span class="line">        ri = <span class="built_in">min</span>(lt, i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(ri, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># dp[j] is dp[i-1][j] here</span></span><br><span class="line">            <span class="keyword">if</span>(s[i-<span class="number">1</span>] == t[j-<span class="number">1</span>]):</span><br><span class="line">                <span class="comment"># dp[j-1] here is dp[i-1][j-1] in fact</span></span><br><span class="line">                <span class="comment"># following equation represents dp[i][j] += dp[i-1][j-1]</span></span><br><span class="line">                dp[j] += dp[j-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[lt]  <span class="comment"># the value is dp[ls][lt] now</span></span><br></pre></td></tr></table></figure>

<h1 id="Leetcode-115-Distinct-Subsequences"><a href="#Leetcode-115-Distinct-Subsequences" class="headerlink" title="Leetcode 115. Distinct Subsequences"></a>Leetcode 115. Distinct Subsequences</h1><p>Given a string <strong>S</strong> and a string <strong>T</strong>, count the number of distinct subsequences of <strong>S</strong> which equals <strong>T</strong>.</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>&quot;ACE&quot;</code> is a subsequence of <code>&quot;ABCDE&quot;</code> while <code>&quot;AEC&quot;</code> is not).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: S = &quot;rabbbit&quot;, T = &quot;rabbit&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">As shown below, there are 3 ways you can generate &quot;rabbit&quot; from S.</span><br><span class="line">(The caret symbol ^ means the chosen letters)</span><br><span class="line"></span><br><span class="line">rabbbit</span><br><span class="line">^^^^ ^^</span><br><span class="line">rabbbit</span><br><span class="line">^^ ^^^^</span><br><span class="line">rabbbit</span><br><span class="line">^^^ ^^^</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: S = &quot;babgbag&quot;, T = &quot;bag&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">As shown below, there are 5 ways you can generate &quot;bag&quot; from S.</span><br><span class="line">(The caret symbol ^ means the chosen letters)</span><br><span class="line"></span><br><span class="line">babgbag</span><br><span class="line">^^ ^</span><br><span class="line">babgbag</span><br><span class="line">^^    ^</span><br><span class="line">babgbag</span><br><span class="line">^    ^^</span><br><span class="line">babgbag</span><br><span class="line">  ^  ^^</span><br><span class="line">babgbag</span><br><span class="line">    ^^^</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 72 Edit Distance (DP)</title>
    <url>/posts/oj/dp/leetcode-72-edit-distance/</url>
    <content><![CDATA[<p>编辑距离 (<a href="https://leetcode.com/problems/edit-distance/">LeetCode 72: Edit Distance</a>) 指的是将一个字符串 A 转变为另外一个字符串 B 所需的最小操作次数。</p>
<span id="more"></span>

<p>一次操作可以是以下三者之一：</p>
<ul>
<li>删除一个字符</li>
<li>插入一个字符</li>
<li>替换一个字符</li>
</ul>
<p>这道题就是求两个字符串的编辑距离，是一个比较经典的动态规划问题。容易想到用 <code>dp[i][j]</code> 用来表示 A 字符串的<br>前 <code>i</code> 个字符（<code>A[:i]</code>）到 B 字符串的前 <code>j</code> 个字符（<code>B[:j]</code>）的编辑距离，那么有以下两种情况：</p>
<ul>
<li><p><code>A[i] == B[j]</code>，<br>此时 <code>dp[i][j] = dp[i-1][j-1]</code></p>
</li>
<li><p><code>A[i] != B[j]</code>，<br>此时有三种可能操作可以使得 A 当前的子串（<code>A[:i]</code>）转换为 B 当前的子串（<code>B[:j]</code>）：</p>
<ul>
<li>删除 <code>A[i]</code>，总共所需操作次数为 <code>dp[i-1][j] + 1</code></li>
<li>在 <code>A[i]</code> 后插入 <code>B[j]</code>, 总共所需操作次数为 <code>dp[i][j-1] + 1</code></li>
<li>替换 <code>A[i]</code> 为 <code>B[j]</code>，总共所需操作次数为 <code>dp[i-1][j-1] + 1</code></li>
</ul>
<p>所以此时有 <code>dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1</code></p>
</li>
</ul>
<p>也容易想到初始状态：空串和任意字符串之间的编辑距离为该串的长度，即 <code>dp[i][0] =  i; dp[0][j] = j</code></p>
<p>结合上面的状态转移情况不难写出代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># dp[i][j] -&gt; minDistance(word1[:i], word2[:j])</span></span><br><span class="line">        len1, len2 = <span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (len2+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]  <span class="comment"># 2 * (len2+1) array</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(len2+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = j</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, len1+<span class="number">1</span>):</span><br><span class="line">            cur = i % <span class="number">2</span></span><br><span class="line">            dp[cur][<span class="number">0</span>] = i</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, len2+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i-<span class="number">1</span>] == word2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[cur][j] = dp[cur-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># min(remove, insert, replace)</span></span><br><span class="line">                    dp[cur][j] = <span class="built_in">min</span>(dp[cur-<span class="number">1</span>][j], dp[cur]</span><br><span class="line">                                     [j-<span class="number">1</span>], dp[cur-<span class="number">1</span>][j-<span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[len1 % <span class="number">2</span>][len2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    solu = Solution()</span><br><span class="line">    <span class="built_in">print</span>(solu.minDistance(<span class="string">&#x27;intention&#x27;</span>, <span class="string">&#x27;execution&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(solu.minDistance(<span class="string">&#x27;horse&#x27;</span>, <span class="string">&#x27;ros&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(solu.minDistance(<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;ros&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(solu.minDistance(<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OJ</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>1355 巧克力 （线段树点+区间）</title>
    <url>/posts/oj/ds/1355%20%E5%B7%A7%E5%85%8B%E5%8A%9B%20%EF%BC%88%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%82%B9+%E5%8C%BA%E9%97%B4%EF%BC%89/</url>
    <content><![CDATA[<p>继续最水的线段树 简单粗暴</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define lc p&lt;&lt;<span class="number">1</span>,s,mid</span><br><span class="line">#define rc p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,e</span><br><span class="line">#define mid ((s+e)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">100005</span>;</span><br><span class="line">int add[<span class="number">4</span> * N], maxv[<span class="number">4</span> * N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pushup</span>(<span class="params">int p</span>)</span><br><span class="line">&#123;</span><br><span class="line">    maxv[p] = <span class="title function_">max</span>(maxv[p &lt;&lt; <span class="number">1</span>], maxv[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pushdown</span>(<span class="params">int p</span>)</span><br><span class="line">&#123;</span><br><span class="line">    add[p &lt;&lt; <span class="number">1</span>] += add[p];</span><br><span class="line">    add[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += add[p];</span><br><span class="line">    maxv[p &lt;&lt; <span class="number">1</span>] += add[p];</span><br><span class="line">    maxv[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += add[p];</span><br><span class="line">    add[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">build</span>(<span class="params">int p, int s, int e</span>)</span><br><span class="line">&#123;</span><br><span class="line">    add[p] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(s == e) <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;maxv[p]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">build</span>(lc);</span><br><span class="line">        <span class="title function_">build</span>(rc);</span><br><span class="line">        <span class="title function_">pushup</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span>(<span class="params">int p, int s, int e, int l, int r, int v, int op</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == l &amp;&amp; e == r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(op)</span><br><span class="line">        &#123;</span><br><span class="line">            add[p] += v;</span><br><span class="line">            maxv[p] += v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> maxv[p] = v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= mid) <span class="title function_">update</span>(lc, l, r, v, op);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l &gt; mid) <span class="title function_">update</span>(rc, l, r, v, op);</span><br><span class="line">    <span class="keyword">else</span> <span class="title function_">update</span>(lc, l, mid, v, op), <span class="title function_">update</span>(rc, mid + <span class="number">1</span>, r, v, op);</span><br><span class="line">    <span class="title function_">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">query</span>(<span class="params">int p, int s, int e, int l, int r</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == l &amp;&amp; e == r) <span class="keyword">return</span> maxv[p];</span><br><span class="line">    <span class="title function_">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= mid) <span class="keyword">return</span> <span class="title function_">query</span>(lc, l, r);</span><br><span class="line">    <span class="keyword">if</span>(l &gt; mid) <span class="keyword">return</span> <span class="title function_">query</span>(rc, l, r);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">max</span>(<span class="title function_">query</span>(lc, l, mid), <span class="title function_">query</span>(rc, mid + <span class="number">1</span>, r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, m, x, y;</span><br><span class="line">    char cmd[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, cmd);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="title function_">strcmp</span>(cmd, <span class="string">&quot;Ask&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">                <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="title function_">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, x + <span class="number">1</span>, x + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">            <span class="keyword">if</span>(cmd[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="title function_">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, x + <span class="number">1</span>, y + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cmd[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">                <span class="title function_">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, x + <span class="number">1</span>, x + <span class="number">1</span>, y, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="title function_">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, x + <span class="number">1</span>, y + <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1355: 巧克力</p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><p>TY最喜欢做的事情就是吃巧克力，经常幻想拥有吃不完的巧克力，作为一个acmer(菜机），IcY出了个问题准备考考她，如果回答出来，那巧克力自然是源源不断的啦。</p>
<p>IcY给出了一列排好的的巧克力，有的是德芙，有的是费列罗，它们都拥有不同的美味值……现在IcY通过魔法更改了这些巧克力，TY必须能指出排列中第K个是巧克力的美味值是多少和某一段巧克力中最美味的值是多少，才能吃到巧克力，否则，哼哼，就去乖乖的做题吧。现在，TY来寻求你的帮助，你能让poor TY吃上巧克力吗？</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>输入数据有很多组，以EOF结尾。</p>
<p>每组数据第一行是2个整数N，M。N代表初始的巧克力数目，M代表操作数。</p>
<p>第二行含有n个正整数，代表每块巧克力的美味值wi。每块巧克力的下标从0–n-1。</p>
<p>接下来的M行，表示M个操作。</p>
<p>操作分4种：</p>
<p>Query x y 代表查询某一个区间内的美味最大值。</p>
<p>Ask x 代表查询某一块巧克力的美味值。</p>
<p>Change x y 代表将第x块的美味值变成y</p>
<p>Add x y 代表讲从第x块到第y块巧克力的美味值分别增加1.</p>
<p>（1 &lt;&#x3D; N&lt;&#x3D; 1000001&lt;&#x3D; M &lt;&#x3D; 100000Wi &lt;&#x3D; 5000）</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>对于每一个Query输出一个整数，代表区间内的美味最大值。</p>
<p>对于每一个Ask 输出一个整数，代表这块巧克力的美味值。</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>10 4 1 2 3 4 5 6 7 8 9 10 Ask 0 Change 0 1 Add 0 2 Query 0 2</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>1 4</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 527C Glass Carving(Set)</title>
    <url>/posts/oj/ds/Codeforces%20527C%20Glass%20Carving(Set)/</url>
    <content><![CDATA[<p>题意 一块w&#x2F;*h的玻璃 对其进行n次切割 每次切割都是垂直或者水平的 输出每次切割后最大单块玻璃的面积</p>
<p>用两个set存储每次切割的位置 就可以比较方便的把每次切割产生和消失的长宽存下来 每次切割后剩下的最大长宽的积就是答案了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">200005</span>;</span><br><span class="line">typedef long long <span class="variable constant_">LL</span>;</span><br><span class="line">set&lt;int&gt;::iterator i, j;</span><br><span class="line">set&lt;int&gt; ve, ho;  <span class="comment">//记录所有边的位置</span></span><br><span class="line">int wi[N], hi[N];  <span class="comment">//记录存在的边长值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">cut</span>(<span class="params">set&lt;int&gt; &amp;s, int *a, int p</span>)</span><br><span class="line">&#123;</span><br><span class="line">    s.<span class="title function_">insert</span>(p), i = j = s.<span class="title function_">find</span>(p);</span><br><span class="line">    --i, ++j, --a[*j - *i];  <span class="comment">//除掉被分开的长宽</span></span><br><span class="line">    ++a[p - *i], ++a[*j - p];  <span class="comment">//新产生了两个长宽</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int w, n, h, p, mw, mh;</span><br><span class="line">    char s[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;w, &amp;h, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">memset</span>(wi, <span class="number">0</span>, <span class="title function_">sizeof</span>(wi)), <span class="title function_">memset</span>(hi, <span class="number">0</span>, <span class="title function_">sizeof</span>(hi));</span><br><span class="line">        ve.<span class="title function_">clear</span>(), ho.<span class="title function_">clear</span>();</span><br><span class="line">        ve.<span class="title function_">insert</span>(<span class="number">0</span>), ho.<span class="title function_">insert</span>(<span class="number">0</span>);</span><br><span class="line">        ve.<span class="title function_">insert</span>(w), ho.<span class="title function_">insert</span>(h);</span><br><span class="line">        wi[w] = hi[h] = <span class="number">1</span>;</span><br><span class="line">        mw = w , mh = h;</span><br><span class="line">        <span class="keyword">while</span>(n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, s, &amp;p);</span><br><span class="line">            <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;V&#x27;</span>) <span class="title function_">cut</span>(ve, wi, p);</span><br><span class="line">            <span class="keyword">else</span> <span class="title function_">cut</span>(ho, hi, p);</span><br><span class="line">            <span class="keyword">while</span>(!wi[mw]) --mw;</span><br><span class="line">            <span class="keyword">while</span>(!hi[mh]) --mh;</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="title function_">LL</span>(mw)*<span class="title function_">LL</span>(mh));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C. Glass Carving</p>
<p>Leonid wants to become a glass carver (the person who creates beautiful artworks by cutting the glass). He already has a rectangular <em>w</em>mm ×  <em>h</em> mm sheet of glass, a diamond glass cutter and lots of enthusiasm. What he lacks is understanding of what to carve and how.</p>
<p>In order not to waste time, he decided to practice the technique of carving. To do this, he makes vertical and horizontal cuts through the entire sheet. This process results in making smaller rectangular fragments of glass. Leonid does not move the newly made glass fragments. In particular, a cut divides each fragment of glass that it goes through into smaller fragments.</p>
<p>After each cut Leonid tries to determine what area the largest of the currently available glass fragments has. Since there appear more and more fragments, this question takes him more and more time and distracts him from the fascinating process.</p>
<p>Leonid offers to divide the labor — he will cut glass, and you will calculate the area of the maximum fragment after each cut. Do you agree?<br>Input</p>
<p>The first line contains three integers <em>w</em>, <em>h</em>, <em>n</em> (2 ≤ <em>w</em>, <em>h</em> ≤ 200 000, 1 ≤ <em>n</em> ≤ 200 000).</p>
<p>Next <em>n</em> lines contain the descriptions of the cuts. Each description has the form <em>H y</em> or <em>V x</em>. In the first case Leonid makes the horizontal cut at the distance <em>y</em> millimeters (1 ≤ <em>y</em> ≤ <em>h</em> - 1) from the lower edge of the original sheet of glass. In the second case Leonid makes a vertical cut at distance <em>x</em> (1 ≤ <em>x</em> ≤ <em>w</em> - 1) millimeters from the left edge of the original sheet of glass. It is guaranteed that Leonid won’t make two identical cuts.</p>
<p>Output</p>
<p>After each cut print on a single line the area of the maximum available glass fragment in mm2.<br>Sample test(s)</p>
<p>input 4 3 4 H 2 V 2 V 3 V 1</p>
<p>output 8 4 4 2<br>input 7 6 5 H 4 V 3 V 5 H 2 V 1</p>
<p>output 28 16 12 6 4</p>
<p>Note</p>
<p>Picture for the first sample test:</p>
<p><img src="/../images/eforces.com-76f76c4b91db5d63d733cd37c91bce09001259b7-.png">  Picture for the second sample test:  <img src="/../images/eforces.com-70c98df3646740cda1a5e6455b065203e1953191-.png"></p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1081 To The Max(DP)</title>
    <url>/posts/oj/ds/HDU%201081%20To%20The%20Max(DP)/</url>
    <content><![CDATA[<p>题意 求一个n&#x2F;*n矩阵的最大子矩阵和</p>
<p>HDU 1003 max sum 的升级版 把二维简化为一维就可以用1003的方法去做了 用mat[i][j]存 第i行前j个数的和 那么mat[k][j]-mat[k][i]就表示第k行 第i+1个数到第j个数的和了 再将k从一枚举到n就可以得到这个这个宽度为j-i的最大矩阵和了 然后i,j又分别从1枚举到n就能得到结果了 和1003的方法一样 只是多了两层循环</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">105</span>;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int t, n, sum, ans, mat[N][N];</span><br><span class="line">    <span class="keyword">while</span> (~scanf (<span class="string">&quot;%d&quot;</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                scanf (<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">                mat[i][j] = mat[i][j - <span class="number">1</span>] + t;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (int i = ans = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (int j = i + <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (int k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) sum = <span class="number">0</span>;</span><br><span class="line">                    sum += (mat[k][j] - mat[k][i]);</span><br><span class="line">                    <span class="keyword">if</span> (sum &gt; ans) ans = sum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        printf (<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="To-The-Max"><a href="#To-The-Max" class="headerlink" title="To The Max"></a>To The Max</h1><p>Problem Description</p>
<p>Given a two-dimensional array of positive and negative integers, a sub-rectangle is any contiguous sub-array of size 1 x 1 or greater located within the whole array. The sum of a rectangle is the sum of all the elements in that rectangle. In this problem the sub-rectangle with the largest sum is referred to as the maximal sub-rectangle.<br>As an example, the maximal sub-rectangle of the array:<br>0 -2 -7 0<br>9 2 -6 2<br>-4 1 -4 1<br>-1 8 0 -2<br>is in the lower left corner:<br>9 2<br>-4 1<br>-1 8<br>and has a sum of 15.<br>Input</p>
<p>The input consists of an N x N array of integers. The input begins with a single positive integer N on a line by itself, indicating the size of the square two-dimensional array. This is followed by N 2 integers separated by whitespace (spaces and newlines). These are the N 2 integers of the array, presented in row-major order. That is, all numbers in the first row, left to right, then all numbers in the second row, left to right, etc. N may be as large as 100. The numbers in the array will be in the range [-127,127].<br>Output</p>
<p>Output the sum of the maximal sub-rectangle.<br>Sample Input</p>
<p>4 0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2<br>Sample Output</p>
<p>15</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1166 敌兵布阵 (树状数组·线段树)</title>
    <url>/posts/oj/ds/HDU%201166%20%E6%95%8C%E5%85%B5%E5%B8%83%E9%98%B5%20(%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%C2%B7%E7%BA%BF%E6%AE%B5%E6%A0%91)/</url>
    <content><![CDATA[<p>题意 中文</p>
<p>动态区间和问题 只会更新点 最基础的树状数组 线段树的应用</p>
<p>树状数组代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">50005</span>;</span><br><span class="line">int c[N], n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span>(<span class="params">int p, int x</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(p &lt;= n)</span><br><span class="line">        c[p] += x, p += p &amp; -p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">getSum</span>(<span class="params">int p</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &gt; <span class="number">0</span>)</span><br><span class="line">        ret += c[p], p -= p &amp; -p;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int u, v, t, cas;</span><br><span class="line">    char op[<span class="number">20</span>];</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">for</span>(int k = <span class="number">1</span>; k &lt;= cas; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;Case %d:\n&quot;</span>, k);</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="title function_">memset</span>(c, <span class="number">0</span>, <span class="title function_">sizeof</span>(c));</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">            <span class="title function_">add</span>(i, t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, op), op[<span class="number">0</span>] != <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="title function_">getSum</span>(v) - <span class="title function_">getSum</span>(u - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">else</span> <span class="title function_">add</span>(u, op[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span> ? v : -v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线段树代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">#define lc p&lt;&lt;<span class="number">1</span>,s,mid</span><br><span class="line">#define rc p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,e</span><br><span class="line">#define mid ((s+e)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">50005</span>;</span><br><span class="line">int sum[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pushup</span>(<span class="params">int p</span>)</span><br><span class="line">&#123;</span><br><span class="line">    sum[p] = sum[p &lt;&lt; <span class="number">1</span>] + sum[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">build</span>(<span class="params">int p, int s, int e</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;sum[p]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">build</span>(lc), <span class="title function_">build</span>(rc);</span><br><span class="line">    <span class="title function_">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span>(<span class="params">int p, int s, int e, int a, int b</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == e &amp;&amp; e == a)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[p] += b;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( a &lt;= mid) <span class="title function_">update</span>(lc, a, b);</span><br><span class="line">    <span class="keyword">else</span> <span class="title function_">update</span>(rc, a, b);</span><br><span class="line">    <span class="title function_">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">query</span>(<span class="params">int p, int s, int e, int l, int r</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s &gt;= l &amp;&amp; e &lt;= r) <span class="keyword">return</span> sum[p];</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= mid) <span class="keyword">return</span> <span class="title function_">query</span>(lc, l, r);</span><br><span class="line">    <span class="keyword">if</span>(l &gt; mid) <span class="keyword">return</span> <span class="title function_">query</span>(rc, l, r);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">query</span>(lc, l, mid) + <span class="title function_">query</span>(rc, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas, n, a, b;</span><br><span class="line">    char c[<span class="number">20</span>];</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">for</span>(int k = <span class="number">1</span>; k &lt;= cas; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;Case %d:\n&quot;</span>, k);</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="title function_">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, c), c[<span class="number">0</span>] != <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">if</span>(c[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>) <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="title function_">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, a, b));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span>) <span class="title function_">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, a, b);</span><br><span class="line">            <span class="keyword">else</span> <span class="title function_">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, a, -b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="敌兵布阵"><a href="#敌兵布阵" class="headerlink" title="敌兵布阵"></a>敌兵布阵</h1><p>Problem Description</p>
<p>C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。<br>中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的.<br>Input</p>
<p>第一行一个整数T，表示有T组数据。<br>每组数据第一行一个正整数N（N&lt;&#x3D;50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;&#x3D;ai&lt;&#x3D;50）。<br>接下来每行有一条命令，命令有4种形式：<br>(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）<br>(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;<br>(3)Query i j ,i和j为正整数,i&lt;&#x3D;j，表示询问第i到第j个营地的总人数;<br>(4)End 表示结束，这条命令在每组数据最后出现;<br>每组数据最多有40000条命令<br>Output</p>
<p>对第i组数据,首先输出“Case i:”和回车,<br>对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。<br>Sample Input</p>
<p>1 10 1 2 3 4 5 6 7 8 9 10 Query 1 3 Add 3 6 Query 2 7 Sub 10 2 Add 6 3 Query 3 10 End<br>Sample Output</p>
<p>Case 1: 6 33 59<br>Author</p>
<p>Windbreaker</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1540 Tunnel Warfare(线段树 区间合并 最大连续区间)</title>
    <url>/posts/oj/ds/HDU%201540%20Tunnel%20Warfare(%E7%BA%BF%E6%AE%B5%E6%A0%91%20%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6%20%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%8C%BA%E9%97%B4)/</url>
    <content><![CDATA[<p>题意 有n个连在一起的地道 接下来有m个操作 D x 炸掉x号地道 炸掉后x所在的区间就不连续了 Q x 查询输出包括x的最大连续区间长度 R修复最后一个被炸的地道 注意输入R时可能并没有需要修复的地道</p>
<p>线段树的区间合并问题 线段树要维护3个信息</p>
<p>len 对应区间的最大连续长度</p>
<p>ll 对应区间最左端的一段连续长度</p>
<p>lr 对应区间最右端的一段连续长度</p>
<p>那么双亲节点的这些信息和孩子节点有什么关系呢容易发现</p>
<p>双亲的len 是 左孩子的len 右孩子的len 左孩子的右端长度+右孩子的左端长度 这三个的最大值</p>
<p>双亲的ll 如果左孩子整个区间都是连续的话 ll就等于左孩子的len加上右孩子的左端长度了</p>
<p>双亲的lr 如果右孩子整个区间都是连续的话 lr就等于右孩子的len加上左孩子的右端长度了</p>
<p>于是就知道pushup函数怎么写了 请看代码</p>
<p>知道这些信息又怎么查询包括x点的最大区间长度呢</p>
<p>肯定是在包含x的区间里面查的</p>
<p>如果根区间整个区间都是连续的 那么根区间长度就是答案了</p>
<p>如果x在左孩子的右端连续段或者右孩子的左端连续段里 那么这两段的和就是答案了</p>
<p>否则就继续查询x所属的孩子区间咯</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">#define lc lp, s, mid</span><br><span class="line">#define rc rp, mid+<span class="number">1</span>, e</span><br><span class="line">#define lp p&lt;&lt;<span class="number">1</span></span><br><span class="line">#define rp p&lt;&lt;<span class="number">1</span>|<span class="number">1</span></span><br><span class="line">#define mid ((s+e)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">50005</span>;</span><br><span class="line">int len[N * <span class="number">4</span>], lr[N * <span class="number">4</span>], ll[N * <span class="number">4</span>];</span><br><span class="line">int n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pushup</span>(<span class="params">int p, int s, int e</span>)</span><br><span class="line">&#123;</span><br><span class="line">    len[p] = <span class="title function_">max</span>(len[lp], len[rp]);</span><br><span class="line">    len[p] = <span class="title function_">max</span>(len[p], lr[lp] + ll[rp]);</span><br><span class="line">    ll[p] = ll[lp], lr[p] = lr[rp];</span><br><span class="line">    <span class="keyword">if</span>(ll[p] == mid - s + <span class="number">1</span>) ll[p] += ll[rp];</span><br><span class="line">    <span class="keyword">if</span>(lr[p] == e - mid) lr[p] += lr[lp];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">build</span>(<span class="params">int p, int s, int e</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == e)</span><br><span class="line">    &#123;</span><br><span class="line">        len[p] = ll[p] = lr[p] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">build</span>(lc);</span><br><span class="line">    <span class="title function_">build</span>(rc);</span><br><span class="line">    <span class="title function_">pushup</span>(p, s, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span>(<span class="params">int p, int s, int e, int x, int v</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == e &amp;&amp; e == x)</span><br><span class="line">    &#123;</span><br><span class="line">        len[p] = ll[p] = lr[p] = v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="title function_">update</span>(lc, x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="title function_">update</span>(rc, x, v);</span><br><span class="line">    <span class="title function_">pushup</span>(p, s, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">query</span>(<span class="params">int p, int s, int e, int x</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(len[p] == <span class="number">0</span> || len[p] == e - s + <span class="number">1</span>)	<span class="keyword">return</span> len[p];</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)</span><br><span class="line">        <span class="keyword">return</span> x &gt; mid - lr[lp] ? lr[lp] + ll[rp] : <span class="title function_">query</span>(lc, x);</span><br><span class="line">    <span class="keyword">return</span> x &lt;= ll[rp] + mid ? ll[rp] + lr[lp] : <span class="title function_">query</span>(rc, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    char op[<span class="number">10</span>];</span><br><span class="line">    int p;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        stack&lt;int&gt; s;</span><br><span class="line">        <span class="title function_">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;R&#x27;</span> &amp;&amp; !s.<span class="title function_">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                p = s.<span class="title function_">top</span>(), s.<span class="title function_">pop</span>();</span><br><span class="line">                <span class="title function_">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, p, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p);</span><br><span class="line">                <span class="title function_">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, p, <span class="number">0</span>);</span><br><span class="line">                s.<span class="title function_">push</span>(p);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p);</span><br><span class="line">                <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="title function_">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, p));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1542 Atlantis（线段树扫描线·面积并）</title>
    <url>/posts/oj/ds/HDU%201542%20Atlantis%EF%BC%88%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%89%AB%E6%8F%8F%E7%BA%BF%C2%B7%E9%9D%A2%E7%A7%AF%E5%B9%B6%EF%BC%89/</url>
    <content><![CDATA[<p>题意 给你一些矩形的左下和右上的坐标 求这些矩形的面积并</p>
<p>最基础的扫描线 理解了就是个水题了 先看一些图吧</p>
<p><img src="/../images/dn.net-20150812201313561-watermark-2-text-aHR0cDovL2Jsb2cuY3Nkbi5uZXQv-font-5a6L5L2T-fontsize-400-fill-I0JBQkFCMA==-dissolve-70-gravity-SouthEast.png"> <img src="/../images/dn.net-20150812201335946-watermark-2-text-aHR0cDovL2Jsb2cuY3Nkbi5uZXQv-font-5a6L5L2T-fontsize-400-fill-I0JBQkFCMA==-dissolve-70-gravity-SouthEast.png"> <img src="/../images/dn.net-20150812201350012-watermark-2-text-aHR0cDovL2Jsb2cuY3Nkbi5uZXQv-font-5a6L5L2T-fontsize-400-fill-I0JBQkFCMA==-dissolve-70-gravity-SouthEast.png"> <img src="/../images/dn.net-20150812201358280-watermark-2-text-aHR0cDovL2Jsb2cuY3Nkbi5uZXQv-font-5a6L5L2T-fontsize-400-fill-I0JBQkFCMA==-dissolve-70-gravity-SouthEast.png"> <img src="/../images/dn.net-20150812201407487-watermark-2-text-aHR0cDovL2Jsb2cuY3Nkbi5uZXQv-font-5a6L5L2T-fontsize-400-fill-I0JBQkFCMA==-dissolve-70-gravity-SouthEast.png"> <img src="/../images/dn.net-20150812201420062-watermark-2-text-aHR0cDovL2Jsb2cuY3Nkbi5uZXQv-font-5a6L5L2T-fontsize-400-fill-I0JBQkFCMA==-dissolve-70-gravity-SouthEast.png"></p>
<p>恩 看完了有什么感觉没有 那些红色的线就可以当作传说中的扫描线 就像从左到右扫描嘛 可以发现 矩形有竖直边的地方就有这些线 这些线把把拼在一起的矩形切成了一个个的小矩形 我们把这些小矩形的面积加起来不就是要求的面积吗</p>
<p>那么现在这些小矩形的面积怎么求呢 长乘宽嘛 长是什么 两条红线之间的距离 恩 我们要先把所有矩形的竖直边存起来 然后按横坐标排个序 那么相邻两个竖边的横坐标的差不就是长吗</p>
<p>那么宽呢 宽就是扫描线右边有矩形部分的长度呀 那么现在的问题就是怎么求这个长度了 我们是依次对矩形竖边进行扫描的 我们的扫描线就可以用来维护这个长度(len) 开始让扫描线上所有位置值(cnt)都为0 每来一条竖边 如果这个竖边是矩形左边的边(入边) 我们就让扫描线对应区间的值都加上1 如果这个竖边是矩形右边的边(出边) 我们就让扫描线对应区间的值都减去1 那么我们每次只用知道扫描线上非0部分有多长 这个长度不就是扫描线右边有矩形部分的长度了</p>
<p>噢 对区间进行加1减1操作 是不是很熟悉呀</p>
<p>你可以当作普通的区间更新来做 但是扫描线有个特殊的性质可以让你省掉lazy标记 因为减1的区间肯定是之前加过1的 我们更新时找到满足条件的区间后不用再往下推(pushdown)了 而且只有cnt &#x3D; 0的地方才需要pushup</p>
<p>由于这道题的y坐标的范围比较大 而且不是整数 所以需要进行离散化操作 离散化只用把原来的值替换为排序后的下标就行了 因为这样不会改变他们y坐标的相对顺序 计算len的时候再把下标对应的y值取出来</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define lc p&lt;&lt;<span class="number">1</span>, s, mid</span><br><span class="line">#define rc p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid + <span class="number">1</span>, e</span><br><span class="line">#define mid ((s+e)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">205</span>;</span><br><span class="line">int cnt[N * <span class="number">4</span>];</span><br><span class="line">double len[N * <span class="number">4</span>], y[N];</span><br><span class="line"></span><br><span class="line">struct <span class="title class_">SLine</span></span><br><span class="line">&#123;</span><br><span class="line">    double x, y1, y2;</span><br><span class="line">    int flag;</span><br><span class="line">    <span class="title class_">SLine</span>() &#123;&#125;</span><br><span class="line">    <span class="title class_">SLine</span>(double a, double b, double c, int t):</span><br><span class="line">        <span class="title function_">x</span>(a), <span class="title function_">y1</span>(b), <span class="title function_">y2</span>(c), <span class="title function_">flag</span>(<span class="params">t</span>) &#123;&#125;</span><br><span class="line">    bool operator&lt; (<span class="keyword">const</span> <span class="title class_">SLine</span> &amp;s) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; s.<span class="property">x</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; line[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pushup</span>(int p, int s, int e) <span class="comment">//只有cnt = 0时才需要更新</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt[p]) len[p] = y[e] - y[s - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s == e) len[p] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> len[p] = len[p &lt;&lt; <span class="number">1</span>] + len[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">build</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">memset</span>(len, <span class="number">0</span>, <span class="title function_">sizeof</span>(len));</span><br><span class="line">    <span class="title function_">memset</span>(cnt, <span class="number">0</span>, <span class="title function_">sizeof</span>(cnt));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span>(<span class="params">int p, int s, int e, int l, int r, int v</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= s &amp;&amp; e &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt[p] += v;</span><br><span class="line">        <span class="title function_">pushup</span>(p, s, e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="title function_">update</span>(lc, l, r, v);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="title function_">update</span>(rc, l, r, v);</span><br><span class="line">    <span class="title function_">pushup</span>(p, s, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, m, cas = <span class="number">0</span>;</span><br><span class="line">    double x1, y1, x2, y2;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">build</span>();</span><br><span class="line">        m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%lf%lf%lf%lf&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">            y[m] = y1, y[m + <span class="number">1</span>] = y2;</span><br><span class="line">            line[m++] = <span class="title class_">SLine</span>(x1, y1, y2, <span class="number">1</span>);</span><br><span class="line">            line[m++] = <span class="title class_">SLine</span>(x2, y1, y2, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">sort</span>(line, line + m);</span><br><span class="line">        <span class="title function_">sort</span>(y, y + m); <span class="comment">//离散化</span></span><br><span class="line"></span><br><span class="line">        double sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            int l = <span class="title function_">lower_bound</span>(y, y + m, line[i].<span class="property">y1</span>) - y;</span><br><span class="line">            int r = <span class="title function_">lower_bound</span>(y, y + m, line[i].<span class="property">y2</span>) - y;</span><br><span class="line">            <span class="title function_">update</span>(<span class="number">1</span>, <span class="number">1</span>, m, l + <span class="number">1</span>, r, line[i].<span class="property">flag</span>);</span><br><span class="line">            <span class="comment">//l+1是点区间化段区间时长度需减1</span></span><br><span class="line">            sum += len[<span class="number">1</span>] * (line[i + <span class="number">1</span>].<span class="property">x</span> - line[i].<span class="property">x</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;Test case #%d\nTotal explored area: %.2f\n\n&quot;</span>, ++cas, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Atlantis"><a href="#Atlantis" class="headerlink" title="Atlantis"></a>Atlantis</h1><p>Problem Description</p>
<p>There are several ancient Greek texts that contain descriptions of the fabled island Atlantis. Some of these texts even include maps of parts of the island. But unfortunately, these maps describe different regions of Atlantis. Your friend Bill has to know the total area for which maps exist. You (unwisely) volunteered to write a program that calculates this quantity.<br>Input</p>
<p>The input file consists of several test cases. Each test case starts with a line containing a single integer n (1&lt;&#x3D;n&lt;&#x3D;100) of available maps. The n following lines describe one map each. Each of these lines contains four numbers x1;y1;x2;y2 (0&lt;&#x3D;x1&lt;x2&lt;&#x3D;100000;0&lt;&#x3D;y1&lt;y2&lt;&#x3D;100000), not necessarily integers. The values (x1; y1) and (x2;y2) are the coordinates of the top-left resp. bottom-right corner of the mapped area.<br>The input file is terminated by a line containing a single 0. Don’t process it.<br>Output</p>
<p>For each test case, your program should output one section. The first line of each section must be “Test case &#x2F;#k”, where k is the number of the test case (starting with 1). The second one must be “Total explored area: a”, where a is the total explored area (i.e. the area of the union of all rectangles in this test case), printed exact to two digits to the right of the decimal point.<br>Output a blank line after each test case.<br>Sample Input</p>
<p>2 10 10 20 20 15 15 25 25.5 0<br>Sample Output</p>
<p>Test case &#x2F;#1 Total explored area: 180.00</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1754 I Hate It(入门线段树)</title>
    <url>/posts/oj/ds/HDU%201754%20I%20Hate%20It(%E5%85%A5%E9%97%A8%E7%BA%BF%E6%AE%B5%E6%A0%91)/</url>
    <content><![CDATA[<p>题意 中文</p>
<p>最基础的线段树了 只涉及到了点的修改</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define lc p&lt;&lt;<span class="number">1</span>,s,mid</span><br><span class="line">#define rc p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,e</span><br><span class="line">#define mid ((s+e)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">200005</span>;</span><br><span class="line">int maxv[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pushup</span>(<span class="params">int p</span>)</span><br><span class="line">&#123;</span><br><span class="line">    maxv[p] = <span class="title function_">max</span>(maxv[p &lt;&lt; <span class="number">1</span>], maxv[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">build</span>(<span class="params">int p, int s, int e</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == e) <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;maxv[p]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">build</span>(lc);</span><br><span class="line">        <span class="title function_">build</span>(rc);</span><br><span class="line">        <span class="title function_">pushup</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span>(<span class="params">int p, int s, int e, int a, int b</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == e &amp;&amp; e == a)</span><br><span class="line">    &#123;</span><br><span class="line">        maxv[p] = b;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a &lt;= mid) <span class="title function_">update</span>(lc, a, b);</span><br><span class="line">    <span class="keyword">else</span> <span class="title function_">update</span>(rc, a, b);</span><br><span class="line">    <span class="title function_">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">query</span>(<span class="params">int p, int s, int e, int l, int r</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s &gt;= l &amp;&amp; e &lt;= r) <span class="keyword">return</span> maxv[p];</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= mid) <span class="keyword">return</span> <span class="title function_">query</span>(lc, l, r);</span><br><span class="line">    <span class="keyword">if</span>(l &gt; mid) <span class="keyword">return</span> <span class="title function_">query</span>(rc, l, r);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">max</span>(<span class="title function_">query</span>(lc, l, mid), <span class="title function_">query</span>(rc, mid + <span class="number">1</span>, r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, m, a, b;</span><br><span class="line">    char c[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, c, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">if</span>(c[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>) <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="title function_">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, a, b));</span><br><span class="line">            <span class="keyword">else</span> <span class="title function_">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="I-Hate-It"><a href="#I-Hate-It" class="headerlink" title="I Hate It"></a>I Hate It</h1><p>Problem Description</p>
<p>很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。<br>这让很多学生很反感。<br>不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。<br>Input</p>
<p>本题目包含多组测试，请处理到文件结束。<br>在每个测试的第一行，有两个正整数 N 和 M ( 0&lt;N&lt;&#x3D;200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。<br>学生ID编号分别从1编到N。<br>第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。<br>接下来有M行。每一行有一个字符 C (只取’Q’或’U’) ，和两个正整数A，B。<br>当C为’Q’的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。<br>当C为’U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。<br>Output</p>
<p>对于每一次询问操作，在一行里面输出最高成绩。<br>Sample Input</p>
<p>5 6 1 2 3 4 5 Q 1 5 U 3 6 Q 3 4 Q 4 5 U 2 9 Q 1 5<br>Sample Output</p>
<p>5 6 5 9</p>
<p><em>Hint</em> Huge input,the C function scanf() will work better than cin</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1828 Picture（线段树扫描线·周长并）</title>
    <url>/posts/oj/ds/HDU%201828%20Picture%EF%BC%88%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%89%AB%E6%8F%8F%E7%BA%BF%C2%B7%E5%91%A8%E9%95%BF%E5%B9%B6%EF%BC%89/</url>
    <content><![CDATA[<p>题意 给你一些矩形的左下和右上的坐标 求这些矩形的周长并</p>
<p>也先来看点图</p>
<p><img src="/../images/dn.net-20150814134244728-watermark-2-text-aHR0cDovL2Jsb2cuY3Nkbi5uZXQv-font-5a6L5L2T-fontsize-400-fill-I0JBQkFCMA==-dissolve-70-gravity-SouthEast.png"> <img src="/../images/dn.net-20150814134259064-watermark-2-text-aHR0cDovL2Jsb2cuY3Nkbi5uZXQv-font-5a6L5L2T-fontsize-400-fill-I0JBQkFCMA==-dissolve-70-gravity-SouthEast.png"></p>
<p>和面积并类似 求周长并也可以对每条竖边从左往右进行扫描 每次周长增加了多少呢 可以发现y方向上对周长增加的量就是扫描线上线段的总长度的改变量 x方向增加了线段段数 &#x2F;* 2 倍的与下一条竖边间的距离 因为每一段都会对应两个横边</p>
<p>那么我们需要维护线段的总长度len和线段的段数num len和面积并的是一样的 num有点类似区间合并 由子节点更新父节点的时候 先让父节点的num等于两个子节点的num的和 但是当左孩子结点的右端有线段 而其右孩子的左端有线段的时候 这两段是可以连在一起的 父节点的num就要减去1 所以我们还要维护每个区间左端是否有线段lh 右边是否有线段rh</p>
<p>另外求周长并还要注意当两个竖边的x值相等时 要把入边放前面 出边放后面 也就是排序时要注意一下 否则会多加上一些长度</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">10005</span>, M = N * <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">struct <span class="title class_">SLine</span></span><br><span class="line">&#123;</span><br><span class="line">    int x, y1, y2, flag;</span><br><span class="line">    <span class="title class_">SLine</span>() &#123;&#125;</span><br><span class="line">    <span class="title class_">SLine</span>(int xx, int a, int b, int f):</span><br><span class="line">        <span class="title function_">x</span>(xx), <span class="title function_">y1</span>(a), <span class="title function_">y2</span>(b), <span class="title function_">flag</span>(<span class="params">f</span>) &#123;&#125;</span><br><span class="line">    bool operator&lt; (<span class="keyword">const</span> <span class="title class_">SLine</span> &amp;s) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x == s.<span class="property">x</span>) <span class="keyword">return</span> flag &gt; s.<span class="property">flag</span>;</span><br><span class="line">        <span class="comment">//有入边出边在一条线上时 要先扫描入边 不然周长可能会多算重叠部分</span></span><br><span class="line">        <span class="keyword">return</span> x &lt; s.<span class="property">x</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; line[N];</span><br><span class="line"></span><br><span class="line">int num[M], cnt[M], len[M], y[N];</span><br><span class="line">bool lh[M], rh[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pushup</span>(<span class="params">int p, int s, int e</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt[p]) <span class="comment">//cnt == 0 时才需要由子节点来更新父节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        len[p] = y[e] - y[s - <span class="number">1</span>];</span><br><span class="line">        num[p] = lh[p] = rh[p] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s == e)</span><br><span class="line">        len[p] = num[p] = lh[p] = rh[p] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//区间合并</span></span><br><span class="line">    &#123;</span><br><span class="line">        len[p] = len[p &lt;&lt; <span class="number">1</span>] + len[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">        num[p] = num[p &lt;&lt; <span class="number">1</span>] + num[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">        lh[p] = lh[p &lt;&lt; <span class="number">1</span>], rh[p] = rh[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(rh[p &lt;&lt; <span class="number">1</span>] &amp;&amp; lh[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]) --num[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span>(<span class="params">int p, int s, int e, int l, int r, int v</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= s &amp;&amp; e &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt[p] += v;</span><br><span class="line">        <span class="title function_">pushup</span>(p, s, e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid = (s + e) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="title function_">update</span>(p &lt;&lt; <span class="number">1</span>, s, mid, l, r, v);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="title function_">update</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, e, l, r, v);</span><br><span class="line">    <span class="title function_">pushup</span>(p, s, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, m, x1, y1, x2, y2;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = m = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">            y[m] = y1, y[m + <span class="number">1</span>] = y2;</span><br><span class="line">            line[m++] = <span class="title class_">SLine</span>(x1, y1, y2, <span class="number">1</span>);</span><br><span class="line">            line[m++] = <span class="title class_">SLine</span>(x2, y1, y2, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">sort</span>(line, line + m);</span><br><span class="line">        <span class="title function_">sort</span>(y, y + m);  <span class="comment">//离散化</span></span><br><span class="line"></span><br><span class="line">        int ans = <span class="number">0</span>, last = <span class="number">0</span>, l, r;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            l = <span class="title function_">lower_bound</span>(y, y + m, line[i].<span class="property">y1</span>) - y + <span class="number">1</span>;</span><br><span class="line">            r = <span class="title function_">lower_bound</span>(y, y + m, line[i].<span class="property">y2</span>) - y;</span><br><span class="line">            <span class="title function_">update</span>(<span class="number">1</span>, <span class="number">1</span>, m, l, r, line[i].<span class="property">flag</span>);</span><br><span class="line">            <span class="keyword">if</span>(i &lt; m - <span class="number">1</span>) ans += <span class="number">2</span> * num[<span class="number">1</span>] * (line[i + <span class="number">1</span>].<span class="property">x</span> - line[i].<span class="property">x</span>); <span class="comment">//横边</span></span><br><span class="line">            ans += <span class="title function_">abs</span>(len[<span class="number">1</span>] - last); <span class="comment">//竖边</span></span><br><span class="line">            last = len[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Picture"><a href="#Picture" class="headerlink" title="Picture"></a>Picture</h1><p>Problem Description</p>
<p>A number of rectangular posters, photographs and other pictures of the same shape are pasted on a wall. Their sides are all vertical or horizontal. Each rectangle can be partially or totally covered by the others. The length of the boundary of the union of all rectangles is called the perimeter.<br>Write a program to calculate the perimeter. An example with 7 rectangles is shown in Figure 1.<br><img src="/../images/cn-data-images-1828-1.jpg.png"><br>The corresponding boundary is the whole set of line segments drawn in Figure 2.<br><img src="/../images/cn-data-images-1828-2.jpg.png"><br>The vertices of all rectangles have integer coordinates.<br>Input</p>
<p>Your program is to read from standard input. The first line contains the number of rectangles pasted on the wall. In each of the subsequent lines, one can find the integer coordinates of the lower left vertex and the upper right vertex of each rectangle. The values of those coordinates are given as ordered pairs consisting of an x-coordinate followed by a y-coordinate.<br>0 &lt;&#x3D; number of rectangles &lt; 5000<br>All coordinates are in the range [-10000,10000] and any existing rectangle has a positive area.<br>Please process to the end of file.<br>Output</p>
<p>Your program is to write to standard output. The output must contain a single line with a non-negative integer which corresponds to the perimeter for the input rectangles.<br>Sample Input</p>
<p>7 -15 0 5 10 -5 8 20 25 15 -4 24 14 0 -6 16 4 2 15 10 22 30 10 36 20 34 0 40 16<br>Sample Output</p>
<p>228</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 2871 Memory Control（线段树·区间合并·Vector）</title>
    <url>/posts/oj/ds/HDU%202871%20Memory%20Control%EF%BC%88%E7%BA%BF%E6%AE%B5%E6%A0%91%C2%B7%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6%C2%B7Vector%EF%BC%89/</url>
    <content><![CDATA[<p>题意 模拟内存申请 有n个内存单元 有以下4种操作</p>
<p>Reset 将n个内存单元全部清空</p>
<p>New x 申请一个长度为x的连续内存块 申请成功就输出左端</p>
<p>Free x 将x所在的内存块空间释放 释放成功输出释放的内存始末位置</p>
<p>Get x 输出第x个内存块的起始位置</p>
<p>Reset 和 New 都是基本的区间合并知识 比较简单 Free和Get需要知道内层块的位置 所以我们在New的时候要将申请的内存块的始末位置都存起来 两个内层块不会相交 这样就能通过二分找到需要的内层块了 Free后要删去对应的内存块 用vector是为了使Get操作能在O(1)时间内完成 用List的话插入删除快一些但是Get就慢了 所以随便用什么来保存被占的内层块 相对来说vector比较容易实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define lc p&lt;&lt;<span class="number">1</span>, s, mid</span><br><span class="line">#define lp p&lt;&lt;<span class="number">1</span></span><br><span class="line">#define rc p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid + <span class="number">1</span>, e</span><br><span class="line">#define rp p&lt;&lt;<span class="number">1</span>|<span class="number">1</span></span><br><span class="line">#define mid ((s+e)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">50005</span>;</span><br><span class="line">int len[N &lt;&lt; <span class="number">2</span>], lle[N &lt;&lt; <span class="number">2</span>], lri[N &lt;&lt; <span class="number">2</span>], setv[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">struct <span class="title class_">Block</span> <span class="comment">//内层块结构体</span></span><br><span class="line">&#123;</span><br><span class="line">    int l, r;</span><br><span class="line">    bool operator&lt; (<span class="keyword">const</span> <span class="title class_">Block</span> &amp;b) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; b.<span class="property">l</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; block;</span><br><span class="line">vector&lt;<span class="title class_">Block</span>&gt; vb;</span><br><span class="line">vector&lt;<span class="title class_">Block</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pushup</span>(<span class="params">int p, int s, int e</span>)</span><br><span class="line">&#123;</span><br><span class="line">    len[p] = <span class="title function_">max</span>(len[lp], len[rp]);</span><br><span class="line">    len[p] = <span class="title function_">max</span>(len[p], lri[lp] + lle[rp]);</span><br><span class="line">    lle[p] = lle[lp], lri[p] = lri[rp];</span><br><span class="line">    <span class="keyword">if</span>(lle[p] == mid - s + <span class="number">1</span>) lle[p] += lle[rp];</span><br><span class="line">    <span class="keyword">if</span>(lri[p] == e - mid)  lri[p] += lri[lp];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pushdown</span>(<span class="params">int p, int s, int e</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(setv[p] == -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    setv[lp] = setv[rp] = setv[p];</span><br><span class="line">    len[lp] = lle[lp] = lri[lp] = setv[p] * (mid - s + <span class="number">1</span>);</span><br><span class="line">    len[rp] = lle[rp] = lri[rp] = setv[p] * (e - mid);</span><br><span class="line">    setv[p] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">build</span>(<span class="params">int p, int s, int e</span>)</span><br><span class="line">&#123;</span><br><span class="line">    setv[p] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s == e)</span><br><span class="line">    &#123;</span><br><span class="line">        len[p] = lle[p] = lri[p] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">build</span>(lc);</span><br><span class="line">    <span class="title function_">build</span>(rc);</span><br><span class="line">    <span class="title function_">pushup</span>(p, s, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span>(<span class="params">int p, int s, int e, int l, int r, int v</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= s &amp;&amp; e &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        setv[p] = v;</span><br><span class="line">        len[p] = lle[p] = lri[p] = v * (e - s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">pushdown</span>(p, s, e);</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="title function_">update</span>(lc, l, r, v);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="title function_">update</span>(rc, l, r, v);</span><br><span class="line">    <span class="title function_">pushup</span>(p, s, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">query</span>(<span class="params">int p, int s, int e, int v</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == e) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="title function_">pushdown</span>(p, s, e);</span><br><span class="line">    <span class="keyword">if</span>(len[lp] &gt;= v) <span class="keyword">return</span> <span class="title function_">query</span>(lc, v);</span><br><span class="line">    <span class="keyword">if</span>(lri[lp] + lle[rp] &gt;= v) <span class="keyword">return</span> mid + <span class="number">1</span> - lri[lp];</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">query</span>(rc, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, m, x, p;</span><br><span class="line">    char op[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        vb.<span class="title function_">clear</span>();</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;R&#x27;</span>) <span class="comment">//Reset</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="title function_">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, n, <span class="number">1</span>); <span class="comment">//用build会TLE</span></span><br><span class="line">                vb.<span class="title function_">clear</span>();</span><br><span class="line">                <span class="title function_">puts</span>(<span class="string">&quot;Reset Now&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;N&#x27;</span>)  <span class="comment">//New</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">                <span class="keyword">if</span>(len[<span class="number">1</span>] &lt; x) <span class="title function_">puts</span>(<span class="string">&quot;Reject New&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p = <span class="title function_">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, x);</span><br><span class="line">                    <span class="title function_">printf</span>(<span class="string">&quot;New at %d\n&quot;</span>, p);</span><br><span class="line">                    <span class="title function_">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, p, p + x - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                    block.<span class="property">l</span> = p;</span><br><span class="line">                    block.<span class="property">r</span> = p + x - <span class="number">1</span>;</span><br><span class="line">                    it = <span class="title function_">upper_bound</span>(vb.<span class="title function_">begin</span>(), vb.<span class="title function_">end</span>(), block);</span><br><span class="line">                    <span class="comment">//找到第一个起点大于p的位置 确保插入后还是升序的</span></span><br><span class="line">                    vb.<span class="title function_">insert</span>(it, block);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;G&#x27;</span>)  <span class="comment">//Get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">                <span class="keyword">if</span>(x &gt; vb.<span class="title function_">size</span>()) <span class="title function_">puts</span>(<span class="string">&quot;Reject Get&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="title function_">printf</span>(<span class="string">&quot;Get at %d\n&quot;</span>, vb[x - <span class="number">1</span>].<span class="property">l</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span>) <span class="comment">//Free</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">                block.<span class="property">l</span> = block.<span class="property">r</span> = x;</span><br><span class="line">                it = <span class="title function_">upper_bound</span>(vb.<span class="title function_">begin</span>(), vb.<span class="title function_">end</span>(), block);</span><br><span class="line">                int i = it - vb.<span class="title function_">begin</span>() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; <span class="number">0</span> || vb[i].<span class="property">r</span> &lt; x) <span class="title function_">puts</span>(<span class="string">&quot;Reject Free&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="title function_">printf</span>(<span class="string">&quot;Free from %d to %d\n&quot;</span>, vb[i].<span class="property">l</span>, vb[i].<span class="property">r</span>);</span><br><span class="line">                    <span class="title function_">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, vb[i].<span class="property">l</span>, vb[i].<span class="property">r</span>, <span class="number">1</span>);</span><br><span class="line">                    vb.<span class="title function_">erase</span>(--it);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Memory-Control"><a href="#Memory-Control" class="headerlink" title="Memory Control"></a>Memory Control</h1><p>Problem Description</p>
<p>Memory units are numbered from 1 up to N.<br>A sequence of memory units is called a memory block.<br>The memory control system we consider now has four kinds of operations:</p>
<ol>
<li>Reset Reset all memory units free.</li>
<li>New x Allocate a memory block consisted of x continuous free memory units with the least start number</li>
<li>Free x Release the memory block which includes unit x</li>
<li>Get x Return the start number of the xth memory block(Note that we count the memory blocks allocated from left to right)<br>Where 1&lt;&#x3D;x&lt;&#x3D;N.You are request to find out the output for M operations.<br>Input</li>
</ol>
<p>Input contains multiple cases.<br>Each test case starts with two integer N,M(1&lt;&#x3D;N,M&lt;&#x3D;50000) ,indicating that there are N units of memory and M operations.<br>Follow by M lines,each line contains one operation as describe above.<br>Output</p>
<p>For each “Reset” operation, output “Reset Now”.<br>For each “New” operation, if it’s possible to allocate a memory block,<br>output “New at A”,where Ais the least start number,otherwise output “Reject New”.<br>For each “Free” operation, if it’s possible to find a memory block occupy unit x,<br>output “Free from A to B”,where A and B refer to the start and end number of the memory block,otherwise output “Reject Free”.<br>For each “Get” operation, if it’s possible to find the xth memory blocks,<br>output “Get at A”,where A is its start number,otherwise output “Reject Get”.<br>Output one blank line after each test case.<br>Sample Input</p>
<p>6 10 New 2 New 5 New 2 New 2 Free 3 Get 1 Get 2 Get 3 Free 3 Reset<br>Sample Output</p>
<p>New at 1 Reject New New at 3 New at 5 Free from 3 to 4 Get at 1 Get at 5 Reject Get Reject Free Reset Now</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 3265 Posters（线段树扫描线·矩形框面积并）</title>
    <url>/posts/oj/ds/HDU%203265%20Posters%EF%BC%88%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%89%AB%E6%8F%8F%E7%BA%BF%C2%B7%E7%9F%A9%E5%BD%A2%E6%A1%86%E9%9D%A2%E7%A7%AF%E5%B9%B6%EF%BC%89/</url>
    <content><![CDATA[<p>题意 把一些矩形海报挖去一部分小矩形贴在指定位置 问最后海报覆盖的面积</p>
<p>一个矩形框可以分割成4个独立的小矩形 然后就能用扫描线求面积并了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">100005</span>, M = N &lt;&lt; <span class="number">2</span>;</span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">struct <span class="title class_">SLine</span></span><br><span class="line">&#123;</span><br><span class="line">    int x, y1, y2, flag;</span><br><span class="line">    <span class="title class_">SLine</span>() &#123;&#125;;</span><br><span class="line">    <span class="title class_">SLine</span>(int xx, int a, int b, int f) :</span><br><span class="line">        <span class="title function_">x</span>(xx), <span class="title function_">y1</span>(a), <span class="title function_">y2</span>(b), <span class="title function_">flag</span>(<span class="params">f</span>) &#123;&#125;</span><br><span class="line">    bool operator&lt; (<span class="keyword">const</span> <span class="title class_">SLine</span> &amp;s) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; s.<span class="property">x</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; line[N &lt;&lt; <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">int len[M], cnt[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pushup</span>(<span class="params">int p, int s, int e</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt[p]) len[p] = e - s + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s == e) len[p] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> len[p] = len[p &lt;&lt; <span class="number">1</span>] + len[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span>(<span class="params">int p, int s, int e, int l, int r, int v</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt; l) <span class="keyword">return</span>; <span class="comment">//分割后矩形有y1 = y2 的情况</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= s &amp;&amp; e &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt[p] += v;</span><br><span class="line">        <span class="title function_">pushup</span>(p, s, e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid = (s + e) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="title function_">update</span>(p &lt;&lt; <span class="number">1</span>, s, mid, l, r, v);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="title function_">update</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, e, l, r, v);</span><br><span class="line">    <span class="title function_">pushup</span>(p, s, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, m, x1, y1, x2, y2, x3, y3, x4, y4, f;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x3, &amp;y3, &amp;x4, &amp;y4);</span><br><span class="line">            <span class="comment">//将矩形框分成4个矩形</span></span><br><span class="line">            line[m++] = <span class="title class_">SLine</span>(x1, y1, y2, <span class="number">1</span>);</span><br><span class="line">            line[m++] = <span class="title class_">SLine</span>(x3, y1, y2, -<span class="number">1</span>);</span><br><span class="line">            line[m++] = <span class="title class_">SLine</span>(x4, y1, y2, <span class="number">1</span>);</span><br><span class="line">            line[m++] = <span class="title class_">SLine</span>(x2, y1, y2, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            line[m++] = <span class="title class_">SLine</span>(x1, y1, y3, <span class="number">1</span>);</span><br><span class="line">            line[m++] = <span class="title class_">SLine</span>(x2, y1, y3, -<span class="number">1</span>);</span><br><span class="line">            line[m++] = <span class="title class_">SLine</span>(x1, y4, y2, <span class="number">1</span>);</span><br><span class="line">            line[m++] = <span class="title class_">SLine</span>(x2, y4, y2, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">sort</span>(line, line + m);</span><br><span class="line"></span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">update</span>(<span class="number">1</span>, <span class="number">1</span>, N, line[i].<span class="property">y1</span> + <span class="number">1</span>, line[i].<span class="property">y2</span>, line[i].<span class="property">flag</span>);</span><br><span class="line">            ans += <span class="title function_">ll</span>(len[<span class="number">1</span>]) * (line[i + <span class="number">1</span>].<span class="property">x</span> - line[i].<span class="property">x</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Last modified :  2015-08-14 14:29 CST</span></span><br></pre></td></tr></table></figure>

<h1 id="Posters"><a href="#Posters" class="headerlink" title="Posters"></a>Posters</h1><p>Problem Description</p>
<p>Ted has a new house with a huge window. In this big summer, Ted decides to decorate the window with some posters to prevent the glare outside. All things that Ted can find are rectangle posters.<br>However, Ted is such a picky guy that in every poster he finds something ugly. So before he pastes a poster on the window, he cuts a rectangular hole on that poster to remove the ugly part. Ted is also a careless guy so that some of the pasted posters may overlap when he pastes them on the window.<br>Ted wants to know the total area of the window covered by posters. Now it is your job to figure it out.<br>To make your job easier, we assume that the window is a rectangle located in a rectangular coordinate system. The window’s bottom-left corner is at position (0, 0) and top-right corner is at position (50000, 50000). The edges of the window, the edges of the posters and the edges of the holes on the posters are all parallel with the coordinate axes.<br>Input</p>
<p>The input contains several test cases. For each test case, the first line contains a single integer N (0&lt;N&lt;&#x3D;50000), representing the total number of posters. Each of the following N lines contains 8 integers x1, y1, x2, y2, x3, y3, x4, y4, showing details about one poster. (x1, y1) is the coordinates of the poster’s bottom-left corner, and (x2, y2) is the coordinates of the poster’s top-right corner. (x3, y3) is the coordinates of the hole’s bottom-left corner, while (x4, y4) is the coordinates of the hole’s top-right corner. It is guaranteed that 0&lt;&#x3D;xi, yi&lt;&#x3D;50000(i&#x3D;1…4) and x1&lt;&#x3D;x3&lt;x4&lt;&#x3D;x2, y1&lt;&#x3D;y3&lt;y4&lt;&#x3D;y2.<br>The input ends with a line of single zero.<br>Output</p>
<p>For each test case, output a single line with the total area of window covered by posters.<br>Sample Input</p>
<p>2 0 0 10 10 1 1 9 9 2 2 8 8 3 3 7 7 0<br>Sample Output</p>
<p>56</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 3308 LCIS (线段树·单点更新·区间合并)</title>
    <url>/posts/oj/ds/HDU%203308%20LCIS%20(%E7%BA%BF%E6%AE%B5%E6%A0%91%C2%B7%E5%8D%95%E7%82%B9%E6%9B%B4%E6%96%B0%C2%B7%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6)/</url>
    <content><![CDATA[<p>题意 给你一个数组 有更新值和查询两种操作 对于每次查询 输出对应区间的最长连续递增子序列的长度</p>
<p>基础的线段树区间合并 线段树维护三个值 对应区间的LCIS长度(lcis) 对应区间以左端点为起点的LCIS长度(lle) 对应区间以右端点为终点的LCIS长度(lri) 然后用val存储数组对应位置的值 当val[mid + 1] &gt; val[mid] 的时候就要进行区间合并操作了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define lc lp, s, mid</span><br><span class="line">#define rc rp, mid+<span class="number">1</span>, e</span><br><span class="line">#define lp p&lt;&lt;<span class="number">1</span></span><br><span class="line">#define rp p&lt;&lt;<span class="number">1</span>|<span class="number">1</span></span><br><span class="line">#define mid ((s+e)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">100005</span>, M = N * <span class="number">4</span>;</span><br><span class="line">int lcis[M], lle[M], lri[M], val[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pushup</span>(<span class="params">int p, int s, int e</span>)</span><br><span class="line">&#123;</span><br><span class="line">    lcis[p] = <span class="title function_">max</span>(lcis[lp], lcis[rp]);</span><br><span class="line">    lle[p] = lle[lp], lri[p] = lri[rp];</span><br><span class="line">    <span class="keyword">if</span>(val[mid + <span class="number">1</span>] &gt; val[mid]) <span class="comment">//合并条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        lcis[p] = <span class="title function_">max</span>(lcis[p], lri[lp] + lle[rp]);</span><br><span class="line">        <span class="keyword">if</span>(lle[lp] == mid + <span class="number">1</span> - s) lle[p] += lle[rp];</span><br><span class="line">        <span class="keyword">if</span>(lri[rp] == e - mid) lri[p] += lri[lp];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">build</span>(<span class="params">int p, int s, int e</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == e)</span><br><span class="line">    &#123;</span><br><span class="line">        lcis[p] = lle[p] = lri[p] = <span class="number">1</span>;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;val[s]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">build</span>(lc);</span><br><span class="line">    <span class="title function_">build</span>(rc);</span><br><span class="line">    <span class="title function_">pushup</span>(p, s, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span>(<span class="params">int p, int s, int e, int x, int v</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == e)</span><br><span class="line">    &#123;</span><br><span class="line">        val[s] = v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="title function_">update</span>(lc, x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x &gt; mid) <span class="title function_">update</span>(rc, x, v);</span><br><span class="line">    <span class="title function_">pushup</span>(p, s, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">query</span>(<span class="params">int p, int s, int e, int l, int r</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= s &amp;&amp; e &lt;= r) <span class="keyword">return</span> lcis[p];</span><br><span class="line">    int ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(val[mid + <span class="number">1</span>] &gt; val[mid])</span><br><span class="line">        ret = <span class="title function_">min</span>(r, mid + lle[rp]) - <span class="title function_">max</span>(l, mid + <span class="number">1</span> - lri[lp]) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)  ret = <span class="title function_">max</span>(ret, <span class="title function_">query</span>(lc, l, r));</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)  ret = <span class="title function_">max</span>(ret, <span class="title function_">query</span>(rc, l, r));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int T, n, m, a, b;</span><br><span class="line">    char op[<span class="number">5</span>];</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="title function_">build</span>(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="title function_">query</span>(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, a, b));</span><br><span class="line">            <span class="keyword">else</span> <span class="title function_">update</span>(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LCIS"><a href="#LCIS" class="headerlink" title="LCIS"></a>LCIS</h1><p>Problem Description</p>
<p>Given n integers.<br>You have two operations:<br>U A B: replace the Ath number by B. (index counting from 0)<br>Q A B: output the length of the longest consecutive increasing subsequence (LCIS) in [a, b].<br>Input</p>
<p>T in the first line, indicating the case number.<br>Each case starts with two integers n , m(0&lt;n,m&lt;&#x3D;10 5).<br>The next line has n integers(0&lt;&#x3D;val&lt;&#x3D;10 5).<br>The next m lines each has an operation:<br>U A B(0&lt;&#x3D;A,n , 0&lt;&#x3D;B&#x3D;10 5)<br>OR<br>Q A B(0&lt;&#x3D;A&lt;&#x3D;B&lt; n).<br>Output</p>
<p>For each Q, output the answer.<br>Sample Input</p>
<p>1 10 10 7 7 3 3 5 9 9 8 1 8 Q 6 6 U 3 4 Q 0 1 Q 0 5 Q 4 7 Q 3 5 Q 0 2 Q 4 6 U 6 10 Q 0 9<br>Sample Output</p>
<p>1 1 4 2 3 1 2 5</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 3397 Sequence operation（线段树·成段更新·区间合并·混合操作）</title>
    <url>/posts/oj/ds/HDU%203397%20Sequence%20operation%EF%BC%88%E7%BA%BF%E6%AE%B5%E6%A0%91%C2%B7%E6%88%90%E6%AE%B5%E6%9B%B4%E6%96%B0%C2%B7%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6%C2%B7%E6%B7%B7%E5%90%88%E6%93%8D%E4%BD%9C%EF%BC%89/</url>
    <content><![CDATA[<p>题意 给你一个只有0, 1的数组 有这些操作</p>
<ol start="0">
<li><p>将[a, b]区间的所有数都改为0</p>
</li>
<li><p>将[a, b]区间的所有数都改为1</p>
</li>
<li><p>将[a, b]区间的所有数都取反 即与1异或</p>
</li>
<li><p>输出区间[a, b]中1的个数 即所有数的和</p>
</li>
<li><p>输出区间[a, b]中最大连续1的长度</p>
</li>
</ol>
<p>对于所有的3, 4操作输出对应的答案</p>
<p>单个的操作都很简单 但搞在一起就有点恶心了 还好数组里的数只有0和1</p>
<p>线段树维护9个值 对应区间0, 1的最大长度len[i] 对应区间左端点为起点的最大0, 1长度lle[i] 对应区间右端点为终点的最大0, 1长度 对应区间的1的个数sum 对应区间的置值标记setv 对应区间的取反标记opp</p>
<p>成段更新时有两种操作 取反 (opp) 和置值 (setv) 取反操作时因为是0, 1互换 将维护的对应的信息也交换就行了 sum就变成长度减去sum了 置值操作比较简单 但是要注意置值操作前的所有取反操作都是没有意义的 所以置值的时候要将对应区间的取反标记去掉</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define lc p&lt;&lt;<span class="number">1</span>, s, mid</span><br><span class="line">#define rc p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, e</span><br><span class="line">#define lp p&lt;&lt;<span class="number">1</span></span><br><span class="line">#define rp p&lt;&lt;<span class="number">1</span>|<span class="number">1</span></span><br><span class="line">#define mid ((s+e)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">100005</span>, M = N * <span class="number">4</span>;</span><br><span class="line"><span class="comment">//最大连续i的长度 左端连续长度 右端连续长度</span></span><br><span class="line">int len[<span class="number">2</span>][M], lle[<span class="number">2</span>][M], lri[<span class="number">2</span>][M];</span><br><span class="line">int opp[M], setv[M], sum[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">swap01</span>(int p)  <span class="comment">//将p对应区间的01信息交换</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">swap</span>(len[<span class="number">0</span>][p], len[<span class="number">1</span>][p]);</span><br><span class="line">    <span class="title function_">swap</span>(lle[<span class="number">0</span>][p], lle[<span class="number">1</span>][p]);</span><br><span class="line">    <span class="title function_">swap</span>(lri[<span class="number">0</span>][p], lri[<span class="number">1</span>][p]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setAll</span>(int p, int i, int v) <span class="comment">//将p对应的区间全部置为i</span></span><br><span class="line">&#123;</span><br><span class="line">    int j = <span class="number">1</span> - i;</span><br><span class="line">    len[i][p] = lle[i][p] = lri[i][p] = v;</span><br><span class="line">    len[j][p] = lle[j][p] = lri[j][p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pushup</span>(<span class="params">int p, int s, int e</span>)</span><br><span class="line">&#123;</span><br><span class="line">    sum[p] = sum[lp] + sum[rp];</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        len[i][p] = <span class="title function_">max</span>(len[i][lp], len[i][rp]);</span><br><span class="line">        lle[i][p] = lle[i][lp], lri[i][p] = lri[i][rp];</span><br><span class="line">        <span class="keyword">if</span>(lri[i][lp] &amp;&amp; lle[i][rp]) <span class="comment">//左右孩子边界可连接</span></span><br><span class="line">        &#123;</span><br><span class="line">            len[i][p] = <span class="title function_">max</span>(len[i][p], lri[i][lp] + lle[i][rp]);</span><br><span class="line">            <span class="keyword">if</span>(lle[i][lp] == mid + <span class="number">1</span> - s) lle[i][p] += lle[i][rp];</span><br><span class="line">            <span class="keyword">if</span>(lri[i][rp] == e - mid) lri[i][p] += lri[i][lp];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">build</span>(<span class="params">int p, int s, int e</span>)</span><br><span class="line">&#123;</span><br><span class="line">    opp[p] = <span class="number">0</span>;</span><br><span class="line">    setv[p] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s == e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;sum[p]);</span><br><span class="line">        int i = sum[p];</span><br><span class="line">        <span class="title function_">setAll</span>(p, i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">build</span>(lc);</span><br><span class="line">    <span class="title function_">build</span>(rc);</span><br><span class="line">    <span class="title function_">pushup</span>(p, s, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pushdown</span>(<span class="params">int p, int s, int e</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(setv[p] != -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        int i = setv[lp] = setv[rp] = setv[p];</span><br><span class="line">        opp[lp] = opp[rp] = <span class="number">0</span>;</span><br><span class="line">        sum[lp] = i * (mid + <span class="number">1</span> - s);</span><br><span class="line">        sum[rp] = i * (e - mid);</span><br><span class="line"></span><br><span class="line">        <span class="title function_">setAll</span>(lp, i, mid + <span class="number">1</span> - s);</span><br><span class="line">        <span class="title function_">setAll</span>(rp, i, e-mid);</span><br><span class="line">        setv[p] = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(opp[p])</span><br><span class="line">    &#123;</span><br><span class="line">        opp[lp] ^= <span class="number">1</span>;</span><br><span class="line">        opp[rp] ^= <span class="number">1</span>;</span><br><span class="line">        sum[lp] = mid + <span class="number">1</span> - s - sum[lp];</span><br><span class="line">        sum[rp] = e - mid - sum[rp];</span><br><span class="line"></span><br><span class="line">        <span class="title function_">swap01</span>(lp);</span><br><span class="line">        <span class="title function_">swap01</span>(rp);</span><br><span class="line">        opp[p] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span>(<span class="params">int p, int s, int e, int l, int r, int v</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= s &amp;&amp; e &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(v == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            opp[p] ^= <span class="number">1</span>;</span><br><span class="line">            sum[p] = e - s + <span class="number">1</span> - sum[p];</span><br><span class="line">            <span class="title function_">swap01</span>(p);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            int i = setv[p] = v;</span><br><span class="line">            opp[p] = <span class="number">0</span>;</span><br><span class="line">            sum[p] = v * (e - s + <span class="number">1</span>);</span><br><span class="line">            <span class="title function_">setAll</span>(p, i, e - s + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">pushdown</span>(p, s, e);</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="title function_">update</span>(lc, l, r, v);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="title function_">update</span>(rc, l, r, v);</span><br><span class="line">    <span class="title function_">pushup</span>(p, s, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">query</span>(<span class="params">int p, int s, int e, int l, int r, int op</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= s &amp;&amp; e &lt;= r) <span class="keyword">return</span> op == <span class="number">3</span> ? sum[p] : len[<span class="number">1</span>][p];</span><br><span class="line">    <span class="title function_">pushdown</span>(p, s, e);</span><br><span class="line">    int ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(op == <span class="number">3</span>)  <span class="comment">//the number of &#x27;1&#x27;s</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= mid) ret += <span class="title function_">query</span>(lc, l, r, op);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; mid) ret += <span class="title function_">query</span>(rc, l, r, op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// the length of &#x27;1&#x27;s</span></span><br><span class="line">    &#123;</span><br><span class="line">        ret = <span class="title function_">max</span>(ret, <span class="title function_">min</span>(r, mid + lle[<span class="number">1</span>][rp]) - <span class="title function_">max</span>(l, mid + <span class="number">1</span> - lri[<span class="number">1</span>][lp]) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= mid) ret = <span class="title function_">max</span>(ret, <span class="title function_">query</span>(lc, l, r, op));</span><br><span class="line">        <span class="keyword">if</span>(r &gt; mid) ret = <span class="title function_">max</span>(ret, <span class="title function_">query</span>(rc, l, r, op));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int T, n, m, a, b, op;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="title function_">build</span>(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;op, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">if</span>(op &lt; <span class="number">3</span>) <span class="title function_">update</span>(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, a, b, op);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="title function_">query</span>(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, a, b, op));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Last modified :  2015-08-12 09:10 CST</span></span><br></pre></td></tr></table></figure>

<h1 id="Sequence-operation"><a href="#Sequence-operation" class="headerlink" title="Sequence operation"></a>Sequence operation</h1><p>Problem Description</p>
<p>lxhgww got a sequence contains n characters which are all ‘0’s or ‘1’s.<br>We have five operations here:<br>Change operations:<br>0 a b change all characters into ‘0’s in [a , b]<br>1 a b change all characters into ‘1’s in [a , b]<br>2 a b change all ‘0’s into ‘1’s and change all ‘1’s into ‘0’s in [a, b]<br>Output operations:<br>3 a b output the number of ‘1’s in [a, b]<br>4 a b output the length of the longest continuous ‘1’ string in [a , b]<br>Input</p>
<p>T(T&lt;&#x3D;10) in the first line is the case number.<br>Each case has two integers in the first line: n and m (1 &lt;&#x3D; n , m &lt;&#x3D; 100000).<br>The next line contains n characters, ‘0’ or ‘1’ separated by spaces.<br>Then m lines are the operations:<br>op a b: 0 &lt;&#x3D; op &lt;&#x3D; 4 , 0 &lt;&#x3D; a &lt;&#x3D; b &lt; n.<br>Output</p>
<p>For each output operation , output the result.<br>Sample Input</p>
<p>1 10 10 0 0 0 1 1 0 1 0 1 1 1 0 2 3 0 5 2 2 2 4 0 4 0 3 6 2 3 7 4 2 8 1 0 5 0 5 6 3 3 9<br>Sample Output</p>
<p>5 2 6 5</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 3634 City Planning (离散化)</title>
    <url>/posts/oj/ds/HDU%203634%20City%20Planning%20(%E7%A6%BB%E6%95%A3%E5%8C%96)/</url>
    <content><![CDATA[<p>题意 给你n个矩形 每个矩形都有自己的value 你可以任意改变矩形的表里关系 被覆盖的地方的value取最表层的 求总value的最大值</p>
<p>刚看了扫描线 感觉这个可以用扫描线做就直接写了 其实直接离散化就行了 因为最多也就20个矩形 那坐标最多也就40个 那我们对坐标进行离散化 然后将矩形按value从小到大一个个的放 暴力更新覆盖格子的value 最后直接将2n &#x2F;* 2n个小格子的value加起来就行了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">50</span>;</span><br><span class="line">int y[N], x[N], n, m;</span><br><span class="line">ll val[N][N];</span><br><span class="line"></span><br><span class="line">struct <span class="title class_">Rect</span></span><br><span class="line">&#123;</span><br><span class="line">    int x1, y1, x2, y2, v;</span><br><span class="line">    bool operator&lt; (<span class="keyword">const</span> <span class="title class_">Rect</span> &amp;r) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v &lt; r.<span class="property">v</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; r[N];</span><br><span class="line"></span><br><span class="line">int <span class="title function_">fid</span>(<span class="params">int a[], int k</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">lower_bound</span>(a, a + m, k) - a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int T, x1, y1, x2, y2, cas = <span class="number">0</span>;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(int i = m = <span class="number">0</span>; i &lt; n; ++i, m += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>, &amp;r[i].<span class="property">x1</span>, &amp;r[i].<span class="property">y1</span>, &amp;r[i].<span class="property">x2</span>, &amp;r[i].<span class="property">y2</span>, &amp;r[i].<span class="property">v</span>);</span><br><span class="line">            x[m] = r[i].<span class="property">x1</span>, x[m + <span class="number">1</span>] = r[i].<span class="property">x2</span>;</span><br><span class="line">            y[m] = r[i].<span class="property">y1</span>, y[m + <span class="number">1</span>] = r[i].<span class="property">y2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">sort</span>(r, r + n); <span class="comment">//将value小的大楼放前面</span></span><br><span class="line">        <span class="title function_">sort</span>(x, x + m); <span class="comment">//离散化x</span></span><br><span class="line">        <span class="title function_">sort</span>(y, y + m); <span class="comment">//离散化y</span></span><br><span class="line"></span><br><span class="line">        <span class="title function_">memset</span>(val, <span class="number">0</span>, <span class="title function_">sizeof</span>(val));</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            x1 = <span class="title function_">fid</span>(x, r[i].<span class="property">x1</span>), x2 = <span class="title function_">fid</span>(x, r[i].<span class="property">x2</span>);  <span class="comment">//获得x离散化后的坐标</span></span><br><span class="line">            y1 = <span class="title function_">fid</span>(y, r[i].<span class="property">y1</span>), y2 = <span class="title function_">fid</span>(y, r[i].<span class="property">y2</span>);  <span class="comment">//获得y离散化后的坐标</span></span><br><span class="line">            <span class="keyword">for</span>(int j = x1; j &lt; x2; ++j)</span><br><span class="line">                <span class="keyword">for</span>(int k = y1; k &lt; y2; ++k)  val[j][k] = r[i].<span class="property">v</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; ++i)</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; m - <span class="number">1</span>; ++j)</span><br><span class="line">                ans += val[i][j] * (x[i + <span class="number">1</span>] - x[i]) * (y[j + <span class="number">1</span>] - y[j]);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;Case %d: %I64d\n&quot;</span>, ++cas, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有扫描线a的代码 用扫描线的时候是将矩形value从大到小排序 每放置一个矩形 看面积改变了多少 然后就用value乘以这个改变的面积</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define lc p&lt;&lt;<span class="number">1</span>, s, mid</span><br><span class="line">#define rc p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, e</span><br><span class="line">#define mid ((s+e)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">50</span>;</span><br><span class="line">int y[N], flag[N * <span class="number">2</span>], len[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">struct <span class="title class_">Rect</span></span><br><span class="line">&#123;</span><br><span class="line">    int x1, y1, x2, y2, v;</span><br><span class="line">    bool operator&lt; (<span class="keyword">const</span> <span class="title class_">Rect</span> &amp;r) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> v &gt; r.<span class="property">v</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; r[N];</span><br><span class="line"></span><br><span class="line">struct <span class="title class_">SLine</span></span><br><span class="line">&#123;</span><br><span class="line">    int x, y1, y2, flag;</span><br><span class="line">    <span class="title class_">SLine</span>() &#123;&#125;</span><br><span class="line">    <span class="title class_">SLine</span>(int xx, int a, int b, int f):</span><br><span class="line">        <span class="title function_">x</span>(xx), <span class="title function_">y1</span>(a), <span class="title function_">y2</span>(b), <span class="title function_">flag</span>(<span class="params">f</span>) &#123;&#125;</span><br><span class="line">    bool operator&lt; (<span class="keyword">const</span> <span class="title class_">SLine</span> &amp;s) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; s.<span class="property">x</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; line[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">build</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">memset</span>(flag, <span class="number">0</span>, <span class="title function_">sizeof</span>(flag));</span><br><span class="line">    <span class="title function_">memset</span>(len, <span class="number">0</span>, <span class="title function_">sizeof</span>(len));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pushup</span>(<span class="params">int p, int s, int e</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag[p]) len[p] = y[e] - y[s - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s == e) len[p] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> len[p] = len[p &lt;&lt; <span class="number">1</span>] + len[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span>(<span class="params">int p, int s, int e, int l, int r, int v</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= s &amp;&amp; e &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        flag[p] += v;</span><br><span class="line">        <span class="title function_">pushup</span>(p, s, e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="title function_">update</span>(lc, l, r, v);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="title function_">update</span>(rc, l, r, v);</span><br><span class="line">    <span class="title function_">pushup</span>(p, s, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int T, n, m, cas = <span class="number">0</span>;</span><br><span class="line">    int x1, y1, x2, y2, v;</span><br><span class="line">    ll ans;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>, &amp;r[i].<span class="property">x1</span>, &amp;r[i].<span class="property">y1</span>, &amp;r[i].<span class="property">x2</span>, &amp;r[i].<span class="property">y2</span>, &amp;r[i].<span class="property">v</span>);</span><br><span class="line">        <span class="title function_">sort</span>(r, r + n);</span><br><span class="line">        ll ans = <span class="number">0</span>, last = <span class="number">0</span>, area;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(int i = m = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">build</span>();</span><br><span class="line">            area = <span class="number">0</span>;</span><br><span class="line">            y[m] = r[i].<span class="property">y1</span>, y[m + <span class="number">1</span>] = r[i].<span class="property">y2</span>;</span><br><span class="line">            line[m++] = <span class="title class_">SLine</span>(r[i].<span class="property">x1</span>, r[i].<span class="property">y1</span>, r[i].<span class="property">y2</span>, <span class="number">1</span>);</span><br><span class="line">            line[m++] = <span class="title class_">SLine</span>(r[i].<span class="property">x2</span>, r[i].<span class="property">y1</span>, r[i].<span class="property">y2</span>, -<span class="number">1</span>);</span><br><span class="line">            <span class="title function_">sort</span>(y, y + m);</span><br><span class="line">            <span class="title function_">sort</span>(line, line + m);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; m - <span class="number">1</span>; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                int l = <span class="title function_">lower_bound</span>(y, y + m, line[j].<span class="property">y1</span>) - y;</span><br><span class="line">                int r = <span class="title function_">lower_bound</span>(y, y + m, line[j].<span class="property">y2</span>) - y;</span><br><span class="line">                <span class="title function_">update</span>(<span class="number">1</span>, <span class="number">1</span>, m, l + <span class="number">1</span>, r, line[j].<span class="property">flag</span>);</span><br><span class="line">                area += len[<span class="number">1</span>] * (line[j + <span class="number">1</span>].<span class="property">x</span> - line[j].<span class="property">x</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans += (area - last) * r[i].<span class="property">v</span>;</span><br><span class="line">            last = area;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;Case %d: %I64d\n&quot;</span>, ++cas, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="City-Planning"><a href="#City-Planning" class="headerlink" title="City Planning"></a>City Planning</h1><p>Problem Description</p>
<p>After many years, the buildings in HDU has become very old. It need to rebuild the buildings now. So Mr dragon (the president of HDU’s logistics department ) ask Mr Wan (a very famous engineer) for help.<br>Mr Wan only draw one building on a construction design drawings(all the buildings are rectangle and each edge of buildings’ is paraller or perpendicular to others buildings’ edge ). And total draw n drawings (all the drawings have same width and length . And bottomleft point is (0, 0)). Due to possible overlap of conditions, so when they build a new building, they should to remove all the overlapping part of it. And for each building, HDU have a jury evaluate the value per unit area. Now Mr dragon want to know how to arrange the order of build these buildings can make the highest value.<br>Input</p>
<p>The first line of input is a number T which indicate the number of cases . (1 &lt; T &lt; 3000);<br>Each test case will begin with a single line containing a single integer n (where 1 &lt;&#x3D; n &lt;&#x3D; 20).<br>Next n line will contain five integers x1, y1, x2, y2 ,value . x1,y1 is bottomleft point and x2,y2 is topright point , value is the value of the buildings’ unit area.((0 &lt;&#x3D; x1, y1, x2, y2 &lt;&#x3D; 10000) (x1 &lt; x2, &amp;&amp; y1 &lt; y2) (1 &lt;&#x3D; value &lt;&#x3D; 22)<br>Output</p>
<p>For each case. You just ouput the highest value in one line.<br>Sample Input</p>
<p>1 3 1 1 10 10 4 4 4 15 5 5 7 8 20 30 6<br>Sample Output</p>
<p>Case 1: 2047</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 3974 Assign the task(树 并查集)</title>
    <url>/posts/oj/ds/HDU%203974%20Assign%20the%20task(%E6%A0%91%20%E5%B9%B6%E6%9F%A5%E9%9B%86)/</url>
    <content><![CDATA[<p>题意 公司中有n个员工 除了boss 每个员工都有自己的上司 自己下属的下属也是自己的下属 当给一个员工分配任务时 这个员工会把任务也分配到自己的所有下属 每个员工都只做最后一个被分配的任务 对于每个C x 输出员工x正在做的任务 没有就输出-1</p>
<p>把员工的关系数建成类似并查集的结构 把每个直接分配任务的员工的任务和任务分配时间保存起来 查询时只要找这个员工所有父节点中最晚分配的任务</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">50005</span>;</span><br><span class="line">struct employee&#123;</span><br><span class="line">    int task, t;</span><br><span class="line">&#125; e[N];</span><br><span class="line">int par[N];</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas, a, b, n, m;</span><br><span class="line">    char op[<span class="number">5</span>];</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">for</span>(int k = <span class="number">1</span>; k &lt;= cas; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;Case #%d:\n&quot;</span>, k);</span><br><span class="line">        <span class="title function_">memset</span>(par, -<span class="number">1</span>, <span class="title function_">sizeof</span>(par));</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            e[i].<span class="property">t</span> = e[i].<span class="property">task</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b), par[a] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        e[n].<span class="property">t</span> = e[n].<span class="property">task</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">        int t = <span class="number">0</span>, last, ans;</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;a);</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                last = <span class="number">0</span>;<span class="comment">//所有祖先节点最晚任务的时间</span></span><br><span class="line">                <span class="keyword">while</span>(a != -<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(e[a].<span class="property">t</span> &gt; last)</span><br><span class="line">                        last = e[a].<span class="property">t</span>, ans = e[a].<span class="property">task</span>;</span><br><span class="line">                    a = par[a];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, last ? ans : -<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b);</span><br><span class="line">                e[a].<span class="property">task</span> = b, e[a].<span class="property">t</span> = ++t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Last modified :   2015-04-22 20:48</span></span><br></pre></td></tr></table></figure>

<h1 id="Assign-the-task"><a href="#Assign-the-task" class="headerlink" title="Assign the task"></a>Assign the task</h1><p>Problem Description</p>
<p>There is a company that has N employees(numbered from 1 to N),every employee in the company has a immediate boss (except for the leader of whole company).If you are the immediate boss of someone,that person is your subordinate, and all his subordinates are your subordinates as well. If you are nobody’s boss, then you have no subordinates,the employee who has no immediate boss is the leader of whole company.So it means the N employees form a tree.<br>The company usually assigns some tasks to some employees to finish.When a task is assigned to someone,He&#x2F;She will assigned it to all his&#x2F;her subordinates.In other words,the person and all his&#x2F;her subordinates received a task in the same time. Furthermore,whenever a employee received a task,he&#x2F;she will stop the current task(if he&#x2F;she has) and start the new one.<br>Write a program that will help in figuring out some employee’s current task after the company assign some tasks to some employee.<br>Input</p>
<p>The first line contains a single positive integer T( T &lt;&#x3D; 10 ), indicates the number of test cases.<br>For each test case:<br>The first line contains an integer N (N ≤ 50,000) , which is the number of the employees.<br>The following N - 1 lines each contain two integers u and v, which means the employee v is the immediate boss of employee u(1&lt;&#x3D;u,v&lt;&#x3D;N).<br>The next line contains an integer M (M ≤ 50,000).<br>The following M lines each contain a message which is either<br>“C x” which means an inquiry for the current task of employee x<br>or<br>“T x y”which means the company assign task y to employee x.<br>(1&lt;&#x3D;x&lt;&#x3D;N,0&lt;&#x3D;y&lt;&#x3D;10^9)<br>Output</p>
<p>For each test case, print the test case number (beginning with 1) in the first line and then for every inquiry, output the correspond answer per line.<br>Sample Input</p>
<p>1 5 4 3 3 2 1 3 5 2 5 C 3 T 2 1 C 3 T 3 2 C 3<br>Sample Output</p>
<p>Case &#x2F;#1: -1 1 2<br>Source</p>
<p><a href="http://acm.hdu.edu.cn/search.php?field=problem&key=2011+Multi-University+Training+Contest+14+-+Host+by+FZU&source=1&searchmode=source">2011 Multi-University Training Contest 14 - Host by FZU</a></p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 4006 The kth great number(优先队列·第K大数)</title>
    <url>/posts/oj/ds/HDU%204006%20The%20kth%20great%20number(%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%C2%B7%E7%AC%ACK%E5%A4%A7%E6%95%B0)/</url>
    <content><![CDATA[<p>题意 动态查询第K大的数</p>
<p>用小数在前优先队列维护K个数 每要插入一个数时 若这个数小于队首元素那么就不用插入了 否则队首元素出队 这个数入队 每次询问只用输出队首元素就行了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, a, k;</span><br><span class="line">    char op[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k))</span><br><span class="line">    &#123;</span><br><span class="line">        priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; pq;</span><br><span class="line">        <span class="keyword">while</span>(n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">                <span class="keyword">if</span>(pq.<span class="title function_">size</span>()&lt;k) pq.<span class="title function_">push</span>(a);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(a &gt; pq.<span class="title function_">top</span>()) pq.<span class="title function_">push</span>(a),pq.<span class="title function_">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pq.<span class="title function_">top</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="The-kth-great-number"><a href="#The-kth-great-number" class="headerlink" title="The kth great number"></a>The kth great number</h1><p>Problem Description</p>
<p>Xiao Ming and Xiao Bao are playing a simple Numbers game. In a round Xiao Ming can choose to write down a number, or ask Xiao Bao what the kth great number is. Because the number written by Xiao Ming is too much, Xiao Bao is feeling giddy. Now, try to help Xiao Bao.<br>Input</p>
<p>There are several test cases. For each test case, the first line of input contains two positive integer n, k. Then n lines follow. If Xiao Ming choose to write down a number, there will be an “ I” followed by a number that Xiao Ming will write down. If Xiao Ming choose to ask Xiao Bao, there will be a “Q”, then you need to output the kth great number.<br>Output</p>
<p>The output consists of one integer representing the largest number of islands that all lie on one line.<br>Sample Input</p>
<p>8 3 I 1 I 2 I 3 Q I 5 Q I 4 Q<br>Sample Output</p>
<p>1 2 3</p>
<p><em>Hint</em>Xiao Ming won’t ask Xiao Bao the kth great number when the number of the written number is smaller than k. (1&#x3D;&lt;k&lt;&#x3D;n&lt;&#x3D;1000000).</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 4027 Can you answer these queries?(线段树 区间不等更新)</title>
    <url>/posts/oj/ds/HDU%204027%20Can%20you%20answer%20these%20queries(%E7%BA%BF%E6%AE%B5%E6%A0%91%20%E5%8C%BA%E9%97%B4%E4%B8%8D%E7%AD%89%E6%9B%B4%E6%96%B0)/</url>
    <content><![CDATA[<p>题意 输入n个数 然后有两种操作 输入0时将给定区间所有数都变为自己的开方 输入1输出给定区间所有数的和</p>
<p>虽然是区间更新 但每个点更新的不一样 因此只能对单点进行更新 其实一个点最多被更新7次 2^64开平方7次后就变为1了 如果某个区间的数都变为了1 那么对这个区间的开方就不用考虑了 另外要注意给你的区间可能是反的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">#define lc p&lt;&lt;<span class="number">1</span>,s,mid</span><br><span class="line">#define rc p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,e</span><br><span class="line">#define mid ((s+e)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long <span class="variable constant_">LL</span>;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">100005</span>;</span><br><span class="line"><span class="variable constant_">LL</span> sum[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pushup</span>(<span class="params">int p</span>)</span><br><span class="line">&#123;</span><br><span class="line">    sum[p] = sum[p &lt;&lt; <span class="number">1</span>] + sum[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">build</span>(<span class="params">int p, int s, int e</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;sum[p]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">build</span>(lc);</span><br><span class="line">    <span class="title function_">build</span>(rc);</span><br><span class="line">    <span class="title function_">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span>(<span class="params">int p, int s, int e, int l, int r</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum[p] == e - s + <span class="number">1</span>) <span class="keyword">return</span>;  <span class="comment">//[e,s]区间所有数都为1</span></span><br><span class="line">    <span class="keyword">if</span>(s == e)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[p] = <span class="title function_">sqrt</span>(sum[p]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="title function_">update</span>(lc, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="title function_">update</span>(rc, l, r);</span><br><span class="line">    <span class="title function_">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">LL</span> <span class="title function_">query</span>(<span class="params">int p, int s, int e, int l, int r</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == l &amp;&amp; e == r) <span class="keyword">return</span> sum[p];</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= mid) <span class="keyword">return</span> <span class="title function_">query</span>(lc, l, r);</span><br><span class="line">    <span class="keyword">if</span>(l &gt; mid) <span class="keyword">return</span> <span class="title function_">query</span>(rc, l, r);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">query</span>(lc, l, mid) + <span class="title function_">query</span>(rc, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, m, a, b, c, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;Case #%d:\n&quot;</span>, ++k);</span><br><span class="line">        <span class="title function_">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;c, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">if</span>(b &lt; a) <span class="title function_">swap</span>(a, b);</span><br><span class="line">            <span class="keyword">if</span>(c) <span class="title function_">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="title function_">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, a, b));</span><br><span class="line">            <span class="keyword">else</span> <span class="title function_">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Can-you-answer-these-queries"><a href="#Can-you-answer-these-queries" class="headerlink" title="Can you answer these queries?"></a>Can you answer these queries?</h1><p>Problem Description</p>
<p>A lot of battleships of evil are arranged in a line before the battle. Our commander decides to use our secret weapon to eliminate the battleships. Each of the battleships can be marked a value of endurance. For every attack of our secret weapon, it could decrease the endurance of a consecutive part of battleships by make their endurance to the square root of it original value of endurance. During the series of attack of our secret weapon, the commander wants to evaluate the effect of the weapon, so he asks you for help.<br>You are asked to answer the queries that the sum of the endurance of a consecutive part of the battleship line.<br>Notice that the square root operation should be rounded down to integer.<br>Input</p>
<p>The input contains several test cases, terminated by EOF.<br>For each test case, the first line contains a single integer N, denoting there are N battleships of evil in a line. (1 &lt;&#x3D; N &lt;&#x3D; 100000)<br>The second line contains N integers Ei, indicating the endurance value of each battleship from the beginning of the line to the end. You can assume that the sum of all endurance value is less than 2 63.<br>The next line contains an integer M, denoting the number of actions and queries. (1 &lt;&#x3D; M &lt;&#x3D; 100000)<br>For the following M lines, each line contains three integers T, X and Y. The T&#x3D;0 denoting the action of the secret weapon, which will decrease the endurance value of the battleships between the X-th and Y-th battleship, inclusive. The T&#x3D;1 denoting the query of the commander which ask for the sum of the endurance value of the battleship between X-th and Y-th, inclusive.<br>Output</p>
<p>For each test case, print the case number at the first line. Then print one line for each query. And remember follow a blank line after each test case.<br>Sample Input</p>
<p>10 1 2 3 4 5 6 7 8 9 10 5 0 1 10 1 1 10 1 1 5 0 5 8 1 4 8<br>Sample Output</p>
<p>Case &#x2F;#1: 19 7 6<br>Source</p>
<p><a href="http://acm.hdu.edu.cn/search.php?field=problem&key=The+36th+ACM/ICPC+Asia+Regional+Shanghai+Site+%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD+Online+Contest&source=1&searchmode=source">The 36th ACM&#x2F;ICPC Asia Regional Shanghai Site —— Online Contest</a></p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1436 Horizontally Visible Segments (线段树·区间染色)</title>
    <url>/posts/oj/ds/POJ%201436%20Horizontally%20Visible%20Segments%20(%E7%BA%BF%E6%AE%B5%E6%A0%91%C2%B7%E5%8C%BA%E9%97%B4%E6%9F%93%E8%89%B2)/</url>
    <content><![CDATA[<p>题意 在坐标系中有n条平行于y轴的线段 当一条线段与另一条线段之间可以连一条平行与x轴的线不与其它线段相交 就视为它们是可见的 问有多少组三条线段两两相互可见</p>
<p>先把所有线段存下来 并按x坐标排序 线段树记录对应区间从右往左当前可见的线段编号(1…n) 超过一条就为0 然后从左往右对每条线段 先查询左边哪些线段和它是可见的 把可见关系存到数组中 然后把这条线段对应区间的最右端可见编号更新为这条线段的编号 最后暴力统计有多少组就行了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#define lc p&lt;&lt;<span class="number">1</span>, s, mid</span><br><span class="line">#define rc p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, e</span><br><span class="line">#define mid ((s+e)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">8005</span>;</span><br><span class="line">int top[N * <span class="number">8</span>];</span><br><span class="line">bool g[N][N];</span><br><span class="line"></span><br><span class="line">struct seg</span><br><span class="line">&#123;</span><br><span class="line">    int y1, y2, x;</span><br><span class="line">&#125; line[N];</span><br><span class="line"></span><br><span class="line">bool <span class="title function_">cmp</span>(<span class="params">seg a, seg b</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="property">x</span> &lt; b.<span class="property">x</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">build</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">memset</span>(g, <span class="number">0</span>, <span class="title function_">sizeof</span>(g));</span><br><span class="line">    <span class="title function_">memset</span>(top, <span class="number">0</span>, <span class="title function_">sizeof</span>(top));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pushup</span>(<span class="params">int p</span>)</span><br><span class="line">&#123;</span><br><span class="line">    top[p] = (top[p &lt;&lt; <span class="number">1</span>] == top[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]) ? top[p &lt;&lt; <span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pushdown</span>(<span class="params">int p</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(top[p])</span><br><span class="line">    &#123;</span><br><span class="line">        top[p &lt;&lt; <span class="number">1</span>] = top[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = top[p];</span><br><span class="line">        top[p] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span>(<span class="params">int p, int s, int e, int l, int r, int v</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= s &amp;&amp; e &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        top[p] = v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="title function_">update</span>(lc, l, r, v);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="title function_">update</span>(rc, l, r, v);</span><br><span class="line">    <span class="title function_">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">query</span>(<span class="params">int p, int s, int e, int l, int r, int x</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(top[p]) <span class="comment">//p对应的区间已经只可见一条线段</span></span><br><span class="line">    &#123;</span><br><span class="line">        g[top[p]][x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s == e) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="title function_">query</span>(lc, l, r, x);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="title function_">query</span>(rc, l, r, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int T, n, l, r;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;line[i].<span class="property">y1</span>, &amp;line[i].<span class="property">y2</span>, &amp;line[i].<span class="property">x</span>);</span><br><span class="line">        <span class="title function_">sort</span>(line + <span class="number">1</span>, line + n + <span class="number">1</span>, cmp);</span><br><span class="line"></span><br><span class="line">        <span class="title function_">build</span>();</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//点化为区间会丢失间隔为1的区间  所以要乘以2</span></span><br><span class="line">            l = (line[i].<span class="property">y1</span>) * <span class="number">2</span>;</span><br><span class="line">            r = (line[i].<span class="property">y2</span>) * <span class="number">2</span>;</span><br><span class="line">            <span class="title function_">query</span>(<span class="number">1</span>, <span class="number">0</span>, N * <span class="number">2</span>, l, r, i);</span><br><span class="line">            <span class="title function_">update</span>(<span class="number">1</span>, <span class="number">0</span>, N * <span class="number">2</span>, l, r, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = i + <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(g[i][j])</span><br><span class="line">                    <span class="keyword">for</span>(int k = j + <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">                        <span class="keyword">if</span>(g[j][k] &amp;&amp; g[i][k]) ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Last modified :   2015-07-15 15:33</span></span><br></pre></td></tr></table></figure>

<p>Horizontally Visible Segments</p>
<p>Description<br>There is a number of disjoint vertical line segments in the plane. We say that two segments are horizontally visible if they can be connected by a horizontal line segment that does not have any common points with other vertical segments. Three different vertical segments are said to form a triangle of segments if each two of them are horizontally visible. How many triangles can be found in a given set of vertical segments?<br>Task<br>Write a program which for each data set:<br>reads the description of a set of vertical segments,<br>computes the number of triangles in this set,<br>writes the result.</p>
<p>Input</p>
<p>The first line of the input contains exactly one positive integer d equal to the number of data sets, 1 &lt;&#x3D; d &lt;&#x3D; 20. The data sets follow.<br>The first line of each data set contains exactly one integer n, 1 &lt;&#x3D; n &lt;&#x3D; 8 000, equal to the number of vertical line segments.<br>Each of the following n lines consists of exactly 3 nonnegative integers separated by single spaces:<br>yi’, yi’’, xi - y-coordinate of the beginning of a segment, y-coordinate of its end and its x-coordinate, respectively. The coordinates satisfy 0 &lt;&#x3D; yi’ &lt; yi’’ &lt;&#x3D; 8 000, 0 &lt;&#x3D; xi &lt;&#x3D; 8 000. The segments are disjoint.</p>
<p>Output</p>
<p>The output should consist of exactly d lines, one line for each data set. Line i should contain exactly one integer equal to the number of triangles in the i-th data set.</p>
<p>Sample Input</p>
<p>1 5 0 4 4 0 3 1 3 4 2 0 2 2 0 2 3</p>
<p>Sample Output</p>
<p>1</p>
<p>Source</p>
<p><a href="http://poj.org/searchproblem?field=source&key=Central+Europe+2001">Central Europe 2001</a></p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2182 Lost Cows （树状数组,递推）</title>
    <url>/posts/oj/ds/POJ%202182%20Lost%20Cows%20%EF%BC%88%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84,%E9%80%92%E6%8E%A8%EF%BC%89/</url>
    <content><![CDATA[<p>﻿﻿ <span style="font-family:Microsoft YaHei;font-size:14px;">题意 N头牛排成一列 但编号顺序是乱的 知道每头牛前面有多少头牛编号在其之前 要求输出此时队列中每头牛的编号</span></span> <span style="font-family:Microsoft YaHei;font-size:14px;">本题有两种做法 一是利用数据结构的树状数组 时间复杂度低但相对较复杂 也可以依次推出每头牛的编号 这里先介绍递推的 以后再介绍数据结构优化的</span></span> <span style="font-family:Microsoft YaHei;font-size:14px;">从后往前递推 知道第i头牛在前i头牛里面的编号 即a[i]+1 然后加上a[i]+1之前已经被确定的编号个数（也就是被i后面的牛所确定的编号） 就是第i头牛的实际编了每次算i的编号时 i+1的编号都是确定的</span> <pre class="cpp" name="code">/#include<cstdio> using namespace std; /#define M 8005 /#define t a[i]+1 //t开始为i在前i头牛中的编号，后逐步推为实际编号； int main() { int sure[M]= {0},a[M],n; scanf("%d",&n); a[1]=0; for(int i=2; i<=n; i++) scanf("%d",&a[i]); for(int i=n; i>0; i--) { for(int j=1; j<=t; j++) if(sure[j]) //编号j已经被确定; a[i]++; sure[t]=1; } for(int i=1; i<=n; i++) printf("%d\n",t); return 0; }</p>
<p>Lost Cows</p>
<p>N (2 <= N <= 8,000) cows have unique brands in the range 1..N. In a spectacular display of poor judgment, they visited the neighborhood 'watering hole' and drank a few too many beers before dinner. When it was time to line up for their evening meal, they did not line up in the required ascending numerical order of their brands.<br>Regrettably, FJ does not have a way to sort them. Furthermore, he's not very good at observing problems. Instead of writing down each cow's brand, he determined a rather silly statistic: For each cow in line, he knows the number of cows that precede that cow in line that do, in fact, have smaller brands than that cow.<br>Given this data, tell FJ the exact ordering of the cows.</p>
<p>/* Line 1: A single integer, N<br>/* Lines 2..N: These N-1 lines describe the number of cows that precede a given cow in line and have brands smaller than that cow. Of course, no cows precede the first cow in line, so she is not listed. Line 2 of the input describes the number of preceding cows whose brands are smaller than the cow in slot /#2; line 3 describes the number of preceding cows whose brands are smaller than the cow in slot /#3; and so on.</p>
<p>/* Lines 1..N: Each of the N lines of output tells the brand of a cow in line. Line /#1 of the output tells the brand of the first cow in line; line 2 tells the brand of the second cow; and so on.</p>
<p>Sample Input<br><span style="font-family:Comic Sans MS;font-size:12px;">5 1 2 1 0 </span><br>Sample Output<br><span style="font-family:Comic Sans MS;font-size:12px;">2 4 5 3 1</span></p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2299 Ultra-QuickSort(归并排序·树状数组·逆序对)</title>
    <url>/posts/oj/ds/POJ%202299%20Ultra-QuickSort(%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%C2%B7%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%C2%B7%E9%80%86%E5%BA%8F%E5%AF%B9)/</url>
    <content><![CDATA[<p>题意 给你一个数组求其中逆序对**(i&lt;j&amp;&amp;a[i]&gt;a[j])**的个数</p>
<p>我们来看一个归并排序的过程:<br>给定的数组为[2, 4, 5, 3, 1]，二分后的数组分别为[2, 4, 5], [1, 3]，假设我们已经完成了子过程，现在进行到该数组的“并”操作：<br>a: [2, 4, 5]  b: [1, 3]  result:[1]  选取b数组的1 a: [2, 4, 5]  b: [3]  result:[1, 2]  选取a数组的2 a: [4, 5]  b: [3]  result:[1, 2, 3]  选取b数组的3 a: [4, 5]  b: []  result:[1, 2, 3, 4]  选取a数组的4 a: [5]  b: []  result:[1, 2, 3, 4, 5]  选取a数组的5 在执行[2, 4, 5]和[1, 3]合并的时候我们可以发现，当我们将a数组的元素k放入result数组时，result中存在的b数组的元素一定比k小。<br>在原数组中，b数组中的元素位置一定在k之后，也就是说k和这些元素均构成了逆序对。<br>那么在放入a数组中的元素时，我们通过计算result中b数组的元素个数，就可以计算出对于k来说，b数组中满足逆序对的个数。<br>又因为递归的过程中，a数组中和k满足逆序对的数也计算过。则在该次递归结束时，[2, 4, 5, 3, 1]中所有k的逆序对个数也就都统计了。<br>同理对于a中其他的元素也同样有这样的性质。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">500005</span>;</span><br><span class="line">int a[N], t[N], n;</span><br><span class="line">long long cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">merge</span>(<span class="params">int l, int m, int r</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int pl = l, pr = m + <span class="number">1</span>, p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(pl &lt;= m &amp;&amp; pr &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[pl] &lt;= a[pr]) t[p++] = a[pl++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            t[p++] = a[pr++];</span><br><span class="line">            cnt += m + <span class="number">1</span> - pl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pl&lt;=m) t[p++] = a[pl++];</span><br><span class="line">    <span class="keyword">while</span>(pr&lt;=r) t[p++] = a[pr++];</span><br><span class="line">    <span class="title function_">memcpy</span>(a + l, t, <span class="title function_">sizeof</span>(int)*p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">mergeSort</span>(<span class="params">int l, int r</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    int	m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="title function_">mergeSort</span>(l, m);</span><br><span class="line">    <span class="title function_">mergeSort</span>(m + <span class="number">1</span>, r);</span><br><span class="line">    <span class="title function_">merge</span>(l, m, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="title function_">mergeSort</span>(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然逆序对也可以通过树状数组或者线段树来求 插入每个时 计算一下有多少个比这个数大的数已经插入了就行了 a[i]的值可能很大 需要离散化 这个离散化只需要排个序</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">500005</span>;</span><br><span class="line">int a[N], r[N], n;</span><br><span class="line"></span><br><span class="line">bool <span class="title function_">cmp</span>(int i, int j) <span class="comment">//离散化排序用的比较函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a[i] &lt; a[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span>(<span class="params">int x, int v</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(x &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        a[x] += v;</span><br><span class="line">        x += x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">sum</span>(<span class="params">int x</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        ret += a[x];</span><br><span class="line">        x -= x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]), r[i] = i;</span><br><span class="line">        <span class="title function_">sort</span>(r + <span class="number">1</span>, r + n + <span class="number">1</span>, cmp); <span class="comment">//离散化 用数排序后的下标代替数</span></span><br><span class="line"></span><br><span class="line">        long long ans = <span class="number">0</span>;</span><br><span class="line">        <span class="title function_">memset</span>(a, <span class="number">0</span>, <span class="title function_">sizeof</span>(a));</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += <span class="title function_">sum</span>(n) - <span class="title function_">sum</span>(r[i]);</span><br><span class="line">            <span class="title function_">add</span>(r[i], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Ultra-QuickSort</p>
<p>Description<br><img src="/../images/es-2299_1.jpg.png">In this problem, you have to analyze a particular sorting algorithm. The algorithm processes a sequence of n distinct integers by swapping two adjacent sequence elements until the sequence is sorted in ascending order. For the input sequence<br>9 1 0 5 4 ,<br>Ultra-QuickSort produces the output<br>0 1 4 5 9 .<br>Your task is to determine how many swap operations Ultra-QuickSort needs to perform in order to sort a given input sequence.</p>
<p>Input</p>
<p>The input contains several test cases. Every test case begins with a line that contains a single integer n &lt; 500,000 – the length of the input sequence. Each of the the following n lines contains a single integer 0 ≤ a[i] ≤ 999,999,999, the i-th input sequence element. Input is terminated by a sequence of length n &#x3D; 0. This sequence must not be processed.</p>
<p>Output</p>
<p>For every input sequence, your program prints a single line containing an integer number op, the minimum number of swap operations necessary to sort the given input sequence.</p>
<p>Sample Input</p>
<p>5 9 1 0 5 4 3 1 2 3 0</p>
<p>Sample Output</p>
<p>6 0</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2528 Mayor&#39;s posters(离散化 线段树 贴海报)</title>
    <url>/posts/oj/ds/POJ%202528%20Mayor&#39;s%20posters(%E7%A6%BB%E6%95%A3%E5%8C%96%20%E7%BA%BF%E6%AE%B5%E6%A0%91%20%E8%B4%B4%E6%B5%B7%E6%8A%A5)/</url>
    <content><![CDATA[<p>题意 在墙上贴n张海报 输入每张海报的的左右端点坐标 问最后可以看到多少张海报 能看到一点也是能看到</p>
<p>先把线段树初始化为0 输入一张海报 就把那个区间变成这张海报的序号 最后判断墙上有多少个不同的序号就行了</p>
<p>但是海报坐标的端点值高达10000000 直接用线段树会超时 但是注意到海报最多只有10000张 也就是最多有20000个不同的坐标 于是可以利用离散化的知识 把所有坐标排序 注意所有右端点坐标+1也要加入排序(注意1,10 ; 1,3; 7,10这种情况 如果右端点+1没加入排序的话可能使原来不相邻的变为相邻 这样就覆盖了本来没有覆盖的区间) 可以发现 把每个端点的坐标变为该点排序后的序号不会改变整个图形的结构 于是就可以用序号代替坐标了 大大减小了复杂度</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define lc p&lt;&lt;<span class="number">1</span>,s,mid</span><br><span class="line">#define rc p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,e</span><br><span class="line">#define mid ((s+e)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">#define <span class="title function_">CLR</span>(A) <span class="title function_">memset</span>(A,<span class="number">0</span>,<span class="title function_">sizeof</span>(A))</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">20005</span>;</span><br><span class="line">int col[N * <span class="number">4</span>], vis[N];</span><br><span class="line">int le[N], ri[N], c[N * <span class="number">2</span>], ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pushdown</span>(<span class="params">int p</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(col[p] == -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    col[p &lt;&lt; <span class="number">1</span>] = col[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]  = col[p];</span><br><span class="line">    col[p] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span>(<span class="params">int p, int s, int e, int l, int r, int v</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s &gt;= l &amp;&amp; e &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        col[p] = v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="title function_">update</span>(lc, l, r, v);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="title function_">update</span>(rc, l, r, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">query</span>(<span class="params">int p, int s, int e</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(col[p] != -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[col[p]])</span><br><span class="line">            vis[col[p]] = <span class="number">1</span>, ++ans;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">query</span>(lc);</span><br><span class="line">    <span class="title function_">query</span>(rc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">compress</span>(int n) <span class="comment">//离散化</span></span><br><span class="line">&#123;</span><br><span class="line">    int k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        c[k++] = le[i];</span><br><span class="line">        c[k++] = ri[i];</span><br><span class="line">        c[k++] = ri[i] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">sort</span>(c, c + k);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">unique</span>(c, c + k) - c - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas, m, n, l, r;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span>(cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;le[i], &amp;ri[i]);</span><br><span class="line">        n = <span class="title function_">compress</span>(m);</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="title function_">CLR</span>(col), <span class="title function_">CLR</span>(vis);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            l = <span class="title function_">lower_bound</span>(c, c + n, le[i]) - c + <span class="number">1</span>;</span><br><span class="line">            r = <span class="title function_">lower_bound</span>(c, c + n, ri[i]) - c + <span class="number">1</span>;</span><br><span class="line">            <span class="title function_">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        vis[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="title function_">query</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mayor’s posters</p>
<p>Description<br>The citizens of Bytetown, AB, could not stand that the candidates in the mayoral election campaign have been placing their electoral posters at all places at their whim. The city council has finally decided to build an electoral wall for placing the posters and introduce the following rules:</p>
<p>They have built a wall 10000000 bytes long (such that there is enough place for all candidates). When the electoral campaign was restarted, the candidates were placing their posters on the wall and their posters differed widely in width. Moreover, the candidates started placing their posters on wall segments already occupied by other posters. Everyone in Bytetown was curious whose posters will be visible (entirely or in part) on the last day before elections.<br>Your task is to find the number of visible posters when all the posters are placed given the information about posters’ size, their place and order of placement on the electoral wall.</p>
<p>Input</p>
<p>The first line of input contains a number c giving the number of cases that follow. The first line of data for a single case contains number 1 &lt;&#x3D; n &lt;&#x3D; 10000. The subsequent n lines describe the posters in the order in which they were placed. The i-th line among the n lines contains two integer numbers l i and ri which are the number of the wall segment occupied by the left end and the right end of the i-th poster, respectively. We know that for each 1 &lt;&#x3D; i &lt;&#x3D; n, 1 &lt;&#x3D; l i &lt;&#x3D; ri &lt;&#x3D; 10000000. After the i-th poster is placed, it entirely covers all wall segments numbered l i, l i+1 ,… , ri.</p>
<p>Output</p>
<p>For each input data set print the number of visible posters after all the posters are placed.<br>The picture below illustrates the case of the sample input.<br><img src="/../images/es-2528_1.jpg.png"></p>
<p>Sample Input</p>
<p>1 5 1 4 2 6 8 10 3 4 7 10</p>
<p>Sample Output</p>
<p>4</p>
<p>Source</p>
<p><a href="http://poj.org/searchproblem?field=source&key=Alberta+Collegiate+Programming+Contest+2003.10.18">Alberta Collegiate Programming Contest 2003.10.18</a></p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2823 Sliding Window(单调队列)</title>
    <url>/posts/oj/ds/POJ%202823%20Sliding%20Window(%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97)/</url>
    <content><![CDATA[<p>题意 长度为n的数组上有个长度为k的滑窗从左向右移动 求每次移动后滑窗区间的最小值和最大值 输出两行 第一行所有最小值 第二行所有最大值</p>
<p>可以用线段树来做 但是单调队列更简单</p>
<p>单调递增队列： 队尾单调入队(入队元素大于队尾元素时直接入队 否则队尾出队直到队尾元素小于入队元素或者队列为空) 队首队尾都可以出队</p>
<p>求最小值时 先判断队首元素是否在滑窗之内 不在队首就出队 然后队首元素就是滑窗中的最小值了 求最大值用单减队列就行了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line">int a[N], q[N], t[N];</span><br><span class="line">int front, rear, n, k;</span><br><span class="line"></span><br><span class="line">#define <span class="variable constant_">NOTMONO</span> (!op &amp;&amp; a[i] &lt; q[rear - <span class="number">1</span>]) || (op &amp;&amp; a[i] &gt; q[rear - <span class="number">1</span>])</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">getMonoQueue</span>(int op) <span class="comment">//op = 0 时单增队列  op = 1 时单减队列</span></span><br><span class="line">&#123;</span><br><span class="line">    front = rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>( rear &gt; front &amp;&amp; (<span class="variable constant_">NOTMONO</span>)) --rear;</span><br><span class="line">        t[rear] = i;      <span class="comment">//记录滑窗滑到i点的时间</span></span><br><span class="line">        q[rear++] = a[i];</span><br><span class="line">        <span class="keyword">while</span>(t[front] &lt;= i - k) ++front;  <span class="comment">//保证队首元素在滑窗之内</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; k - <span class="number">2</span>)</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;%d%c&quot;</span>, q[front], i == n - <span class="number">1</span> ? <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="title function_">getMonoQueue</span>(<span class="number">0</span>); <span class="comment">//单增队列维护最小值</span></span><br><span class="line">        <span class="title function_">getMonoQueue</span>(<span class="number">1</span>); <span class="comment">//单减队列维护最大值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Last modified :   2015-07-06 12:16</span></span><br></pre></td></tr></table></figure>

<p>Sliding Window</p>
<p>Description<br>An array of size <em>n</em> ≤ 10 6 is given to you. There is a sliding window of size <em>k</em> which is moving from the very left of the array to the very right. You can only see the <em>k</em> numbers in the window. Each time the sliding window moves rightwards by one position. Following is an example:<br>The array is [1 3 -1 -3 5 3 6 7], and <em>k</em> is 3. Window position Minimum value Maximum value [1 3 -1] -3 5 3 6 7 -1 3 1 [3 -1 -3] 5 3 6 7 -3 3 1 3 [-1 -3 5] 3 6 7 -3 5 1 3 -1 [-3 5 3] 6 7 -3 5 1 3 -1 -3 [5 3 6] 7 3 6 1 3 -1 -3 5 [3 6 7] 3 7</p>
<p>Your task is to determine the maximum and minimum values in the sliding window at each position.</p>
<p>Input</p>
<p>The input consists of two lines. The first line contains two integers <em>n</em> and <em>k</em> which are the lengths of the array and the sliding window. There are <em>n</em> integers in the second line.</p>
<p>Output</p>
<p>There are two lines in the output. The first line gives the minimum values in the window at each position, from left to right, respectively. The second line gives the maximum values.</p>
<p>Sample Input</p>
<p>8 3 1 3 -1 -3 5 3 6 7</p>
<p>Sample Output</p>
<p>-1 -3 -3 -3 3 3 3 3 5 5 6 7</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2828 Buy Tickets(线段树·插队)</title>
    <url>/posts/oj/ds/POJ%202828%20Buy%20Tickets(%E7%BA%BF%E6%AE%B5%E6%A0%91%C2%B7%E6%8F%92%E9%98%9F)/</url>
    <content><![CDATA[<p>题意 n个人排队 每个人都有个属性值 依次输入n个pos[i] val[i] 表示第i个人直接插到当前第pos[i]个人后面 他的属性值为val[i] 要求最后依次输出队中各个人的属性值</p>
<p>从头到尾看的话 队列是动态的 无法操作 但是反过来看时 pos[i]就可以表示第i个人前面有多少个空位了 然后想到了用线段树做就简单了 线段树维护对应区间还有多少个空位 每次把i放到前面刚好有pos[i]个空位的位置就行了 具体看代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#define lc p&lt;&lt;<span class="number">1</span>, s, mid</span><br><span class="line">#define rc p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, e</span><br><span class="line">#define mid ((s+e)&gt;&gt;<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">int tot[N * <span class="number">4</span>], ans[N];</span><br><span class="line"><span class="comment">//tot维护对应区间还能放多少人</span></span><br><span class="line">int pos[N], val[N];</span><br><span class="line"><span class="comment">//pos[i] 保存第i个人进队时前面有多少人</span></span><br><span class="line"><span class="comment">//val[i] 保存第i个人的val</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pushup</span>(<span class="params">int p</span>)</span><br><span class="line">&#123;</span><br><span class="line">    tot[p] = tot[p &lt;&lt; <span class="number">1</span>] + tot[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">build</span>(<span class="params">int p, int s, int e</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//tot维护对应区间还能放多少人</span></span><br><span class="line">    <span class="keyword">if</span>(s == e)</span><br><span class="line">    &#123;</span><br><span class="line">        tot[p] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">build</span>(lc);</span><br><span class="line">    <span class="title function_">build</span>(rc);</span><br><span class="line">    <span class="title function_">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第i个人插入</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span>(<span class="params">int p, int s, int e, int i</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == e)</span><br><span class="line">    &#123;</span><br><span class="line">        tot[p] = <span class="number">0</span>;</span><br><span class="line">        ans[e] = val[i];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tot[p &lt;&lt; <span class="number">1</span>] &gt; pos[i])</span><br><span class="line">        <span class="title function_">update</span>(lc, i);  <span class="comment">//左区间的空位足够</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pos[i] -= tot[p &lt;&lt; <span class="number">1</span>];</span><br><span class="line">        <span class="title function_">update</span>(rc, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;pos[i], &amp;val[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(int i = n; i &gt; <span class="number">0</span>; --i) <span class="comment">//倒着更新</span></span><br><span class="line">            <span class="title function_">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line"></span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[n]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Last modified :   2015-07-13 11:13</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2886 Who Gets the Most Candies?(线段树·约瑟夫环)</title>
    <url>/posts/oj/ds/POJ%202886%20Who%20Gets%20the%20Most%20Candies(%E7%BA%BF%E6%AE%B5%E6%A0%91%C2%B7%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF)/</url>
    <content><![CDATA[<p>题意 n个人顺时针围成一圈玩约瑟夫游戏 每个人手上有一个数val[i] 开始第k个人出队 若val[k] &lt; 0 下一个出队的为在剩余的人中向右数 -val[k]个人 val[k] &gt; 0 时向左数val[k]个 第m出队的人可以得到m的约数个数个糖果 问得到最多糖果的人是谁</p>
<p>约瑟夫环问题 n比较大 直接模拟会超时 通过线段树可以让每次出队在O(logN)时间内完成 类似上一道插队的题 线段树维护对应区间还有多少个人没出队 那么当我们知道出队的人在剩余人中排第几个也就可以通过线段树知道他在原始环中排第几个了</p>
<p>至于第几个出队的人糖果最多就是求1…n中约数最多的数 可以利用反素数相关知识</p>
<p>对于任何正整数x 其约数的个数记做g(x) 例如g(1)&#x3D;1 g(6)&#x3D;4 如果某个正整数x满足 对于任意i(0&lt;i&lt;x) 都有g(i)&lt;g(x) 则称x为反素数</p>
<p>我直接用的别人的反素数表</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#define lc p&lt;&lt;<span class="number">1</span>, s, mid</span><br><span class="line">#define rc p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid + <span class="number">1</span>, e</span><br><span class="line">#define mid ((s+e)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line">int tot[N * <span class="number">4</span>], val[N];</span><br><span class="line"><span class="comment">//tot维护对应区间还有多少人没出去</span></span><br><span class="line">char name[N][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">int ip[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">24</span>, <span class="number">36</span>, <span class="number">48</span>, <span class="number">60</span>, <span class="number">120</span>, <span class="number">180</span>, <span class="number">240</span>, <span class="number">360</span>, <span class="number">720</span>,</span><br><span class="line">            <span class="number">840</span>, <span class="number">1260</span>, <span class="number">1680</span>, <span class="number">2520</span>, <span class="number">5040</span>, <span class="number">7560</span>, <span class="number">10080</span>, <span class="number">15120</span>, <span class="number">20160</span>,</span><br><span class="line">            <span class="number">25200</span>, <span class="number">27720</span>, <span class="number">45360</span>, <span class="number">50400</span>, <span class="number">55440</span>, <span class="number">83160</span>, <span class="number">110880</span>,</span><br><span class="line">            <span class="number">166320</span>, <span class="number">221760</span>, <span class="number">277200</span>, <span class="number">332640</span>, <span class="number">498960</span>, <span class="number">500001</span></span><br><span class="line">           &#125;; <span class="comment">//反素数</span></span><br><span class="line"></span><br><span class="line">int div[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">24</span>, <span class="number">30</span>, <span class="number">32</span>, <span class="number">36</span>,</span><br><span class="line">             <span class="number">40</span>, <span class="number">48</span>, <span class="number">60</span>, <span class="number">64</span>, <span class="number">72</span>, <span class="number">80</span>, <span class="number">84</span>, <span class="number">90</span>, <span class="number">96</span>, <span class="number">100</span>, <span class="number">108</span>, <span class="number">120</span>,</span><br><span class="line">             <span class="number">128</span>, <span class="number">144</span>, <span class="number">160</span>, <span class="number">168</span>, <span class="number">180</span>, <span class="number">192</span>, <span class="number">200</span></span><br><span class="line">            &#125;;<span class="comment">//反素数对应的约数个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pushup</span>(<span class="params">int p</span>)</span><br><span class="line">&#123;</span><br><span class="line">    tot[p] = tot[p &lt;&lt; <span class="number">1</span>] + tot[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">build</span>(<span class="params">int p, int s, int e</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == e)</span><br><span class="line">    &#123;</span><br><span class="line">        tot[p] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">build</span>(lc);</span><br><span class="line">    <span class="title function_">build</span>(rc);</span><br><span class="line">    <span class="title function_">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">update</span>(<span class="params">int p, int s, int e, int x</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    <span class="keyword">if</span>(s == e)</span><br><span class="line">    &#123;</span><br><span class="line">        tot[p] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= tot[p &lt;&lt; <span class="number">1</span>]) ret = <span class="title function_">update</span>(lc, x);</span><br><span class="line">    <span class="keyword">else</span> ret = <span class="title function_">update</span>(rc, x - tot[p &lt;&lt; <span class="number">1</span>]);</span><br><span class="line">    <span class="title function_">pushup</span>(p);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, k, m, r, ans, pos;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k) != <span class="variable constant_">EOF</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, name[i], &amp;val[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; ip[i] &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            m = ip[i];   <span class="comment">//m为小于等于n的第一个反素数</span></span><br><span class="line">            ans = div[i];  <span class="comment">//ans对应m的约数个数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r = n; <span class="comment">//还剩r个人</span></span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            r--;</span><br><span class="line">            pos = <span class="title function_">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, k);</span><br><span class="line">            <span class="comment">//pos为剩余序列中排第k的人在原始队列中的位置</span></span><br><span class="line">            <span class="keyword">if</span>(!r) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(val[pos] &gt;= <span class="number">0</span>)   <span class="comment">//顺时针</span></span><br><span class="line">                k = (k - <span class="number">1</span> - <span class="number">1</span> + val[pos]) % r + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//第一个-1是把1开始转换为0开始</span></span><br><span class="line">            <span class="comment">//第二个是删除第k个后现在位于第k-1个 要前进val[pos]步</span></span><br><span class="line">            <span class="comment">//后面的+1是把0开始换回1开始</span></span><br><span class="line">            <span class="keyword">else</span>                <span class="comment">//逆时针</span></span><br><span class="line">                k = ((k - <span class="number">1</span> + val[pos]) % r + r) % r + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//逆时针删除第k个后现在还位于第k个 要后退-val[pos]步</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>, name[pos], ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Last modified :   2015-07-13 19:13</span></span><br></pre></td></tr></table></figure>

<p>Who Gets the Most Candies?</p>
<p>Description<br><em>N</em> children are sitting in a circle to play a game.</p>
<p>The children are numbered from 1 to <em>N</em> in clockwise order. Each of them has a card with a non-zero integer on it in his&#x2F;her hand. The game starts from the <em>K</em>-th child, who tells all the others the integer on his card and jumps out of the circle. The integer on his card tells the next child to jump out. Let <em>A</em> denote the integer. If <em>A</em> is positive, the next child will be the <em>A</em>-th child to the left. If <em>A</em> is negative, the next child will be the (−<em>A</em>)-th child to the right.</p>
<p>The game lasts until all children have jumped out of the circle. During the game, the <em>p</em>-th child jumping out will get <em>F</em>(<em>p</em>) candies where <em>F</em>(<em>p</em>) is the number of positive integers that perfectly divide <em>p</em>. Who gets the most candies?</p>
<p>Input</p>
<p>There are several test cases in the input. Each test case starts with two integers <em>N</em> (0 &lt; <em>N</em> ≤ 500,000) and <em>K</em> (1 ≤ <em>K</em> ≤ <em>N</em>) on the first line. The next <em>N</em>lines contains the names of the children (consisting of at most 10 letters) and the integers (non-zero with magnitudes within 108) on their cards in increasing order of the children’s numbers, a name and an integer separated by a single space in a line with no leading or trailing spaces.</p>
<p>Output</p>
<p>Output one line for each test case containing the name of the luckiest child and the number of candies he&#x2F;she gets. If ties occur, always choose the child who jumps out of the circle first.</p>
<p>Sample Input</p>
<p>4 2 Tom 2 Jack 4 Mary -1 Sam 1</p>
<p>Sample Output</p>
<p>Sam 3</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2991 Crane（线段树·向量旋转）</title>
    <url>/posts/oj/ds/POJ%202991%20Crane%EF%BC%88%E7%BA%BF%E6%AE%B5%E6%A0%91%C2%B7%E5%90%91%E9%87%8F%E6%97%8B%E8%BD%AC%EF%BC%89/</url>
    <content><![CDATA[<p>题意 有一个Crane由n条线段连接组成 每个连接点处均可以任意旋转 给你n条线段的长度 然后又m次旋转操作 给你p和r 将第p和第p+1条线段之间的角度旋转为r 即第p条线段绕p的终点逆时针旋转r度后能够与第p+1条重合 问每次旋转后最后一条线段的终点坐标</p>
<p>可以发现 旋转第p+1条线段时 p+1后面的所有线段也一起旋转了 可以把Crane分解为n个向量 这些向量的和也就是Crane终点的坐标 用rad[i]保存第i个向量与第i+1个向量之间的夹角 每次旋转操作时 我们要把rad[i]变为r 也就是要把第i+1和后面的所有向量逆时针旋转r - rad[i] 对于向量的旋转操作有</p>
<p>**(x,y)<strong>逆时针旋转 r 弧度 –&gt;</strong>(x&#x2F;*cos(r) - y&#x2F;*sin(r), x&#x2F;<em>sin(r) + y&#x2F;<em>cos(r))</em></em></p>
<p>**(x,y)<strong>顺时针旋转 r 弧度 –&gt;</strong>(-x&#x2F;*cos(r) + y&#x2F;*sin(r), x&#x2F;<em>sin(r) + y&#x2F;<em>cos(r))</em></em></p>
<p>那么我们可以用线段树来维护对应区间的向量的和 根节点对应的x, y也就是答案了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#define lc p&lt;&lt;<span class="number">1</span>, s, mid</span><br><span class="line">#define rc p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, e</span><br><span class="line">#define mid ((s+e)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">const</span> double pi = <span class="title function_">acos</span>(-<span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">const</span> double eps = <span class="number">1e-8</span>;</span><br><span class="line">double x[N &lt;&lt; <span class="number">2</span>], y[N &lt;&lt; <span class="number">2</span>], rot[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="comment">//x 对应区间所有向量的和的横坐标</span></span><br><span class="line"><span class="comment">//y 对应区间所有向量的和的纵坐标</span></span><br><span class="line"><span class="comment">//rot 子节点对应区间所有向量需要逆时针旋转的弧度</span></span><br><span class="line">double rad[N]; <span class="comment">//rad[i] 保存第i个向量和第i+1个向量间的弧度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">rotate</span>(<span class="params">double &amp;x, double &amp;y, double r</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//将向量(x, y)逆时针旋转r弧度</span></span><br><span class="line">    double xx = x;</span><br><span class="line">    x = xx * <span class="title function_">cos</span>(r) - y * <span class="title function_">sin</span>(r);</span><br><span class="line">    y = xx * <span class="title function_">sin</span>(r) + y * <span class="title function_">cos</span>(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pushup</span>(<span class="params">int p</span>)</span><br><span class="line">&#123;</span><br><span class="line">    x[p] = x[p &lt;&lt; <span class="number">1</span>] + x[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    y[p] = y[p &lt;&lt; <span class="number">1</span>] + y[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pushdown</span>(<span class="params">int p, int s, int e</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_">fabs</span>(rot[p]) &lt; eps) <span class="keyword">return</span>;</span><br><span class="line">    int lp = p &lt;&lt; <span class="number">1</span>, rp = p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">    rot[lp] += rot[p];</span><br><span class="line">    rot[rp] += rot[p];</span><br><span class="line">    <span class="title function_">rotate</span>(x[lp], y[lp], rot[p]);</span><br><span class="line">    <span class="title function_">rotate</span>(x[rp], y[rp], rot[p]);</span><br><span class="line">    rot[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">build</span>(<span class="params">int p, int s, int e</span>)</span><br><span class="line">&#123;</span><br><span class="line">    rot[p] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(s == e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;y[p]);</span><br><span class="line">        x[p] = <span class="number">0</span>;</span><br><span class="line">        rad[s] = pi;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">build</span>(lc);</span><br><span class="line">    <span class="title function_">build</span>(rc);</span><br><span class="line">    <span class="title function_">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span>(<span class="params">int p, int s, int e, int l, int r, double v</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= s &amp;&amp; e &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        rot[p] += v;</span><br><span class="line">        <span class="title function_">rotate</span>(x[p], y[p], v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">pushdown</span>(p, s, e);</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="title function_">update</span>(lc, l, r, v);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="title function_">update</span>(rc, l, r, v);</span><br><span class="line">    <span class="title function_">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, m, p, first = <span class="number">1</span>;</span><br><span class="line">    double r;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!first) <span class="title function_">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> first = <span class="number">0</span>;</span><br><span class="line">        <span class="title function_">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%lf&quot;</span>, &amp;p, &amp;r);</span><br><span class="line">            r = r / <span class="number">180</span> * pi;</span><br><span class="line">            <span class="comment">//p与p+1之间的弧度为rad[p] 要达到r p+1还需要逆时针旋转r - rad[p]弧度</span></span><br><span class="line">            <span class="title function_">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, p + <span class="number">1</span>, n, r - rad[p]);</span><br><span class="line">            rad[p] = r;  <span class="comment">//旋转后p与p+1之间的弧度变为r</span></span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;%f %f\n&quot;</span>, x[<span class="number">1</span>], y[<span class="number">1</span>]); <span class="comment">//x[1], y[1]为所有向量和的坐标</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Crane</p>
<p>Description<br>ACM has bought a new crane (crane – jeřáb) . The crane consists of n segments of various lengths, connected by flexible joints. The end of the i-th segment is joined to the beginning of the i + 1-th one, for 1 ≤ i &lt; n. The beginning of the first segment is fixed at point with coordinates (0, 0) and its end at point with coordinates (0, w), where w is the length of the first segment. All of the segments lie always in one plane, and the joints allow arbitrary rotation in that plane. After series of unpleasant accidents, it was decided that software that controls the crane must contain a piece of code that constantly checks the position of the end of crane, and stops the crane if a collision should happen.<br>Your task is to write a part of this software that determines the position of the end of the n-th segment after each command. The state of the crane is determined by the angles between consecutive segments. Initially, all of the angles are straight, i.e., 180 o. The operator issues commands that change the angle in exactly one joint.</p>
<p>Input</p>
<p>The input consists of several instances, separated by single empty lines.<br>The first line of each instance consists of two integers 1 ≤ n ≤10 000 and c 0 separated by a single space – the number of segments of the crane and the number of commands. The second line consists of n integers l1,…, ln (1 li 100) separated by single spaces. The length of the i-th segment of the crane is li. The following c lines specify the commands of the operator. Each line describing the command consists of two integers s and a (1 ≤ s &lt; n, 0 ≤ a ≤ 359) separated by a single space – the order to change the angle between the s-th and the s + 1-th segment to a degrees (the angle is measured counterclockwise from the s-th to the s + 1-th segment).</p>
<p>Output</p>
<p>The output for each instance consists of c lines. The i-th of the lines consists of two rational numbers x and y separated by a single space – the coordinates of the end of the n-th segment after the i-th command, rounded to two digits after the decimal point.<br>The outputs for each two consecutive instances must be separated by a single empty line.</p>
<p>Sample Input</p>
<p>2 1 10 5 1 90 3 2 5 5 5 1 270 2 90</p>
<p>Sample Output</p>
<p>5.00 10.00 -10.00 5.00 -5.00 10.00</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3282 Ferry Loading IV(模拟,队列)</title>
    <url>/posts/oj/ds/POJ%203282%20Ferry%20Loading%20IV(%E6%A8%A1%E6%8B%9F,%E9%98%9F%E5%88%97)/</url>
    <content><![CDATA[<p>题意 汽车通过渡船过河 渡船开始在左边 输入按车辆来的顺序输入河两岸的车 渡船每次运输的汽车的总长度不能超过渡船自己本身的长度 先来的车先走 求轮船至少跨河多少次才能将所有的车辆都运完</p>
<p>简单模拟 建两个队列 分别装左边的车 和右边的车 算出两边各至少需要运输多少次就行了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas, lcnt, rcnt, on,n,m,l;</span><br><span class="line">    char s[<span class="number">10</span>];</span><br><span class="line">    scanf (<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span> (cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        queue&lt;int&gt; le, ri;</span><br><span class="line">        scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        n *= <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">while</span> (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf (<span class="string">&quot;%d%s&quot;</span>, &amp;l, s);</span><br><span class="line">            <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;l&#x27;</span>) le.<span class="property">push</span> (l);</span><br><span class="line">            <span class="keyword">else</span> ri.<span class="property">push</span> (l);</span><br><span class="line">        &#125;</span><br><span class="line">        lcnt = on = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!le.<span class="title function_">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!le.<span class="title function_">empty</span>() &amp;&amp; on + le.<span class="title function_">front</span>() &lt; n)</span><br><span class="line">                on += le.<span class="title function_">front</span>(), le.<span class="title function_">pop</span>();</span><br><span class="line">            ++lcnt, on = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rcnt = on = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!ri.<span class="title function_">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!ri.<span class="title function_">empty</span>() &amp;&amp; on + ri.<span class="title function_">front</span>() &lt; n)</span><br><span class="line">                on += ri.<span class="title function_">front</span>(), ri.<span class="title function_">pop</span>();</span><br><span class="line">            ++rcnt, on = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lcnt &gt; rcnt) printf (<span class="string">&quot;%d\n&quot;</span>, <span class="number">2</span> * lcnt - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> printf (<span class="string">&quot;%d\n&quot;</span>,<span class="number">2</span> * rcnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Ferry Loading IV</p>
<p>Description<br>Before bridges were common, ferries were used to transport cars across rivers. River ferries, unlike their larger cousins, run on a guide line and are powered by the river’s current. Cars drive onto the ferry from one end, the ferry crosses the river, and the cars exit from the other end of the ferry.</p>
<p>There is an <em>l</em>-meter-long ferry that crosses the river. A car may arrive at either river bank to be transported by the ferry to the opposite bank. The ferry travels continuously back and forth between the banks so long as it is carrying a car or there is at least one car waiting at either bank. Whenever the ferry arrives at one of the banks, it unloads its cargo and loads up cars that are waiting to cross as long as they fit on its deck. The cars are loaded in the order of their arrival; ferry’s deck accommodates only one lane of cars. The ferry is initially on the left bank where it broke and it took quite some time to fix it. In the meantime, lines of cars formed on both banks that await to cross the river.</p>
<p>Input</p>
<p>The first line of input contains <em>c</em>, the number of test cases. Each test case begins with <em>l, m</em>. <em>m</em> lines follow describing the cars that arrive in this order to be transported. Each line gives the length of a car (in centimeters), and the bank at which the car arrives (“left” or “right”).</p>
<p>Output</p>
<p>For each test case, output one line giving the number of times the ferry has to cross the river in order to serve all waiting cars.</p>
<p>Sample Input</p>
<p>4 20 4 380 left 720 left 1340 right 1040 left 15 4 380 left 720 left 1340 right 1040 left 15 4 380 left 720 left 1340 left 1040 left 15 4 380 right 720 right 1340 right 1040 right</p>
<p>Sample Output</p>
<p>3 3 5 6</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3481 Double Queue(STL)</title>
    <url>/posts/oj/ds/POJ%203481%20Double%20Queue(STL)/</url>
    <content><![CDATA[<p>题意 模拟银行的排队系统 有三种操作 1-添加优先级为p 编号为k的人到队列 2-服务当前优先级最大的 3-服务当前优先级最小的 0-退出系统</p>
<p>可以用stl中的map 因为map本身就根据key的值排了序 对应2，3 我们只需要输出最大或最小就行了并从map中删除该键值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">map&lt;int, int&gt; a;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    map&lt;int, int&gt;::iterator it;</span><br><span class="line">    int n,k,p;</span><br><span class="line">    <span class="keyword">while</span> (scanf (<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;k, &amp;p);</span><br><span class="line">            a[p] = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.<span class="title function_">empty</span>()) printf (<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(n==<span class="number">2</span>) it = a.<span class="title function_">end</span>(),--it;</span><br><span class="line">                <span class="keyword">else</span> it=a.<span class="title function_">begin</span>();</span><br><span class="line">                printf (<span class="string">&quot;%d\n&quot;</span>, it-&gt;second);</span><br><span class="line">                a.<span class="property">erase</span> (it-&gt;first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Double Queue</p>
<p>Description<br>The new founded Balkan Investment Group Bank (BIG-Bank) opened a new office in Bucharest, equipped with a modern computing environment provided by IBM Romania, and using modern information technologies. As usual, each client of the bank is identified by a positive integer <em>K</em> and, upon arriving to the bank for some services, he or she receives a positive integer priority <em>P</em>. One of the inventions of the young managers of the bank shocked the software engineer of the serving system. They proposed to break the tradition by sometimes calling the serving desk with the <strong>lowest</strong> priority instead of that with the highest priority. Thus, the system will receive the following types of request:<br>0 The system needs to stop serving 1 <em>K P</em> Add client <em>K</em> to the waiting list with priority <em>P</em> 2 Serve the client with the highest priority and drop him or her from the waiting list 3 Serve the client with the lowest priority and drop him or her from the waiting list</p>
<p>Your task is to help the software engineer of the bank by writing a program to implement the requested serving policy.</p>
<p>Input</p>
<p>Each line of the input contains one of the possible requests; only the last line contains the stop-request (code 0). You may assume that when there is a request to include a new client in the list (code 1), there is no other request in the list of the same client or with the same priority. An identifier <em>K</em> is always less than 106, and a priority <em>P</em> is less than 107. The client may arrive for being served multiple times, and each time may obtain a different priority.</p>
<p>Output</p>
<p>For each request with code 2 or 3, the program has to print, in a separate line of the standard output, the identifier of the served client. If the request arrives when the waiting list is empty, then the program prints zero (0) to the output.</p>
<p>Sample Input</p>
<p>2 1 20 14 1 30 3 2 1 10 99 3 2 2 0</p>
<p>Sample Output</p>
<p>0 20 30 10 0</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 10954 Add All(优先队列)</title>
    <url>/posts/oj/ds/UVa%2010954%20Add%20All(%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97)/</url>
    <content><![CDATA[<p>题意 求把所有数加起来的最小代价a+b的代价为(a+b)</p>
<p>越先运算的数 要被加的次数越多 所以每次相加的两个数都应该是剩下序列中最小的数 然后结果要放到序列中 也就是优先队列了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;q;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll ans;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, t;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">            q.<span class="title function_">push</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="title function_">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            int a = q.<span class="title function_">top</span>();      q.<span class="title function_">pop</span>();</span><br><span class="line">            int b = q.<span class="title function_">top</span>();      q.<span class="title function_">pop</span>();</span><br><span class="line">            ans += (a + b);</span><br><span class="line">            <span class="keyword">if</span>(q.<span class="title function_">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">            q.<span class="title function_">push</span>(a + b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Yup!! The problem name reflects your task; just add a set of numbers. But you may feel yourselves condescended, to write a C&#x2F;C++ program just to add a set of numbers. Such a problem will simply question your erudition. So, let’s add some flavor of ingenuity to it.</p>
<p>Addition operation requires cost now, and the cost is the summation of those two to be added. So, to add <strong>1</strong> and <strong>10</strong>, you need a cost of<strong>11</strong>. If you want to add <strong>1</strong>, <strong>2</strong> and <strong>3</strong>. There are several ways –</p>
<p>1 + 2 &#x3D; 3, cost &#x3D; 3</p>
<p>3 + 3 &#x3D; 6, cost &#x3D; 6</p>
<p>Total &#x3D; 9</p>
<p>1 + 3 &#x3D; 4, cost &#x3D; 4</p>
<p>2 + 4 &#x3D; 6, cost &#x3D; 6</p>
<p>Total &#x3D; 10</p>
<p>2 + 3 &#x3D; 5, cost &#x3D; 5</p>
<p>1 + 5 &#x3D; 6, cost &#x3D; 6</p>
<p>Total &#x3D; 11</p>
<p>I hope you have understood already your mission, to add a set of integers so that the cost is minimal.</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>Each test case will start with a positive number, <strong>N (2 ≤ N ≤ 5000)</strong> followed by <strong>N</strong> positive integers (all are less than <strong>100000</strong>). Input is terminated by a case where the value of <strong>N</strong> is zero. This case should not be processed.</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each case print the minimum total cost of addition in a single line.</p>
<h1 id="Sample-Input-Output-for-Sample-Input"><a href="#Sample-Input-Output-for-Sample-Input" class="headerlink" title="Sample Input Output for Sample Input"></a><strong>Sample Input Output for Sample Input</strong></h1><p><strong>3</strong></p>
<p><strong>1 2 3</strong></p>
<p><strong>4</strong></p>
<p><strong>1 2 3 4</strong></p>
<p><strong>0</strong></p>
<hr>
<p><strong>9</strong></p>
<p><strong>19</strong></p>
<hr>
<hr>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 11988 Broken Keyboard(模拟链表)</title>
    <url>/posts/oj/ds/UVa%2011988%20Broken%20Keyboard(%E6%A8%A1%E6%8B%9F%E9%93%BE%E8%A1%A8)/</url>
    <content><![CDATA[<p>题意 有一个键盘坏了 会在你不知道的情况下按下home或者end 给你这个键盘的实际输入 要求输出显示器上的实际显示</p>
<p>输入最大5MB 所以直接数组检索肯定会超时的 用数组模拟链表 就可以很快了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N=<span class="number">100005</span>;</span><br><span class="line">char s[N];</span><br><span class="line">int next[N];</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int last,cur;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        next[<span class="number">0</span>]=last=cur=<span class="number">0</span>;</span><br><span class="line">        int length=<span class="title function_">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=length;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;[&#x27;</span>) cur=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;]&#x27;</span>) cur=last;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                next[i]=next[cur];</span><br><span class="line">                next[cur]=i;</span><br><span class="line">                <span class="keyword">if</span>(cur==last) last=i;</span><br><span class="line">                cur=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(int i=next[<span class="number">0</span>];i;i=next[i])</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;%c&quot;</span>,s[i]);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Broken-Keyboard"><a href="#Broken-Keyboard" class="headerlink" title="Broken Keyboard"></a>Broken Keyboard</h2><p>You’re typing a long text with a broken keyboard. Well it’s not so badly broken. The only problem with the keyboard is that sometimes the “home” key or the “end” key gets automatically pressed (internally).</p>
<p>You’re not aware of this issue, since you’re focusing on the text and did not even turn on the monitor! After you finished typing, you can see a text on the screen (if you turn on the monitor).</p>
<p>In Chinese, we can call it Beiju. Your task is to find the Beiju text.</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>There are several test cases. Each test case is a single line containing at least one and at most 100,000 letters, underscores and two special characters ‘[‘ and ‘]’. ‘[‘ means the “Home” key is pressed internally, and ‘]’ means the “End” key is pressed internally. The input is terminated by end-of-file (EOF). The size of input file does not exceed 5MB.</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each case, print the Beiju text on the screen.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>This_is_a_[Beiju]_text [[]][][]Happy_Birthday_to_Tsinghua_University</p>
<h2 id="Output-for-the-Sample-Input"><a href="#Output-for-the-Sample-Input" class="headerlink" title="Output for the Sample Input"></a>Output for the Sample Input</h2><p>BeijuThis_is_a__text Happy_Birthday_to_Tsinghua_University</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 11988 Broken Keyboard(链表的应用)</title>
    <url>/posts/oj/ds/UVa%2011988%20Broken%20Keyboard(%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8)/</url>
    <content><![CDATA[<h2 id="Broken-Keyboard-a-k-a-Beiju-Text"><a href="#Broken-Keyboard-a-k-a-Beiju-Text" class="headerlink" title="Broken Keyboard (a.k.a. Beiju Text)"></a>Broken Keyboard (a.k.a. Beiju Text)</h2><p>You’re typing a long text with a broken keyboard. Well it’s not so badly broken. The only problem with the keyboard is that sometimes the “home” key or the “end” key gets automatically pressed (internally).</p>
<p>You’re not aware of this issue, since you’re focusing on the text and did not even turn on the monitor! After you finished typing, you can see a text on the screen (if you turn on the monitor).</p>
<p>In Chinese, we can call it Beiju. Your task is to find the Beiju text.</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>There are several test cases. Each test case is a single line containing at least one and at most 100,000 letters, underscores and two special characters ‘[‘ and ‘]’. ‘[‘ means the “Home” key is pressed internally, and ‘]’ means the “End” key is pressed internally. The input is terminated by end-of-file (EOF). The size of input file does not exceed 5MB.</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each case, print the Beiju text on the screen.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>This_is_a_[Beiju]_text [[]][][]Happy_Birthday_to_Tsinghua_University</p>
<h2 id="Output-for-the-Sample-Input"><a href="#Output-for-the-Sample-Input" class="headerlink" title="Output for the Sample Input"></a>Output for the Sample Input</h2><p>BeijuThis_is_a__text Happy_Birthday_to_Tsinghua_University</p>
<p>题意 电脑键盘的home键和end键坏了 会在你不注意时自动按下</p>
<p>给你一个输入序列 ‘[‘代表home键 ‘]’代表end键 要求输出屏幕上对应的输出</p>
<p>用链表保存每个位置的字符c和下一个位置的编号next 最后一个字符的next为0</p>
<p>并用cur表示光标的移动</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">100005</span>;</span><br><span class="line">char s[N], c;</span><br><span class="line">int cur, last, l;</span><br><span class="line">struct <span class="title class_">Node</span>&#123; char c; int next;&#125;  lis[N];</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (~scanf (<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        l = strlen (s + <span class="number">1</span>);</span><br><span class="line">        lis[<span class="number">0</span>].<span class="property">next</span> = last = cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= l; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;[&#x27;</span>) cur = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;]&#x27;</span>) cur = last;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                lis[i].<span class="property">c</span> = c;</span><br><span class="line">                lis[i].<span class="property">next</span> = lis[cur].<span class="property">next</span>;</span><br><span class="line">                lis[cur].<span class="property">next</span> = i;</span><br><span class="line">                <span class="keyword">if</span> (cur == last) last = i;</span><br><span class="line">                cur = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (int i = lis[<span class="number">0</span>].<span class="property">next</span>; i != <span class="number">0</span>; i = lis[i].<span class="property">next</span>)</span><br><span class="line">            printf (<span class="string">&quot;%c&quot;</span>, lis[i].<span class="property">c</span>);</span><br><span class="line">        printf (<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 122 Trees on the level(建树，层次遍历)</title>
    <url>/posts/oj/ds/UVa%20122%20Trees%20on%20the%20level(%E5%BB%BA%E6%A0%91%EF%BC%8C%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86)/</url>
    <content><![CDATA[<p>题意 建树并层次遍历输出 (data,pos) pos表示改节点位置 L代表左儿子 R代表右儿子</p>
<p>建树很简单 开始在根节点 遇到L往左走遇到R往右走 节点不存在就新建 走完了就保存改节点的值 输出直接bfs就行了了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int maxn = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">char s[maxn][maxn];</span><br><span class="line">int t, n, lans;</span><br><span class="line">bool comp;</span><br><span class="line"></span><br><span class="line">struct <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    int data;</span><br><span class="line">    <span class="title class_">Node</span>* left, *right;</span><br><span class="line">    bool have;</span><br><span class="line">    <span class="title class_">Node</span>(): <span class="title function_">left</span>(<span class="variable constant_">NULL</span>), <span class="title function_">right</span>(<span class="variable constant_">NULL</span>), <span class="title function_">have</span>(<span class="params"><span class="literal">false</span></span>) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Node</span> *ans[maxn];</span><br><span class="line"></span><br><span class="line">bool <span class="title function_">bfs</span>(<span class="params">Node* root</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int fro = <span class="number">0</span>, bac = <span class="number">0</span>;</span><br><span class="line">    ans[fro] = root;</span><br><span class="line">    <span class="keyword">while</span>(fro &lt;= bac)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!ans[fro]-&gt;have) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(ans[fro]-&gt;left != <span class="variable constant_">NULL</span>) ans[++bac] = ans[fro]-&gt;left;</span><br><span class="line">        <span class="keyword">if</span>(ans[fro]-&gt;right != <span class="variable constant_">NULL</span>) ans[++bac] = ans[fro]-&gt;right;</span><br><span class="line">        ++fro;</span><br><span class="line">    &#125;</span><br><span class="line">    lans = bac;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[<span class="number">0</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        <span class="title class_">Node</span> root, *cur = &amp;root;</span><br><span class="line">        comp = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">            int l = <span class="title function_">strlen</span>(s[n]);</span><br><span class="line">            <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; l; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="title function_">isdigit</span>(s[n][i]))</span><br><span class="line">                &#123;</span><br><span class="line">                    t = t * <span class="number">10</span> + s[n][i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[n][i] == <span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cur-&gt;left == <span class="variable constant_">NULL</span>)</span><br><span class="line">                        cur-&gt;left = <span class="keyword">new</span> <span class="title class_">Node</span>;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[n][i] == <span class="string">&#x27;R&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cur-&gt;right == <span class="variable constant_">NULL</span>)</span><br><span class="line">                        cur-&gt;right = <span class="keyword">new</span> <span class="title class_">Node</span>;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;have) comp = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;data = t;</span><br><span class="line">                cur-&gt;have = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = &amp;root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[++n]), s[n][<span class="number">1</span>] != <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(comp) comp = <span class="title function_">bfs</span>(&amp;root);</span><br><span class="line">        <span class="keyword">if</span>(comp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; lans; ++i)</span><br><span class="line">                <span class="title function_">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]-&gt;data);</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[lans]-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="title function_">printf</span>(<span class="string">&quot;not complete\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Trees are fundamental in many branches of computer science. Current state-of-the art parallel computers such as Thinking Machines’ CM-5 are based on <em>fat trees</em>. Quad- and octal-trees are fundamental to many algorithms in computer graphics.</p>
<p>This problem involves building and traversing binary trees.</p>
<h2 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h2><p>Given a sequence of binary trees, you are to write a program that prints a level-order traversal of each tree. In this problem each node of a binary tree contains a positive integer and all binary trees have have fewer than 256 nodes.</p>
<p>In a <em>level-order</em> traversal of a tree, the data in all nodes at a given level are printed in left-to-right order and all nodes at level <em>k</em> are printed before all nodes at level <em>k</em>+1.</p>
<p>For example, a level order traversal of the tree</p>
<p><img src="/../images/dge.org-external-1-122img1.gif.png" alt="picture28"></p>
<p>is: 5, 4, 8, 11, 13, 4, 7, 2, 1.</p>
<p>In this problem a binary tree is specified by a sequence of pairs (<em>n</em>,<em>s</em>) where <em>n</em> is the value at the node whose path from the root is given by the string <em>s</em>. A path is given be a sequence of <em>L</em>‘s and <em>R</em>‘s where <em>L</em> indicates a left branch and <em>R</em> indicates a right branch. In the tree diagrammed above, the node containing 13 is specified by (13,RL), and the node containing 2 is specified by (2,LLR). The root node is specified by (5,) where the empty string indicates the path from the root to itself. A binary tree is considered to be <em>completely specified</em> if every node on all root-to-node paths in the tree is given a value exactly once.</p>
<h2 id="The-Input"><a href="#The-Input" class="headerlink" title="The Input"></a>The Input</h2><p>The input is a sequence of binary trees specified as described above. Each tree in a sequence consists of several pairs (<em>n</em>,<em>s</em>) as described above separated by whitespace. The last entry in each tree is (). No whitespace appears between left and right parentheses.</p>
<p>All nodes contain a positive integer. Every tree in the input will consist of at least one node and no more than 256 nodes. Input is terminated by end-of-file.</p>
<h2 id="The-Output"><a href="#The-Output" class="headerlink" title="The Output"></a>The Output</h2><p>For each completely specified binary tree in the input file, the level order traversal of that tree should be printed. If a tree is not completely specified, i.e., some node in the tree is NOT given a value or a node is given a value more than once, then the string &#96;&#96;not complete’’ should be printed.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>(11,LL) (7,LLL) (8,R) (5,) (4,L) (13,RL) (2,LLR) (1,RRR) (4,RR) () (3,L) (4,R) ()</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>5 4 8 11 13 4 7 2 1 not complete</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 12657 Boxes in a Line(双向链表的应用)</title>
    <url>/posts/oj/ds/UVa%2012657%20Boxes%20in%20a%20Line(%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8)/</url>
    <content><![CDATA[<h1 id="题意-开始有n个盒子按1到n的顺序排列-对这些盒子进行m次操作-每次为把x移到y的左边-右边-交换x-y-颠倒顺序中的一个"><a href="#题意-开始有n个盒子按1到n的顺序排列-对这些盒子进行m次操作-每次为把x移到y的左边-右边-交换x-y-颠倒顺序中的一个" class="headerlink" title="题意 开始有n个盒子按1到n的顺序排列 对这些盒子进行m次操作 每次为把x移到y的左边 右边 交换x,y 颠倒顺序中的一个"></a>题意 开始有n个盒子按1到n的顺序排列 对这些盒子进行m次操作 每次为把x移到y的左边 右边 交换x,y 颠倒顺序中的一个</h1><p>求操作完成后所有奇数位原盒子序号的和;</p>
<p>直接模拟肯定会超时 用stl中的链表也超时 只能用数组自己模拟一个双向链表了 le[i],ri[i]分别表示第i个盒子左边盒子的序号和右边盒子的序号 代码中有注释</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">100005</span>;</span><br><span class="line">int le[N], ri[N], n, m;</span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> link (int l, int r)              <span class="comment">//连接l和r，l在左边</span></span><br><span class="line">&#123;</span><br><span class="line">    le[r] = l;  ri[l] = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas = <span class="number">0</span>, op, x, y, t;</span><br><span class="line">    <span class="keyword">while</span> (scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m) != <span class="variable constant_">EOF</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            ri[i] = i + <span class="number">1</span>, le[i] = i - <span class="number">1</span>;</span><br><span class="line">        ri[n] = <span class="number">0</span>, le[<span class="number">0</span>] = n, ri[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        int flag = <span class="number">0</span>;                      <span class="comment">//判断是否翻转</span></span><br><span class="line">        <span class="keyword">while</span> (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf (<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="number">4</span>) flag = !flag;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">                <span class="keyword">if</span> (flag &amp;&amp; op != <span class="number">3</span>) op = <span class="number">3</span> - op; <span class="comment">//翻转后移动操作就相反了</span></span><br><span class="line">                <span class="keyword">if</span> (ri[y] == x &amp;&amp; op == <span class="number">3</span>)        <span class="comment">//方便后面判断交换是否相邻</span></span><br><span class="line">                    t = x, x = y, y = t;</span><br><span class="line">                <span class="keyword">if</span> ( (op == <span class="number">1</span> &amp;&amp; le[y] == x) || (op == <span class="number">2</span> &amp;&amp; ri[y] == x))  <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (op == <span class="number">1</span>)                      <span class="comment">//x移到y右边</span></span><br><span class="line">                    link (le[x], ri[x]), link (le[y], x), link (x, y);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>)                 <span class="comment">//x移到y左边</span></span><br><span class="line">                    link (le[x], ri[x]), link (x, ri[y]), link (y, x);</span><br><span class="line">                <span class="keyword">else</span>  <span class="keyword">if</span> (y == ri[x])             <span class="comment">//op==3&amp;&amp;x,y相邻</span></span><br><span class="line">                    link (le[x], y), link (x, ri[y]), link (y, x);</span><br><span class="line">                <span class="keyword">else</span>                              <span class="comment">//不相邻</span></span><br><span class="line">                &#123;</span><br><span class="line">                    int ry = ri[y], ly = le[y];</span><br><span class="line">                    link (le[x], y), link (y, ri[x]), link (ly, x), link (x, ry);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        t = <span class="number">0</span>; ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            t = ri[t];</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span>) ans += t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; flag)    <span class="comment">//n为偶数且翻转过 故求的恰为偶数位的和</span></span><br><span class="line">            ans = (ll) n / <span class="number">2</span> * (<span class="number">1</span> + n) - ans;</span><br><span class="line">        printf (<span class="string">&quot;Case %d: %lld\n&quot;</span>, ++cas, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Boxes-in-a-Line"><a href="#Boxes-in-a-Line" class="headerlink" title="Boxes in a Line"></a>Boxes in a Line</h1><p>You have n boxes in a line on the table numbered 1 . . . n from left to right. Your task is to simulate 4<br>kinds of commands:<br>• 1 X Y : move box X to the left to Y (ignore this if X is already the left of Y )<br>• 2 X Y : move box X to the right to Y (ignore this if X is already the right of Y )<br>• 3 X Y : swap box X and Y<br>• 4: reverse the whole line.<br>Commands are guaranteed to be valid, i.e. X will be not equal to Y .<br>For example, if n &#x3D; 6, after executing 1 1 4, the line becomes 2 3 1 4 5 6. Then after executing<br>2 3 5, the line becomes 2 1 4 5 3 6. Then after executing 3 1 6, the line becomes 2 6 4 5 3 1.<br>Then after executing 4, then line becomes 1 3 5 4 6 2</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>There will be at most 10 test cases. Each test case begins with a line containing 2 integers n, m<br>(1 ≤ n, m ≤ 100, 000). Each of the following m lines contain a command.</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each test case, print the sum of numbers at odd-indexed positions. Positions are numbered 1 to n<br>from left to right.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>6 4<br>1 1 4<br>2 3 5<br>3 1 6<br>4<br>6 3<br>1 1 4<br>2 3 5<br>3 1 6<br>100000 1<br>4</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>Case 1: 12<br>Case 2: 9<br>Case 3: 2500050000</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 133 The Dole Queue</title>
    <url>/posts/oj/ds/UVa%20133%20The%20Dole%20Queue/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p>In a serious attempt to downsize (reduce) the dole queue, The New National Green Labour Rhinoceros Party has decided on the following strategy. Every day all dole applicants will be placed in a large circle, facing inwards. Someone is arbitrarily chosen as number 1, and the rest are numbered counter-clockwise up to N (who will be standing on 1’s left). Starting from 1 and moving counter-clockwise, one labour official counts off k applicants, while another official starts from N and moves clockwise, counting m applicants. The two who are chosen are then sent off for retraining; if both officials pick the same person she (he) is sent off to become a politician. Each official then starts counting again at the next available person and the process continues until no-one is left. Note that the two victims (sorry, trainees) leave the ring simultaneously, so it is possible for one official to count a person already selected by the other official.</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>Write a program that will successively read in (in that order) the three numbers (N, k and m; k, m &gt; 0, 0 &lt; N &lt; 20) and determine the order in which the applicants are sent off for retraining. Each set of three numbers will be on a separate line and the end of data will be signalled by three zeroes (0 0 0).</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each triplet, output a single line of numbers specifying the order in which people are chosen. Each number should be in a field of 3 characters. For pairs of numbers list the person chosen by the counter-clockwise official first. Separate successive pairs (or singletons) by commas (but there should not be a trailing comma).</p>
<h2 id="Sample-input"><a href="#Sample-input" class="headerlink" title="Sample input"></a>Sample input</h2><p>10 4 3 0 0 0</p>
<h2 id="Sample-output"><a href="#Sample-output" class="headerlink" title="Sample output"></a>Sample output</h2><p><img src="/../images/dge.org-external-1-133img1.gif.png" alt="tex2html_wrap_inline34"> 4 <img src="/../images/dge.org-external-1-133img1.gif.png" alt="tex2html_wrap_inline34"> 8, <img src="/../images/dge.org-external-1-133img1.gif.png" alt="tex2html_wrap_inline34"> 9 <img src="/../images/dge.org-external-1-133img1.gif.png" alt="tex2html_wrap_inline34"> 5, <img src="/../images/dge.org-external-1-133img1.gif.png" alt="tex2html_wrap_inline34"> 3 <img src="/../images/dge.org-external-1-133img1.gif.png" alt="tex2html_wrap_inline34"> 1, <img src="/../images/dge.org-external-1-133img1.gif.png" alt="tex2html_wrap_inline34"> 2 <img src="/../images/dge.org-external-1-133img1.gif.png" alt="tex2html_wrap_inline34"> 6, <img src="/../images/dge.org-external-1-133img2.gif.png" alt="tex2html_wrap_inline50"> 10, <img src="/../images/dge.org-external-1-133img1.gif.png" alt="tex2html_wrap_inline34"> 7</p>
<p>where <img src="/../images/dge.org-external-1-133img2.gif.png" alt="tex2html_wrap_inline50"> represents a space.</p>
<p>N个人按逆时针从一到n排成一个环 官员1从1开始每次逆时针走过k个人 选出停留地方的人 官员2从n开始每次顺时针走过m个人 选出停留地方的人</p>
<p>若停留地方相同 则只选出一个人 求这些人被选出的顺序 直接模拟就行了;</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">22</span>;</span><br><span class="line">int a[N], n, k, m, r, t1, t2;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (scanf (<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;k, &amp;m), n)</span><br><span class="line">    &#123;</span><br><span class="line">        memset (a, -<span class="number">1</span>, sizeof (a));</span><br><span class="line">        t2 = <span class="number">1</span>;</span><br><span class="line">        t1 = r = n;</span><br><span class="line">        <span class="keyword">while</span> (r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">                <span class="keyword">do</span> t1 = ((t1 == n) ? <span class="number">1</span> : t1 + <span class="number">1</span>); <span class="keyword">while</span> (a[t1] == <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">                <span class="keyword">do</span> t2 = ((t2 == <span class="number">1</span>) ? n : t2 - <span class="number">1</span>); <span class="keyword">while</span> (a[t2] == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            r = (t1 == t2 ? r - <span class="number">1</span> : r - <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (t1 == t2)  printf (<span class="string">&quot;%3d&quot;</span>, t1);</span><br><span class="line">            <span class="keyword">else</span> printf (<span class="string">&quot;%3d%3d&quot;</span>, t1, t2);</span><br><span class="line">            a[t1] = a[t2] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (r)  printf (<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        printf (<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 136 Ugly Numbers(优先队列)</title>
    <url>/posts/oj/ds/UVa%20136%20Ugly%20Numbers(%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97)/</url>
    <content><![CDATA[<p>题意 质因数只可能有2,3,5的数称为丑数 输出第1500个丑数</p>
<p>STL优队列应用 1是丑数 丑数的2,3,5倍都是丑数 用优先队列模拟就行了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line"><span class="comment">//priority_queue&lt;ll, vector&lt;ll&gt;, greater&lt;ll&gt; &gt; q;</span></span><br><span class="line">struct cmp&#123;</span><br><span class="line">    bool operator () (ll a, ll b)    &#123; <span class="keyword">return</span> a &gt; b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;ll, vector&lt;ll&gt;, cmp&gt; q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">set&lt;ll&gt; cnt;</span><br><span class="line">int ugly[<span class="number">3</span>] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    ll a, b;</span><br><span class="line">    q.<span class="title function_">push</span>(<span class="number">1</span>);</span><br><span class="line">    cnt.<span class="title function_">insert</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>;; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        a = q.<span class="title function_">top</span>();</span><br><span class="line">        q.<span class="title function_">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1500</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            b = a * ugly[j];</span><br><span class="line">            <span class="keyword">if</span>(!cnt.<span class="title function_">count</span>(b))</span><br><span class="line">                cnt.<span class="title function_">insert</span>(b), q.<span class="title function_">push</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">printf</span>(<span class="string">&quot;The 1500&#x27;th ugly number is %lld.\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p>Ugly numbers are numbers whose only prime factors are 2, 3 or 5. The sequence</p>
<p>1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, …</p>
<p>shows the first 11 ugly numbers. By convention, 1 is included.</p>
<p>Write a program to find and print the 1500’th ugly number.</p>
<h2 id="Input-and-Output"><a href="#Input-and-Output" class="headerlink" title="Input and Output"></a>Input and Output</h2><p>There is no input to this program. Output should consist of a single line as shown below, with <number> replaced by the number computed.</p>
<h2 id="Sample-output"><a href="#Sample-output" class="headerlink" title="Sample output"></a>Sample output</h2><p>The 1500’th ugly number is <number>.</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 156 Ananagrams(STL,map)</title>
    <url>/posts/oj/ds/UVa%20156%20Ananagrams(STL,map)/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p>Most crossword puzzle fans are used to <em>anagrams</em>–groups of words with the same letters in different orders–for example OPTS, SPOT, STOP, POTS and POST. Some words however do not have this attribute, no matter how you rearrange their letters, you cannot form another word. Such words are called <em>ananagrams</em>, an example is QUIZ.</p>
<p>Obviously such definitions depend on the domain within which we are working; you might think that ATHENE is an ananagram, whereas any chemist would quickly produce ETHANE. One possible domain would be the entire English language, but this could lead to some problems. One could restrict the domain to, say, Music, in which case SCALE becomes a <em>relative ananagram</em> (LACES is not in the same domain) but NOTE is not since it can produce TONE.</p>
<p>Write a program that will read in the dictionary of a restricted domain and determine the relative ananagrams. Note that single letter words are, ipso facto, relative ananagrams since they cannot be &#96;&#96;rearranged’’ at all. The dictionary will contain no more than 1000 words.</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>Input will consist of a series of lines. No line will be more than 80 characters long, but may contain any number of words. Words consist of up to 20 upper and&#x2F;or lower case letters, and will not be broken across lines. Spaces may appear freely around words, and at least one space separates multiple words on the same line. Note that words that contain the same letters but of differing case are considered to be anagrams of each other, thus tIeD and EdiT are anagrams. The file will be terminated by a line consisting of a single &#x2F;#.</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>Output will consist of a series of lines. Each line will consist of a single word that is a relative ananagram in the input dictionary. Words must be output in lexicographic (case-sensitive) order. There will always be at least one relative ananagram.</p>
<h2 id="Sample-input"><a href="#Sample-input" class="headerlink" title="Sample input"></a>Sample input</h2><p>ladder came tape soon leader acme RIDE lone Dreis peat ScAlE orb eye Rides dealer NotE derail LaCeS drIed noel dire Disk mace Rob dries &#x2F;#</p>
<h2 id="Sample-output"><a href="#Sample-output" class="headerlink" title="Sample output"></a>Sample output</h2><p>Disk NotE derail drIed eye ladder soon</p>
<p>题意 给你一篇文章 以”&#x2F;#”号结束 按字典序求输出这篇文章中真正只出现过一次的单词 就是不能通过字母重新排列得到文章中另一个单词的单词</p>
<p>把每个单词的字母全部化为小写 再把这个单词中的字母按字典序排列 得到一个字符串 用map记下出现次数就行 只出现过一次的就是要输出的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef vector&lt;string&gt;::iterator it;</span><br><span class="line">vector&lt;string&gt; ans;</span><br><span class="line">map&lt;string, int&gt; cnt, tcnt;</span><br><span class="line">map&lt;string, string&gt; ss;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    string s, t;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; s, s != <span class="string">&quot;#&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t = s;</span><br><span class="line">        ans.<span class="property">push_back</span> (s);</span><br><span class="line">        <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; t.<span class="title function_">length</span>(); ++j)</span><br><span class="line">            t[j] = tolower (t[j]);</span><br><span class="line">        sort (t.<span class="title function_">begin</span>(), t.<span class="title function_">end</span>());</span><br><span class="line">        ss[s] = t;</span><br><span class="line">        ++cnt[t];</span><br><span class="line">    &#125;</span><br><span class="line">    sort (ans.<span class="title function_">begin</span>(), ans.<span class="title function_">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (it i = ans.<span class="title function_">begin</span>(); i &lt; ans.<span class="title function_">end</span>(); ++i)</span><br><span class="line">        <span class="keyword">if</span> (cnt[ss[*i]] == <span class="number">1</span>)  cout &lt;&lt; *i &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 210 Concurrency Simulator(双端队列)</title>
    <url>/posts/oj/ds/UVa%20210%20Concurrency%20Simulator(%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97)/</url>
    <content><![CDATA[<p>题意 模拟程序并行运行</p>
<p>STL队列 双端队列 的应用 用双端队列维护即将执行的程序 再用个队列维护等待变量释放的程序 用lock表示变量锁定状态<br>先将所有程序依次放到执行队列中 每次取出队首程序运行不超过lim时间 未运行完又放到执行队列队尾<br>遇到lock时 若当前锁定状态为false就将锁定状态变为true 否则将当前程序放到等待队列队尾并结束运行<br>遇到unlock时 若等待队列有程序 就将等待队列队首程序放到执行队列队首</p>
<p>遇到end时 退出当前执行(不再进队尾)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1005</span>;</span><br><span class="line">bool lock;</span><br><span class="line">deque&lt;int&gt; qr;<span class="comment">//执行队列</span></span><br><span class="line">queue&lt;int&gt; qb;<span class="comment">//等待队列</span></span><br><span class="line">vector&lt;string&gt; prg[N];</span><br><span class="line">string s;</span><br><span class="line">int t[N], p[N], <span class="keyword">var</span>[<span class="number">26</span>], lim;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">run</span>(<span class="params">int i</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int rt = lim, v;</span><br><span class="line">    string cur;</span><br><span class="line">    <span class="keyword">while</span>(rt &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cur = prg[i][p[i]];</span><br><span class="line">        <span class="keyword">if</span>(cur[<span class="number">2</span>] == <span class="string">&#x27;=&#x27;</span>)  <span class="comment">// 赋值</span></span><br><span class="line">        &#123;</span><br><span class="line">            rt -= t[<span class="number">0</span>];</span><br><span class="line">            v = cur[<span class="number">4</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.<span class="title function_">size</span>() == <span class="number">6</span>) v = v * <span class="number">10</span> + cur[<span class="number">5</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">var</span>[cur[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>] = v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cur[<span class="number">2</span>] == <span class="string">&#x27;i&#x27;</span>)   <span class="comment">//print</span></span><br><span class="line">        &#123;</span><br><span class="line">            rt -= t[<span class="number">1</span>];</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;%d: %d\n&quot;</span>, i, <span class="keyword">var</span>[cur[<span class="number">6</span>] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cur[<span class="number">2</span>] == <span class="string">&#x27;c&#x27;</span>)   <span class="comment">//lock</span></span><br><span class="line">        &#123;</span><br><span class="line">            rt -= t[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(lock)</span><br><span class="line">            &#123;</span><br><span class="line">                qb.<span class="title function_">push</span>(i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> lock = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cur[<span class="number">2</span>] == <span class="string">&#x27;l&#x27;</span>)  <span class="comment">//unlock</span></span><br><span class="line">        &#123;</span><br><span class="line">            lock = <span class="literal">false</span>;</span><br><span class="line">            rt -= t[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">if</span>(!qb.<span class="title function_">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                v = qb.<span class="title function_">front</span>();</span><br><span class="line">                qb.<span class="title function_">pop</span>();</span><br><span class="line">                qr.<span class="title function_">push_front</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span>;  <span class="comment">//end</span></span><br><span class="line">        ++p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    qr.<span class="title function_">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas, n;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span>(cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t[i]);</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;lim);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            prg[i].<span class="title function_">clear</span>();</span><br><span class="line">            <span class="keyword">while</span>(<span class="title function_">getline</span>(cin, s))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s == <span class="string">&quot;&quot;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                prg[i].<span class="title function_">push_back</span>(s);</span><br><span class="line">                <span class="keyword">if</span>(prg[i].<span class="title function_">back</span>() == <span class="string">&quot;end&quot;</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            qr.<span class="title function_">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">memset</span>(p, <span class="number">0</span>, <span class="title function_">sizeof</span>(p));</span><br><span class="line">        <span class="title function_">memset</span>(<span class="keyword">var</span>, <span class="number">0</span>, <span class="title function_">sizeof</span>(<span class="keyword">var</span>));</span><br><span class="line">        <span class="keyword">while</span>(!qr.<span class="title function_">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            int cur = qr.<span class="title function_">front</span>();</span><br><span class="line">            qr.<span class="title function_">pop_front</span>();</span><br><span class="line">            <span class="title function_">run</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cas) <span class="title function_">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p>Programs executed concurrently on a uniprocessor system appear to be executed at the same time, but in reality the single CPU alternates between the programs, executing some number of instructions from each program before switching to the next. You are to simulate the concurrent execution of up to ten programs on such a system and determine the output that they will produce.</p>
<p>The program that is currently being executed is said to be running, while all programs awaiting execution are said to be ready. A program consists of a sequence of no more than 25 statements, one per line, followed by an end statement. The statements available are listed below.</p>
<p><img src="/../images/dge.org-external-2-210img1.gif.png" alt="tex2html_wrap66"> <img src="/../images/dge.org-external-2-210img2.gif.png" alt="tex2html_wrap68"></p>
<p>Each statement requires an integral number of time units to execute. The running program is permitted to continue executing instructions for a period of time called its quantum. When a program�s time <em>quantum</em> expires, another ready program will be selected to run. Any instruction currently being executed when the time quantum expires will be allowed to complete.</p>
<p>Programs are queued first-in-first-out for execution in a <em>ready queue</em>. The initial order of the ready queue corresponds to the original order of the programs in the input file. This order can change, however, as a result of the execution of <strong>lock</strong> and <strong>unlock</strong> statements.</p>
<p>The <strong>lock</strong> and <strong>unlock</strong> statements are used whenever a program wishes to claim mutually exclusive access to the variables it is manipulating. These statements always occur in pairs, bracketing one or more other statements. A <strong>lock</strong> will always precede an <strong>unlock</strong>, and these statements will never be nested. Once a program successfully executes a <strong>lock</strong> statement, no other program may successfully execute a <strong>lock</strong> statement until the locking program runs and executes the corresponding <strong>unlock</strong>statement. Should a running program attempt to execute a <strong>lock</strong> while one is already in effect, this program will be placed at the end of the <em>blocked queue</em>. Programs blocked in this fashion lose any of their current time quantum remaining. When an <strong>unlock</strong> is executed, any program at the head of the blocked queue is moved to the head of the ready queue. The first statement this program will execute when it runs will be the <strong>lock</strong> statement that previously failed. Note that it is up to the programs involved to enforce the mutual exclusion protocol through correct usage of <strong>lock</strong> and<strong>unlock</strong> statements. (A renegade program with no <strong>lock</strong>&#x2F;<strong>unlock</strong> pair could alter any variables it wished, despite the proper use of <strong>lock</strong>&#x2F;<strong>unlock</strong> by the other programs.)</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p><strong>The input begins with a single positive integer on a line by itself indicating the number of the cases following, each of them as described below. This line is followed by a blank line, and there is also a blank line between two consecutive inputs.</strong></p>
<p>The first line of the input file consists of seven integers separated by spaces. These integers specify (in order): the number of programs which follow, the unit execution times for each of the five statements (in the order given above), and the number of time units comprising the time quantum. The remainder of the input consists of the programs, which are correctly formed from statements according to the rules described above.</p>
<p>All program statements begin in the first column of a line. Blanks appearing in a statement should be ignored. Associated with each program is an identification number based upon its location in the input data (the first program has ID &#x3D; 1, the second has ID &#x3D; 2, etc.).</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p><strong>For each test case, the output must follow the description below. The outputs of two consecutive cases will be separated by a blank line.</strong></p>
<p>Your output will contain of the output generated by the print statements as they occur during the simulation. When a print statement is executed, your program should display the program ID, a colon, a space, and the value of the selected variable. Output from separate print statements should appear on separate lines.</p>
<p>A sample input and correct output are shown below.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>1 3 1 1 1 1 1 1 a &#x3D; 4 print a lock b &#x3D; 9 print b unlock print b end a &#x3D; 3 print a lock b &#x3D; 8 print b unlock print b end b &#x3D; 5 a &#x3D; 17 print a print b lock b &#x3D; 21 print b unlock print b end</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>1: 3 2: 3 3: 17 3: 9 1: 9 1: 9 2: 8 2: 8 3: 21 3: 21</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 297 Quadtrees(四分树)</title>
    <url>/posts/oj/ds/UVa%20297%20Quadtrees(%E5%9B%9B%E5%88%86%E6%A0%91)/</url>
    <content><![CDATA[<p>题意 可以用一个四分图表示一32&#x2F;*32的黑白图像 求两个四分树对应图像相加所得图形黑色部分有多少像素</p>
<p>直接用一个32&#x2F;*32的矩阵表示图 黑色为非0白色为0 递归建图 最后有多少个非零就是答案了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int L = <span class="number">32</span>, N = <span class="number">1050</span>;</span><br><span class="line">char s[N];</span><br><span class="line">int ans[L][L], cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">draw</span>(<span class="params">char *s, int &amp;p, int r, int c, int w</span>)</span><br><span class="line">&#123;</span><br><span class="line">    char ch = s[p++];</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">draw</span>(s, p, r        , c + w / <span class="number">2</span>, w / <span class="number">2</span>);</span><br><span class="line">        <span class="title function_">draw</span>(s, p, r        , c        , w / <span class="number">2</span>);</span><br><span class="line">        <span class="title function_">draw</span>(s, p, r + w / <span class="number">2</span>, c        , w / <span class="number">2</span>);</span><br><span class="line">        <span class="title function_">draw</span>(s, p, r + w / <span class="number">2</span>, c + w / <span class="number">2</span>, w / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = r; i &lt; r + w; ++i)</span><br><span class="line">            <span class="keyword">for</span>(int j = c; j &lt; c + w; ++j)</span><br><span class="line">                <span class="keyword">if</span>(ans[i][j] == <span class="number">0</span>)</span><br><span class="line">                    ans[i][j] = ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span>(cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">memset</span>(ans, <span class="number">0</span>, <span class="title function_">sizeof</span>(ans));</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">            int p = <span class="number">0</span>;</span><br><span class="line">            <span class="title function_">draw</span>(s, p, <span class="number">0</span>, <span class="number">0</span>, L);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;There are %d black pixels.\n&quot;</span>, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p>A quadtree is a representation format used to encode images. The fundamental idea behind the quadtree is that any image can be split into four quadrants. Each quadrant may again be split in four sub quadrants, etc. In the quadtree, the image is represented by a parent node, while the four quadrants are represented by four child nodes, in a predetermined order.</p>
<p>Of course, if the whole image is a single color, it can be represented by a quadtree consisting of a single node. In general, a quadrant needs only to be subdivided if it consists of pixels of different colors. As a result, the quadtree need not be of uniform depth.</p>
<p>A modern computer artist works with black-and-white images of <img src="/../images/dge.org-external-2-297img1.gif.png" alt="tex2html_wrap_inline34"> units, for a total of 1024 pixels per image. One of the operations he performs is adding two images together, to form a new image. In the resulting image a pixel is black if it was black in at least one of the component images, otherwise it is white.</p>
<p>This particular artist believes in what he calls the <em>preferred fullness</em>: for an image to be interesting (i.e. to sell for big bucks) the most important property is the number of filled (black) pixels in the image. So, before adding two images together, he would like to know how many pixels will be black in the resulting image. Your job is to write a program that, given the quadtree representation of two images, calculates the number of pixels that are black in the image, which is the result of adding the two images together.</p>
<p>In the figure, the first example is shown (from top to bottom) as image, quadtree, pre-order string (defined below) and number of pixels. The quadrant numbering is shown at the top of the figure.</p>
<p><img src="/../images/dge.org-external-2-297img2.gif.png"></p>
<h2 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification"></a>Input Specification</h2><p>The first line of input specifies the number of test cases (<em>N</em>) your program has to process.</p>
<p>The input for each test case is two strings, each string on its own line. The string is the pre-order representation of a quadtree, in which the letter ‘p’ indicates a parent node, the letter ‘f’ (full) a black quadrant and the letter ‘e’ (empty) a white quadrant. It is guaranteed that each string represents a valid quadtree, while the depth of the tree is not more than 5 (because each pixel has only one color).</p>
<h2 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification"></a>Output Specification</h2><p>For each test case, print on one line the text ‘There are <em>X</em> black pixels.’, where <em>X</em> is the number of black pixels in the resulting image.</p>
<h2 id="Example-Input"><a href="#Example-Input" class="headerlink" title="Example Input"></a>Example Input</h2><p>3 ppeeefpffeefe pefepeefe peeef peefe peeef peepefefe</p>
<h2 id="Example-Output"><a href="#Example-Output" class="headerlink" title="Example Output"></a>Example Output</h2><p>There are 640 black pixels. There are 512 black pixels. There are 384 black pixels.</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 439 Knight Moves(BFS应用)</title>
    <url>/posts/oj/ds/UVa%20439%20Knight%20Moves(BFS%E5%BA%94%E7%94%A8)/</url>
    <content><![CDATA[<p>题意 求国际象棋中骑士从一个位置移东到另一个位置所需最少步数</p>
<p>基础的BFS应用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int x[] = &#123; -<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">int y[] = &#123; -<span class="number">1</span>, -<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">2</span>, -<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">int d[<span class="number">15</span>][<span class="number">15</span>], sx, sy, ex, ey;</span><br><span class="line">pair&lt;int, int&gt; q[<span class="number">105</span>], t;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">bfs</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cx, cy, r, c, front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">    <span class="title function_">memset</span>(d, -<span class="number">1</span>, <span class="title function_">sizeof</span>(d));</span><br><span class="line">    d[sx][sy] = <span class="number">0</span>;</span><br><span class="line">    q[rear++] = <span class="title function_">make_pair</span>(sx, sy);</span><br><span class="line">    <span class="keyword">while</span>(front &lt; rear)</span><br><span class="line">    &#123;</span><br><span class="line">        t = q[front++];</span><br><span class="line">        cx = t.<span class="property">first</span>, cy = t.<span class="property">second</span>;</span><br><span class="line">        <span class="keyword">if</span>(cx == ex &amp;&amp; cy == ey) <span class="keyword">return</span> d[cx][cy];</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            r = cx + x[i], c = cy + y[i];</span><br><span class="line">            <span class="keyword">if</span>(r &lt; <span class="number">0</span> || r &gt; <span class="number">7</span> || c &lt; <span class="number">0</span> || c &gt; <span class="number">7</span> || d[r][c] &gt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            d[r][c] = d[cx][cy] + <span class="number">1</span>;</span><br><span class="line">            q[rear++] = <span class="title function_">make_pair</span>(r, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    char a[<span class="number">5</span>], b[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, a, b))</span><br><span class="line">    &#123;</span><br><span class="line">        sx = a[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>, sy = a[<span class="number">1</span>] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        ex = b[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>, ey = b[<span class="number">1</span>] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;To get from %s to %s takes %d knight moves.\n&quot;</span>, a, b, <span class="title function_">bfs</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p>A friend of you is doing research on the <em>Traveling Knight Problem (TKP)</em> where you are to find the shortest closed tour of knight moves that visits each square of a given set of <em>n</em> squares on a chessboard exactly once. He thinks that the most difficult part of the problem is determining the smallest number of knight moves between two given squares and that, once you have accomplished this, finding the tour would be easy.</p>
<p>Of course you know that it is vice versa. So you offer him to write a program that solves the “difficult” part.</p>
<p>Your job is to write a program that takes two squares <em>a</em> and <em>b</em> as input and then determines the number of knight moves on a shortest route from <em>a</em> to <em>b</em>.</p>
<h2 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification"></a>Input Specification</h2><p>The input file will contain one or more test cases. Each test case consists of one line containing two squares separated by one space. A square is a string consisting of a letter (a-h) representing the column and a digit (1-8) representing the row on the chessboard.</p>
<h2 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification"></a>Output Specification</h2><p>For each test case, print one line saying “To get from <em>xx</em> to <em>yy</em> takes <em>n</em> knight moves.”.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>e2 e4 a1 b2 b2 c3 a1 h8 a1 h7 h8 a1 b1 c3 f6 f6</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>To get from e2 to e4 takes 2 knight moves. To get from a1 to b2 takes 4 knight moves. To get from b2 to c3 takes 2 knight moves. To get from a1 to h8 takes 6 knight moves. To get from a1 to h7 takes 5 knight moves. To get from h8 to a1 takes 6 knight moves. To get from b1 to c3 takes 1 knight moves. To get from f6 to f6 takes 0 knight moves.</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 442 Matrix Chain Multiplication(矩阵链乘,模拟栈)</title>
    <url>/posts/oj/ds/UVa%20442%20Matrix%20Chain%20Multiplication(%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98,%E6%A8%A1%E6%8B%9F%E6%A0%88)/</url>
    <content><![CDATA[<p>题意 计算给定矩阵链乘表达式需要计算的次数 当前一个矩阵的列数等于后一个矩阵的行数时 他们才可以相乘 不合法输出error</p>
<p>输入是严格合法的 即使只有两个相乘也会用括号括起来 而且括号里最多有两个 那么就很简单了 遇到字母直接入栈 遇到反括号计算后入栈 然后就得到结果了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1000</span>;</span><br><span class="line">int st[N], row[N], col[N], r[N], c[N];</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, ans, top;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    char na[<span class="number">3</span>], s[N];</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, na);</span><br><span class="line">        int j = na[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;row[j], &amp;col[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;s))</span><br><span class="line">    &#123;</span><br><span class="line">        int i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">            c[i] = col[i], r[i] = row[i];</span><br><span class="line">        ans = top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; s[i] != <span class="string">&#x27;\0&#x27;</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_">isalpha</span>(s[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                int j = s[i] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">                st[++top] = j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(r[st[top]] != c[st[top - <span class="number">1</span>]])  <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    --top;</span><br><span class="line">                    c[st[top]] = c[st[top + <span class="number">1</span>]];</span><br><span class="line">                    ans += (r[st[top]] * c[st[top]] * r[st[top + <span class="number">1</span>]]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;\0&#x27;</span>) <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">        <span class="keyword">else</span> <span class="title function_">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p>Suppose you have to evaluate an expression like A&#x2F;*B&#x2F;*C&#x2F;*D&#x2F;*E where A,B,C,D and E are matrices. Since matrix multiplication is associative, the order in which multiplications are performed is arbitrary. However, the number of elementary multiplications needed strongly depends on the evaluation order you choose.</p>
<p>For example, let A be a 50&#x2F;*10 matrix, B a 10&#x2F;*20 matrix and C a 20&#x2F;*5 matrix. There are two different strategies to compute A&#x2F;*B&#x2F;*C, namely (A&#x2F;*B)&#x2F;<em>C and A&#x2F;</em>(B&#x2F;*C).</p>
<p>The first one takes 15000 elementary multiplications, but the second one only 3500.</p>
<p>Your job is to write a program that determines the number of elementary multiplications needed for a given evaluation strategy.</p>
<h2 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification"></a>Input Specification</h2><p>Input consists of two parts: a list of matrices and a list of expressions.</p>
<p>The first line of the input file contains one integer <em>n</em> ( <img src="/../images/dge.org-external-4-442img1.gif.png" alt="tex2html_wrap_inline28"> ), representing the number of matrices in the first part. The next <em>n</em> lines each contain one capital letter, specifying the name of the matrix, and two integers, specifying the number of rows and columns of the matrix.</p>
<p>The second part of the input file strictly adheres to the following syntax (given in EBNF):</p>
<p>SecondPart &#x3D; Line { Line } <EOF> Line &#x3D; Expression <CR> Expression &#x3D; Matrix | “(“ Expression Expression “)” Matrix &#x3D; “A” | “B” | “C” | … | “X” | “Y” | “Z”</p>
<h2 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification"></a>Output Specification</h2><p>For each expression found in the second part of the input file, print one line containing the word “error” if evaluation of the expression leads to an error due to non-matching matrices. Otherwise print one line containing the number of elementary multiplications needed to evaluate the expression in the way specified by the parentheses.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>9 A 50 10 B 10 20 C 20 5 D 30 35 E 35 15 F 15 5 G 5 10 H 10 20 I 20 25 A B C (AA) (AB) (AC) (A(BC)) ((AB)C) (((((DE)F)G)H)I) (D(E(F(G(HI))))) ((D(EF))((GH)I))</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>0 0 0 error 10000</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 514 Rails(栈)</title>
    <url>/posts/oj/ds/UVa%20514%20Rails(%E6%A0%88)/</url>
    <content><![CDATA[<p>题意 有n辆火车 按1到n的顺序进站 最后进站的车可以在任何时候出去 判断给定的出站序列是否可能</p>
<p>火车只有两种状态 从A进站 或者从站到B 模拟栈的操作就行了</p>
<p>令A表示A中当前待进站的第一辆火车 tar[B]表示出站序列中当前应该出站的火车 sta为火车站</p>
<p>当A&#x3D;&#x3D;tar[B]的时候 A进站马上出战 否则当站中最后一辆&#x3D;&#x3D;tar[B]时 这辆车出站 都不满足就只能A中的最前面的火车进站</p>
<p>当n辆火车全部进站 而站中还有火车是 给定的出战序列就是不可能的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1005</span>;</span><br><span class="line">int n, tar[N], A, B;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (scanf (<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (scanf (<span class="string">&quot;%d&quot;</span>, &amp;tar[<span class="number">1</span>]), tar[<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (int i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">                scanf (<span class="string">&quot;%d&quot;</span>, &amp;tar[i]);</span><br><span class="line">            stack&lt;int&gt; sta;</span><br><span class="line">            A = B = <span class="number">1</span>;</span><br><span class="line">            bool ok = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span> (B &lt;= n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (A == tar[B])</span><br><span class="line">                &#123;   ++A; ++B;   &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!sta.<span class="title function_">empty</span>() &amp;&amp; sta.<span class="title function_">top</span>() == tar[B])</span><br><span class="line">                &#123;   sta.<span class="title function_">pop</span>();  ++B;  &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (A &lt;= n)</span><br><span class="line">                    sta.<span class="property">push</span> (A++);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;   ok = <span class="literal">false</span>;  <span class="keyword">break</span>;  &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            printf (ok ? <span class="string">&quot;Yes\n&quot;</span> : <span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p>There is a famous railway station in PopPush City. Country there is incredibly hilly. The station was built in last century. Unfortunately, funds were extremely limited that time. It was possible to establish only a surface track. Moreover, it turned out that the station could be only a dead-end one (see picture) and due to lack of available space it could have only one track.</p>
<p><img src="/../images/dge.org-external-5-p514.gif.png" alt="\begin{picture}(6774,3429)(0,-10)\put(1789.500,1357.500){\arc{3645.278}{4.7247}......tFigFont{14}{16.8}{\rmdefault}{\mddefault}{\updefault}Station}}}}}\end{picture}"></p>
<p>The local tradition is that every train arriving from the direction A continues in the direction B with coaches reorganized in some way. Assume that the train arriving from the direction A has<img src="/../images/dge.org-external-5-514img2.gif.png" alt="$N \leŸ 1000$"> coaches numbered in increasing order <img src="/../images/dge.org-external-5-514img3.gif.png" alt="$1, 2, \dots, N$">. The chief for train reorganizations must know whether it is possible to marshal coaches continuing in the direction B so that their order will be <img src="/../images/dge.org-external-5-514img4.gif.png" alt="$a_1. a_2, \dots, a_N$">. Help him and write a program that decides whether it is possible to get the required order of coaches. You can assume that single coaches can be disconnected from the train before they enter the station and that they can move themselves until they are on the track in the direction B. You can also suppose that at any time there can be located as many coaches as necessary in the station. But once a coach has entered the station it cannot return to the track in the direction A and also once it has left the station in the direction B it cannot return back to the station.</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>The input file consists of blocks of lines. Each block except the last describes one train and possibly more requirements for its reorganization. In the first line of the block there is the integer N described above. In each of the next lines of the block there is a permutation of <img src="/../images/dge.org-external-5-514img3.gif.png" alt="$1, 2, \dots, N$"> The last line of the block contains just 0.</p>
<p>The last block consists of just one line containing 0.</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>The output file contains the lines corresponding to the lines with permutations in the input file. A line of the output file contains Yes if it is possible to marshal the coaches in the order required on the corresponding line of the input file. Otherwise it contains No . In addition, there is one empty line after the lines corresponding to one block of the input file. There is no line in the output file corresponding to the last &#96;&#96;null’’ block of the input file.</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>5 1 2 3 4 5 5 4 1 2 3 0 6 6 5 4 3 2 1 0 0</p>
<h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><p>Yes No Yes</p>
<h1 id="-5"><a href="#-5" class="headerlink" title=""></a></h1><hr>
<p>There is a famous railway station in PopPush City. Country there is incredibly hilly. The station was built in last century. Unfortunately, funds were extremely limited that time. It was possible to establish only a surface track. Moreover, it turned out that the station could be only a dead-end one (see picture) and due to lack of available space it could have only one track.</p>
<p><img src="/../images/dge.org-external-5-p514.gif.png" alt="\begin{picture}(6774,3429)(0,-10)\put(1789.500,1357.500){\arc{3645.278}{4.7247}......tFigFont{14}{16.8}{\rmdefault}{\mddefault}{\updefault}Station}}}}}\end{picture}"></p>
<p>The local tradition is that every train arriving from the direction A continues in the direction B with coaches reorganized in some way. Assume that the train arriving from the direction A has<img src="/../images/dge.org-external-5-514img2.gif.png" alt="$N \leŸ 1000$"> coaches numbered in increasing order <img src="/../images/dge.org-external-5-514img3.gif.png" alt="$1, 2, \dots, N$">. The chief for train reorganizations must know whether it is possible to marshal coaches continuing in the direction B so that their order will be <img src="/../images/dge.org-external-5-514img4.gif.png" alt="$a_1. a_2, \dots, a_N$">. Help him and write a program that decides whether it is possible to get the required order of coaches. You can assume that single coaches can be disconnected from the train before they enter the station and that they can move themselves until they are on the track in the direction B. You can also suppose that at any time there can be located as many coaches as necessary in the station. But once a coach has entered the station it cannot return to the track in the direction A and also once it has left the station in the direction B it cannot return back to the station.</p>
<h2 id="-6"><a href="#-6" class="headerlink" title=""></a></h2><p>The input file consists of blocks of lines. Each block except the last describes one train and possibly more requirements for its reorganization. In the first line of the block there is the integer N described above. In each of the next lines of the block there is a permutation of <img src="/../images/dge.org-external-5-514img3.gif.png" alt="$1, 2, \dots, N$"> The last line of the block contains just 0.</p>
<p>The last block consists of just one line containing 0.</p>
<h2 id="-7"><a href="#-7" class="headerlink" title=""></a></h2><p>The output file contains the lines corresponding to the lines with permutations in the input file. A line of the output file contains Yes if it is possible to marshal the coaches in the order required on the corresponding line of the input file. Otherwise it contains No . In addition, there is one empty line after the lines corresponding to one block of the input file. There is no line in the output file corresponding to the last &#96;&#96;null’’ block of the input file.</p>
<h2 id="-8"><a href="#-8" class="headerlink" title=""></a></h2><p>5 1 2 3 4 5 5 4 1 2 3 0 6 6 5 4 3 2 1 0 0</p>
<h2 id="-9"><a href="#-9" class="headerlink" title=""></a></h2><p>Yes No Yes</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 514 Rails(模拟栈)</title>
    <url>/posts/oj/ds/UVa%20514%20Rails(%E6%A8%A1%E6%8B%9F%E6%A0%88)/</url>
    <content><![CDATA[<p>题意 n辆火车按顺序依次进站 判断给定的出战顺序是否可能</p>
<p>用数组模拟模拟栈代表车站 车依次进站 每当栈顶火车序号与当前要出站的b[cur] 相等时 就让栈顶元素出栈 即top–</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">2000</span>;</span><br><span class="line">int b[N], c[N];</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int l, cur, top;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;l), l)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[<span class="number">1</span>]), b[<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(int i = <span class="number">2</span>; i &lt;= l; ++i)</span><br><span class="line">                <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">            cur = <span class="number">1</span>, top = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= l; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == b[cur]) cur++;</span><br><span class="line">                <span class="keyword">else</span> c[++top] = i;</span><br><span class="line">                <span class="keyword">while</span>(top &amp;&amp; b[cur] == c[top])</span><br><span class="line">                &#123;</span><br><span class="line">                    ++cur;</span><br><span class="line">                    --top;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;%s\n&quot;</span>, top ? <span class="string">&quot;No&quot;</span> : <span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p>There is a famous railway station in PopPush City. Country there is incredibly hilly. The station was built in last century. Unfortunately, funds were extremely limited that time. It was possible to establish only a surface track. Moreover, it turned out that the station could be only a dead-end one (see picture) and due to lack of available space it could have only one track.</p>
<p><img src="/../images/dge.org-external-5-p514.gif.png" alt="\begin{picture}(6774,3429)(0,-10)\put(1789.500,1357.500){\arc{3645.278}{4.7247}......tFigFont{14}{16.8}{\rmdefault}{\mddefault}{\updefault}Station}}}}}\end{picture}"></p>
<p>The local tradition is that every train arriving from the direction A continues in the direction B with coaches reorganized in some way. Assume that the train arriving from the direction A has<img src="/../images/dge.org-external-5-514img2.gif.png" alt="$N \leŸ 1000$"> coaches numbered in increasing order <img src="/../images/dge.org-external-5-514img3.gif.png" alt="$1, 2, \dots, N$">. The chief for train reorganizations must know whether it is possible to marshal coaches continuing in the direction B so that their order will be <img src="/../images/dge.org-external-5-514img4.gif.png" alt="$a_1. a_2, \dots, a_N$">. Help him and write a program that decides whether it is possible to get the required order of coaches. You can assume that single coaches can be disconnected from the train before they enter the station and that they can move themselves until they are on the track in the direction B. You can also suppose that at any time there can be located as many coaches as necessary in the station. But once a coach has entered the station it cannot return to the track in the direction A and also once it has left the station in the direction B it cannot return back to the station.</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>The input file consists of blocks of lines. Each block except the last describes one train and possibly more requirements for its reorganization. In the first line of the block there is the integer N described above. In each of the next lines of the block there is a permutation of  <img src="/../images/dge.org-external-5-514img3.gif.png" alt="$1, 2, \dots, N$"> The last line of the block contains just 0.</p>
<p>The last block consists of just one line containing 0.</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>The output file contains the lines corresponding to the lines with permutations in the input file. A line of the output file contains Yes if it is possible to marshal the coaches in the order required on the corresponding line of the input file. Otherwise it contains No . In addition, there is one empty line after the lines corresponding to one block of the input file. There is no line in the output file corresponding to the last &#96;&#96;null’’ block of the input file.</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>5 1 2 3 4 5 5 4 1 2 3 0 6 6 5 4 3 2 1 0 0</p>
<h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><p>Yes No Yes</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 536 Tree Recovery(先序,中序求后序)</title>
    <url>/posts/oj/ds/UVa%20536%20Tree%20Recovery(%E5%85%88%E5%BA%8F,%E4%B8%AD%E5%BA%8F%E6%B1%82%E5%90%8E%E5%BA%8F)/</url>
    <content><![CDATA[<p>题意 给你二叉树的先序序列和中序序列 求它的后序序列</p>
<p>先序序列的第一个一定是根 中序序列根左边的都属于根的左子树 右边的都属于右子树 递归建树就行了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef struct <span class="title class_">TNode</span></span><br><span class="line">&#123;</span><br><span class="line">    char data;</span><br><span class="line">    <span class="title class_">TNode</span> *lc, *rc;</span><br><span class="line">&#125; node, *<span class="title class_">BTree</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">build</span>(<span class="params">BTree &amp;t, string pre, string <span class="keyword">in</span></span>)</span><br><span class="line">&#123;</span><br><span class="line">    t = <span class="keyword">new</span> node;</span><br><span class="line">    t-&gt;lc = t-&gt;rc = <span class="variable constant_">NULL</span>, t-&gt;data = pre[<span class="number">0</span>];</span><br><span class="line">    int k = <span class="keyword">in</span>.<span class="title function_">find</span>(pre[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(k &gt; <span class="number">0</span>) <span class="title function_">build</span>(t-&gt;lc, pre.<span class="title function_">substr</span>(<span class="number">1</span>, k), <span class="keyword">in</span>.<span class="title function_">substr</span>(<span class="number">0</span>, k));</span><br><span class="line">    <span class="keyword">if</span>(k &lt; <span class="keyword">in</span>.<span class="title function_">size</span>() - <span class="number">1</span>) <span class="title function_">build</span>(t-&gt;rc, pre.<span class="title function_">substr</span>(k + <span class="number">1</span>), <span class="keyword">in</span>.<span class="title function_">substr</span>(k + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">postTral</span>(<span class="params">BTree &amp;t</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!t) <span class="keyword">return</span>;</span><br><span class="line">    <span class="title function_">postTral</span>(t-&gt;lc);</span><br><span class="line">    <span class="title function_">postTral</span>(t-&gt;rc);</span><br><span class="line">    <span class="title function_">putchar</span>(t-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    string pre, <span class="keyword">in</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; pre &gt;&gt; <span class="keyword">in</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title class_">BTree</span> t;</span><br><span class="line">        <span class="title function_">build</span>(t, pre, <span class="keyword">in</span>);</span><br><span class="line">        <span class="title function_">postTral</span>(t);</span><br><span class="line">        <span class="title function_">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p>Little Valentine liked playing with binary trees very much. Her favorite game was constructing randomly looking binary trees with capital letters in the nodes.</p>
<p>This is an example of one of her creations:</p>
<p>D &#x2F; \ &#x2F; \ B E &#x2F; \ \ &#x2F; \ \ A C G &#x2F; &#x2F; F</p>
<p>To record her trees for future generations, she wrote down two strings for each tree: a preorder traversal (root, left subtree, right subtree) and an inorder traversal (left subtree, root, right subtree).</p>
<p>For the tree drawn above the preorder traversal is DBACEGF and the inorder traversal is ABCDEFG.</p>
<p>She thought that such a pair of strings would give enough information to reconstruct the tree later (but she never tried it).</p>
<p>Now, years later, looking again at the strings, she realized that reconstructing the trees was indeed possible, but only because she never had used the same letter twice in the same tree.</p>
<p>However, doing the reconstruction by hand, soon turned out to be tedious.</p>
<p>So now she asks you to write a program that does the job for her!</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>The input file will contain one or more test cases. Each test case consists of one line containing two strings preord and inord, representing the preorder traversal and inorder traversal of a binary tree. Both strings consist of unique capital letters. (Thus they are not longer than 26 characters.)</p>
<p>Input is terminated by end of file.</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>For each test case, recover Valentine’s binary tree and print one line containing the tree’s postorder traversal (left subtree, right subtree, root).</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>DBACEGF ABCDEFG BCAD CBAD</p>
<h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><p>ACBFGED CDAB</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 540 Team Queue（团队队列）</title>
    <url>/posts/oj/ds/UVa%20540%20Team%20Queue%EF%BC%88%E5%9B%A2%E9%98%9F%E9%98%9F%E5%88%97%EF%BC%89/</url>
    <content><![CDATA[<p>题意 模拟团队队列的入队和出队</p>
<p>STL应用 用一个队列维护团队编号 再用一个队列数组维护个体</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1000005</span>;</span><br><span class="line">int team[N];</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas = <span class="number">0</span>, n, t, a;</span><br><span class="line">    char cmd[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t), t)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;Scenario #%d\n&quot;</span>, ++cas);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; t; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">            <span class="keyword">while</span>(n--)</span><br><span class="line">                <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a), team[a] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;int&gt; q, qt[<span class="number">1005</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, cmd), cmd[<span class="number">0</span>] != <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cmd[<span class="number">0</span>] == <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">                t = team[a];</span><br><span class="line">                <span class="keyword">if</span>(qt[t].<span class="title function_">empty</span>()) q.<span class="title function_">push</span>(t);</span><br><span class="line">                qt[t].<span class="title function_">push</span>(a);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                t = q.<span class="title function_">front</span>();</span><br><span class="line">                <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, qt[t].<span class="title function_">front</span>()), qt[t].<span class="title function_">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(qt[t].<span class="title function_">empty</span>()) q.<span class="title function_">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p><em>Queues</em> and <em>Priority Queues</em> are data structures which are known to most computer scientists. The<em>Team Queue</em>, however, is not so well known, though it occurs often in everyday life. At lunch time the queue in front of the Mensa is a team queue, for example.</p>
<p>In a team queue each element belongs to a team. If an element enters the queue, it first searches the queue from head to tail to check if some of its <em>teammates</em> (elements of the same team) are already in the queue. If yes, it enters the queue right behind them. If not, it enters the queue at the tail and becomes the new last element (bad luck). Dequeuing is done like in normal queues: elements are processed from head to tail in the order they appear in the team queue.</p>
<p>Your task is to write a program that simulates such a team queue.</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>The input file will contain one or more test cases. Each test case begins with the number of teams t (  <img src="/../images/dge.org-external-5-540img1.gif.png" alt="$1 \le t \le 1000$"> ). Then t team descriptions follow, each one consisting of the number of elements belonging to the team and the elements themselves. Elements are integers in the range 0 - 999999. A team may consist of up to 1000 elements.</p>
<p>Finally, a list of commands follows. There are three different kinds of commands:</p>
<p>The input will be terminated by a value of 0 for t.</p>
<p><strong>Warning:</strong> A test case may contain up to 200000 (two hundred thousand) commands, so the implementation of the team queue should be efficient: both enqueing and dequeuing of an element should only take constant time.</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>For each test case, first print a line saying &#96;&#96; Scenario &#x2F;# k “, where k is the number of the test case. Then, for each DEQUEUE command, print the element which is dequeued on a single line. Print a blank line after each test case, even after the last one.</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>2 3 101 102 103 3 201 202 203 ENQUEUE 101 ENQUEUE 201 ENQUEUE 102 ENQUEUE 202 ENQUEUE 103 ENQUEUE 203 DEQUEUE DEQUEUE DEQUEUE DEQUEUE DEQUEUE DEQUEUE STOP 2 5 259001 259002 259003 259004 259005 6 260001 260002 260003 260004 260005 260006 ENQUEUE 259001 ENQUEUE 260001 ENQUEUE 259002 ENQUEUE 259003 ENQUEUE 259004 ENQUEUE 259005 DEQUEUE DEQUEUE ENQUEUE 260002 ENQUEUE 260003 DEQUEUE DEQUEUE DEQUEUE DEQUEUE STOP 0</p>
<h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><p>Scenario &#x2F;#1 101 102 103 201 202 203 Scenario &#x2F;#2 259001 259002 259003 259004 259005 260001</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 548 Tree(建树,递归遍历)</title>
    <url>/posts/oj/ds/UVa%20548%20Tree(%E5%BB%BA%E6%A0%91,%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86)/</url>
    <content><![CDATA[<p>题意 给你一个树的中序遍历和后序遍历 某个节点的权值为从根节点到该节点所经过节点的和 求权值最小的叶节点的值 如果存在多个 输出值最小的那个</p>
<p>把树建好就好说了 递归递归dfs msun保存最小叶节点权值 ans保存答案</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int maxn = <span class="number">10005</span>, <span class="variable constant_">INF</span> = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">int <span class="keyword">in</span>[maxn], post[maxn], msum, ans;</span><br><span class="line"></span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int val;</span><br><span class="line">    node *left, *right;</span><br><span class="line">    <span class="title function_">node</span>(): <span class="title function_">left</span>(<span class="variable constant_">NULL</span>), <span class="title function_">right</span>(<span class="params">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">node* <span class="title function_">build</span>(<span class="params">int le, int ri, int pos</span>)</span><br><span class="line">&#123;</span><br><span class="line">    node *cur = <span class="keyword">new</span> node;</span><br><span class="line">    cur-&gt;val = post[pos];</span><br><span class="line">    <span class="keyword">if</span>(le == ri) <span class="keyword">return</span> cur;</span><br><span class="line">    int i = le;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">in</span>[i] != post[pos]) ++i;</span><br><span class="line">    <span class="keyword">if</span>(i == le) cur-&gt;left = <span class="variable constant_">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>  cur-&gt;left = <span class="title function_">build</span>(le, i - <span class="number">1</span>, pos - <span class="number">1</span> - (ri - i));</span><br><span class="line">    <span class="keyword">if</span>(i == ri) cur-&gt;right = <span class="variable constant_">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> cur-&gt;right = <span class="title function_">build</span>(i + <span class="number">1</span>, ri, pos - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span>(<span class="params">node *cur, int sum</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int t = cur-&gt;val;</span><br><span class="line">    <span class="keyword">if</span>(!(cur-&gt;left || cur-&gt;right))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum + t &lt; msum || (sum + t == msum &amp;&amp; t &lt; ans))</span><br><span class="line">            msum = sum + t, ans = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur-&gt;left != <span class="variable constant_">NULL</span>) <span class="title function_">dfs</span>(cur-&gt;left, sum + t);</span><br><span class="line">    <span class="keyword">if</span>(cur-&gt;right != <span class="variable constant_">NULL</span>) <span class="title function_">dfs</span>(cur-&gt;right, sum + t);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    char s[maxn*<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">gets</span>(s) != <span class="variable constant_">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        int t = <span class="number">0</span>, l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; s[i] != <span class="string">&#x27;\0&#x27;</span>; ++i)</span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_">isdigit</span>(s[i])) t = t * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span>  <span class="keyword">in</span>[++l] = t, t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">in</span>[++l] = t;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">gets</span>(s);</span><br><span class="line">        l = t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; s[i] != <span class="string">&#x27;\0&#x27;</span>; ++i)</span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_">isdigit</span>(s[i])) t = t * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> post[++l] = t, t = <span class="number">0</span>;</span><br><span class="line">        post[++l] = t;</span><br><span class="line"></span><br><span class="line">        node *root = <span class="title function_">build</span>(<span class="number">1</span>, l, l);</span><br><span class="line">        ans = msum = <span class="variable constant_">INF</span>;</span><br><span class="line">        <span class="title function_">dfs</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p>You are to determine the value of the leaf node in a given binary tree that is the terminal node of a path of least value from the root of the binary tree to any leaf. The value of a path is the sum of values of nodes along that path.</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>The input file will contain a description of the binary tree given as the inorder and postorder traversal sequences of that tree. Your program will read two line (until end of file) from the input file. The first line will contain the sequence of values associated with an inorder traversal of the tree and the second line will contain the sequence of values associated with a postorder traversal of the tree. All values will be different, greater than zero and less than 10000. You may assume that no binary tree will have more than 10000 nodes or less than 1 node.</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>For each tree description you should output the value of the leaf node of a path of least value. In the case of multiple paths of least value you should pick the one with the least value on the terminal node.</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>3 2 1 4 5 7 6 3 1 2 5 6 7 4 7 8 11 3 5 16 12 18 8 3 11 7 16 18 12 5 255 255</p>
<h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><p>1 3 255</p>
<h1 id="-5"><a href="#-5" class="headerlink" title=""></a></h1><hr>
<p>You are to determine the value of the leaf node in a given binary tree that is the terminal node of a path of least value from the root of the binary tree to any leaf. The value of a path is the sum of values of nodes along that path.</p>
<h2 id="-6"><a href="#-6" class="headerlink" title=""></a></h2><p>The input file will contain a description of the binary tree given as the inorder and postorder traversal sequences of that tree. Your program will read two line (until end of file) from the input file. The first line will contain the sequence of values associated with an inorder traversal of the tree and the second line will contain the sequence of values associated with a postorder traversal of the tree. All values will be different, greater than zero and less than 10000. You may assume that no binary tree will have more than 10000 nodes or less than 1 node.</p>
<h2 id="-7"><a href="#-7" class="headerlink" title=""></a></h2><p>For each tree description you should output the value of the leaf node of a path of least value. In the case of multiple paths of least value you should pick the one with the least value on the terminal node.</p>
<h2 id="-8"><a href="#-8" class="headerlink" title=""></a></h2><p>3 2 1 4 5 7 6 3 1 2 5 6 7 4 7 8 11 3 5 16 12 18 8 3 11 7 16 18 12 5 255 255</p>
<h2 id="-9"><a href="#-9" class="headerlink" title=""></a></h2><p>1 3 255</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 572 Oil Deposits(DFS求8连通块)</title>
    <url>/posts/oj/ds/UVa%20572%20Oil%20Deposits(DFS%E6%B1%828%E8%BF%9E%E9%80%9A%E5%9D%97)/</url>
    <content><![CDATA[<p>题意 求n&#x2F;*m矩阵中‘@’连通块的个数 两个‘@’在一个九宫格内就属于一个连通块</p>
<p>最基础的DFS 遇到@就递归扫描周围8个并标记当前格子已访问 然后就得到答案了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">110</span>;</span><br><span class="line">char mat[N][N];</span><br><span class="line"></span><br><span class="line">int <span class="title function_">dfs</span>(<span class="params">int r, int c</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(mat[r][c] != <span class="string">&#x27;@&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mat[r][c] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = -<span class="number">1</span>; i &lt;= <span class="number">1</span>; ++i)</span><br><span class="line">            <span class="keyword">for</span>(int j = -<span class="number">1</span>; j &lt;= <span class="number">1</span>; ++j)</span><br><span class="line">                <span class="keyword">if</span>(mat[r + i][c + j] == <span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">                    <span class="title function_">dfs</span>(r + i, c + j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m) , m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, mat[i] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        int ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">                ans += <span class="title function_">dfs</span>(i, j);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p>The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil.</p>
<p>A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid.</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>The input file contains one or more grids. Each grid begins with a line containing m and n , the number of rows and columns in the grid, separated by a single space. If m &#x3D; 0 it signals the end of the input; otherwise  <img src="/../images/dge.org-external-5-572img1.gif.png" alt="$1 \le m \le 100$"> and  <img src="/../images/dge.org-external-5-572img2.gif.png" alt="$1 \le n \le 100$"> . Following this are m lines of n characters each (not counting the end-of-line characters). Each character corresponds to one plot, and is either <code>/* &#39;, representing the absence of oil, or</code> @ ‘, representing an oil pocket.</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>For each grid, output the number of distinct oil deposits. Two different pockets are part of the same oil deposit if they are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets.</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>1 1 &#x2F;* 3 5 &#x2F;<em>@&#x2F;</em>@&#x2F;* &#x2F;<em>&#x2F;</em>@&#x2F;<em>&#x2F;</em> &#x2F;<em>@&#x2F;</em>@&#x2F;* 1 8 @@&#x2F;<em>&#x2F;</em>&#x2F;<em>&#x2F;</em>@&#x2F;* 5 5 &#x2F;<em>&#x2F;</em>&#x2F;<em>&#x2F;</em>@ &#x2F;<em>@@&#x2F;</em>@ &#x2F;<em>@&#x2F;</em>&#x2F;<em>@ @@@&#x2F;</em>@ @@&#x2F;<em>&#x2F;</em>@ 0 0</p>
<h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><p>0 1 2 2</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 673 Parentheses Balance(括号配对 栈)</title>
    <url>/posts/oj/ds/UVa%20673%20Parentheses%20Balance(%E6%8B%AC%E5%8F%B7%E9%85%8D%E5%AF%B9%20%E6%A0%88)/</url>
    <content><![CDATA[<p>题意 判断输入的括号序列是否是配对的</p>
<p>栈的基础应用 栈顶元素与输入的字符匹配就出栈咯 注意括号序列可以为空</p>
<p>STL栈</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas;</span><br><span class="line">    char c;</span><br><span class="line">    cin &gt;&gt; cas;</span><br><span class="line">    <span class="title function_">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        stack&lt;char&gt; s;</span><br><span class="line">        <span class="keyword">while</span>((c = <span class="title function_">getchar</span>()) != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="title function_">empty</span>()) s.<span class="title function_">push</span>(c);</span><br><span class="line">            <span class="keyword">else</span>  <span class="keyword">if</span>((c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; s.<span class="title function_">top</span>() == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                     || (c == <span class="string">&#x27;]&#x27;</span> &amp;&amp; s.<span class="title function_">top</span>() == <span class="string">&#x27;[&#x27;</span>))</span><br><span class="line">                s.<span class="title function_">pop</span>();</span><br><span class="line">            <span class="keyword">else</span> s.<span class="title function_">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">puts</span>(s.<span class="title function_">empty</span>() ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组模拟栈</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas, top;</span><br><span class="line">    char s[<span class="number">200</span>], c;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="title function_">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((c = <span class="title function_">getchar</span>()) != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(top == <span class="number">0</span>) s[top++] = c;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[top - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span> &amp;&amp; c == <span class="string">&#x27;)&#x27;</span></span><br><span class="line">                    || s[top - <span class="number">1</span>] == <span class="string">&#x27;[&#x27;</span> &amp;&amp; c == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">                --top;</span><br><span class="line">            <span class="keyword">else</span> s[top++] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">puts</span>(top ? <span class="string">&quot;No&quot;</span> : <span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p>You are given a string consisting of parentheses () and []. A string of this type is said to be<em>correct</em>:<br>(a) if it is the empty string (b) if A and B are correct, AB is correct, (c) if A is correct, (A ) and [A ] is correct.</p>
<p>Write a program that takes a sequence of strings of this type and check their correctness. Your program can assume that the maximum string length is 128.</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>The file contains a positive integer n and a sequence of n strings of parentheses () and [] , one string a line.</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>A sequence of Yes or No on the output file.</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>3 ([]) (([()]))) ([()<a href=""></a>])()</p>
<h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><p>Yes No Yes</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 679 Dropping Balls</title>
    <url>/posts/oj/ds/UVa%20679%20Dropping%20Balls/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p>A number of <em>K</em> balls are dropped one by one from the root of a fully binary tree structure FBT. Each time the ball being dropped first visits a non-terminal node. It then keeps moving down, either follows the path of the left subtree, or follows the path of the right subtree, until it stops at one of the leaf nodes of FBT. To determine a ball’s moving direction a flag is set up in every non-terminal node with two values, either <strong>false</strong> or <strong>true</strong>. Initially, all of the flags are <strong>false</strong>. When visiting a non-terminal node if the flag’s current value at this node is<strong>false</strong>, then the ball will first switch this flag’s value, i.e., from the <strong>false</strong> to the <strong>true</strong>, and then follow the left subtree of this node to keep moving down. Otherwise, it will also switch this flag’s value, i.e., from the <strong>true</strong> to the <strong>false</strong>, but will follow the right subtree of this node to keep moving down. Furthermore, all nodes of FBT are sequentially numbered, starting at 1 with nodes on depth 1, and then those on depth 2, and so on. Nodes on any depth are numbered from left to right.</p>
<p>For example, Fig. 1 represents a fully binary tree of maximum depth 4 with the node numbers 1, 2, 3, …, 15. Since all of the flags are initially set to be <strong>false</strong>, the first ball being dropped will switch flag’s values at node 1, node 2, and node 4 before it finally stops at position 8. The second ball being dropped will switch flag’s values at node 1, node 3, and node 6, and stop at position 12. Obviously, the third ball being dropped will switch flag’s values at node 1, node 2, and node 5 before it stops at position 10.</p>
<p><img src="/../images/dge.org-external-6-p679.gif.png"></p>
<p>Fig. 1: An example of FBT with the maximum depth 4 and sequential node numbers.</p>
<p>Now consider a number of test cases where two values will be given for each test. The first value is <em>D</em>, the maximum depth of FBT, and the second one is <em>I</em>, the <em>I**th</em> ball being dropped. You may assume the value of <em>I</em> will not exceed the total number of leaf nodes for the given FBT.</p>
<p>Please write a program to determine the stop position <em>P</em> for each test case.</p>
<p>For each test cases the range of two parameters <em>D</em> and <em>I</em> is as below:</p>
<p><img src="/../images/dge.org-external-6-679img1.gif.png" alt="\begin{displaymath}2 \le D \le 20, \mbox{ and } 1 \le I \le 524288.\end{displaymath}"></p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>Contains l +2 lines. Line 1 <em>I</em> the number of test cases Line 2 test case &#x2F;#1, two decimal numbers that are separatedby one blank … Line <em>k</em>+1 test case &#x2F;#<em>k</em> Line <em>l</em>+1 test case &#x2F;#<em>l</em> Line <em>l</em>+2 -1 a constant -1 representing the end of the input file</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>Contains l lines. Line 1 the stop position <em>P</em> for the test case &#x2F;#1 … Line <em>k</em> the stop position <em>P</em> for the test case &#x2F;#<em>k</em> … Line <em>l</em> the stop position <em>P</em> for the test case &#x2F;#<em>l</em></p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>5 4 2 3 4 10 1 2 2 8 128 -1</p>
<h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><p>12 7 512 3 255</p>
<p>题意 i个小球在一棵二叉树上下落 第奇数个到达某个节点就往左 否则往右 求最后一个小球下落到最底层所在结点的序号</p>
<p>对于第i个小球 在根结点处 若i是奇数 则它是往左的第(i+1)&#x2F;2个小球 若i是偶数 则它是往右的第n&#x2F;2个小球</p>
<p>而对于一个结点k 它的左子结点序号为2&#x2F;*k 右子节点序号为2&#x2F;*k+1 每次更新i到到最底层就得出结果了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas, ans, d, i;</span><br><span class="line">    <span class="keyword">while</span> (scanf (<span class="string">&quot;%d&quot;</span>, &amp;cas), cas + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (cas--)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="number">1</span>;</span><br><span class="line">            scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;d, &amp;i);</span><br><span class="line">            <span class="keyword">while</span> (--d)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">2</span>)</span><br><span class="line">                    ans = ans * <span class="number">2</span>, i = (i + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ans = ans * <span class="number">2</span> + <span class="number">1</span>, i = i / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            printf (<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 699 The Falling Leaves(递归建树)</title>
    <url>/posts/oj/ds/UVa%20699%20The%20Falling%20Leaves(%E9%80%92%E5%BD%92%E5%BB%BA%E6%A0%91)/</url>
    <content><![CDATA[<p>题意 假设一棵二叉树也会落叶 而且叶子只会垂直下落 每个节点保存的值为那个节点上的叶子数 求所有叶子全部下落后 地面从左到右每堆有多少片叶子</p>
<p>和上一题有点像 都是递归输入的 一个节点(设水平位置为p) 则它的左右儿子节点的水平位置分别为 p-1 p+1 也是可以边输入边处理的 输入完也就得到答案了 注意每个样例后面都有一个空行 包括最后一个</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int le, ri;</span><br><span class="line"><span class="keyword">const</span> int M = <span class="number">205</span>;</span><br><span class="line">int a[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">build</span>(<span class="params">int p</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">if</span>(t == -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        a[p] += t;</span><br><span class="line">        <span class="title function_">build</span>(p - <span class="number">1</span>);</span><br><span class="line">        <span class="title function_">build</span>(p + <span class="number">1</span>);</span><br><span class="line">        le = le &lt; p ? le : p;</span><br><span class="line">        ri = ri &gt; p ? ri : p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas = <span class="number">0</span>;</span><br><span class="line">    le = M, ri = <span class="number">0</span>;</span><br><span class="line">    <span class="title function_">build</span>(M / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(le &lt;= ri)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;Case %d:\n&quot;</span>, ++cas);</span><br><span class="line">        <span class="keyword">for</span>(int i = le; i &lt; ri; ++i)</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n\n&quot;</span>, a[ri]);</span><br><span class="line"></span><br><span class="line">        <span class="title function_">memset</span>(a, <span class="number">0</span>, <span class="title function_">sizeof</span>(a));</span><br><span class="line">        le = M, ri = <span class="number">0</span>;</span><br><span class="line">        <span class="title function_">build</span>(M / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p>Each year, fall in the North Central region is accompanied by the brilliant colors of the leaves on the trees, followed quickly by the falling leaves accumulating under the trees. If the same thing happened to binary trees, how large would the piles of leaves become?</p>
<p>We assume each node in a binary tree “drops” a number of leaves equal to the integer value stored in that node. We also assume that these leaves drop vertically to the ground (thankfully, there’s no wind to blow them around). Finally, we assume that the nodes are positioned horizontally in such a manner that the left and right children of a node are exactly one unit to the left and one unit to the right, respectively, of their parent. Consider the following tree:</p>
<p><img src="/../images/dge.org-external-6-p699.gif.png"></p>
<p>The nodes containing 5 and 6 have the same horizontal position (with different vertical positions, of course). The node containing 7 is one unit to the left of those containing 5 and 6, and the node containing 3 is one unit to their right. When the “leaves” drop from these nodes, three piles are created: the leftmost one contains 7 leaves (from the leftmost node), the next contains 11 (from the nodes containing 5 and 6), and the rightmost pile contains 3. (While it is true that only leaf nodes in a tree would logically have leaves, we ignore that in this problem.)</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>The input contains multiple test cases, each describing a single tree. A tree is specified by giving the value in the root node, followed by the description of the left subtree, and then the description of the right subtree. If a subtree is empty, the value -1 is supplied. Thus the tree shown above is specified as 5 7 -1 6 -1 -1 3 -1 -1 . Each actual tree node contains a positive, non-zero value. The last test case is followed by a single -1 (which would otherwise represent an empty tree).</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>For each test case, display the case number (they are numbered sequentially, starting with 1) on a line by itself. On the next line display the number of “leaves” in each pile, from left to right, with a single space separating each value. This display must start in column 1, and will not exceed the width of an 80-character line. Follow the output for each case by a blank line. This format is illustrated in the examples below.</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>5 7 -1 6 -1 -1 3 -1 -1 8 2 9 -1 -1 6 5 -1 -1 12 -1 -1 3 7 -1 -1 -1 -1</p>
<h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><p>Case 1: 7 11 3 Case 2: 9 7 21 15</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 839 Not so Mobile(树的递归输入)</title>
    <url>/posts/oj/ds/UVa%20839%20Not%20so%20Mobile(%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E8%BE%93%E5%85%A5)/</url>
    <content><![CDATA[<p>题意 判断一个树状天平是否平衡 每个测试样例每行4个数 wl,dl,wr,dr 当wl&#x2F;*dl&#x3D;wr&#x2F;*dr时 视为这个天平平衡 当wl或wr等于0是 下一行将是一个子天平 如果子天平平衡 wl为子天平的wl+wr 否则整个天平不平衡</p>
<p>容易看出 输入是递归的 所以我们可以直接递归 边输入边判断</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool <span class="title function_">solve</span>(<span class="params">int &amp;w</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int wl, dl, wr, dr;</span><br><span class="line">    bool mobl = <span class="literal">true</span>, mobr = <span class="literal">true</span>;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;wl, &amp;dl, &amp;wr, &amp;dr);</span><br><span class="line">    <span class="keyword">if</span>(!wl) mobl = <span class="title function_">solve</span>(wl);</span><br><span class="line">    <span class="keyword">if</span>(!wr) mobr = <span class="title function_">solve</span>(wr);</span><br><span class="line">    w = wl + wr;</span><br><span class="line">    <span class="keyword">return</span> mobl &amp;&amp; mobr &amp;&amp; (wl * dl == wr * dr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas, w;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span>(cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="title function_">solve</span>(w) ? <span class="string">&quot;YES\n&quot;</span> : <span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(cas) <span class="title function_">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p>Before being an ubiquous communications gadget, a <em>mobile</em> was just a structure made of strings and wires suspending colourfull things. This kind of mobile is usually found hanging over cradles of small babies.</p>
<p><img src="/../images/dge.org-external-8-p839a.jpg.png" alt="\epsfbox{p839a.eps}"></p>
<p>The figure illustrates a simple mobile. It is just a wire, suspended by a string, with an object on each side. It can also be seen as a kind of lever with the fulcrum on the point where the string ties the wire. From the lever principle we know that to balance a simple mobile the product of the weight of the objects by their distance to the fulcrum must be equal. That is <strong>W</strong>l×<strong>D</strong>l &#x3D; <strong>W</strong>r×<strong>D</strong>rwhere <strong>D</strong>l is the left distance, <strong>D</strong>r is the right distance, <strong>W</strong>l is the left weight and <strong>W</strong>r is the right weight.</p>
<p>In a more complex mobile the object may be replaced by a sub-mobile, as shown in the next figure. In this case it is not so straightforward to check if the mobile is balanced so we need you to write a program that, given a description of a mobile as input, checks whether the mobile is in equilibrium or not.</p>
<p><img src="/../images/dge.org-external-8-p839b.jpg.png" alt="\epsfbox{p839b.eps}"></p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>The input begins with a single positive integer on a line by itself indicating the number of the cases following, each of them as described below. This line is followed by a blank line, and there is also a blank line between two consecutive inputs.</p>
<p>The input is composed of several lines, each containing 4 integers separated by a single space. The 4 integers represent the distances of each object to the fulcrum and their weights, in the format: <strong>W</strong>l <strong>D</strong>l <strong>W</strong>r <strong>D</strong>r</p>
<p>If <strong>W</strong>l or <strong>W</strong>r is zero then there is a sub-mobile hanging from that end and the following lines define the the sub-mobile. In this case we compute the weight of the sub-mobile as the sum of weights of all its objects, disregarding the weight of the wires and strings. If both <strong>W</strong>l and <strong>W</strong>rare zero then the following lines define two sub-mobiles: first the left then the right one.</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>For each test case, the output must follow the description below. The outputs of two consecutive cases will be separated by a blank line.</p>
<p>Write <code>YES&#39; if the mobile is in equilibrium, write </code>NO’ otherwise.</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>1 0 2 0 4 0 3 0 1 1 1 1 1 2 4 4 2 1 6 3 2</p>
<h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><p>YES<br>#</p>
<hr>
<p>Before being an ubiquous communications gadget, a <em>mobile</em> was just a structure made of strings and wires suspending colourfull things. This kind of mobile is usually found hanging over cradles of small babies.</p>
<p><img src="/../images/dge.org-external-8-p839a.jpg.png" alt="\epsfbox{p839a.eps}"></p>
<p>The figure illustrates a simple mobile. It is just a wire, suspended by a string, with an object on each side. It can also be seen as a kind of lever with the fulcrum on the point where the string ties the wire. From the lever principle we know that to balance a simple mobile the product of the weight of the objects by their distance to the fulcrum must be equal. That is <strong>W</strong>l×<strong>D</strong>l &#x3D; <strong>W</strong>r×<strong>D</strong>rwhere <strong>D</strong>l is the left distance, <strong>D</strong>r is the right distance, <strong>W</strong>l is the left weight and <strong>W</strong>r is the right weight.</p>
<p>In a more complex mobile the object may be replaced by a sub-mobile, as shown in the next figure. In this case it is not so straightforward to check if the mobile is balanced so we need you to write a program that, given a description of a mobile as input, checks whether the mobile is in equilibrium or not.</p>
<p><img src="/../images/dge.org-external-8-p839b.jpg.png" alt="\epsfbox{p839b.eps}"></p>
<h2 id="-5"><a href="#-5" class="headerlink" title=""></a></h2><p>The input begins with a single positive integer on a line by itself indicating the number of the cases following, each of them as described below. This line is followed by a blank line, and there is also a blank line between two consecutive inputs.</p>
<p>The input is composed of several lines, each containing 4 integers separated by a single space. The 4 integers represent the distances of each object to the fulcrum and their weights, in the format: <strong>W</strong>l <strong>D</strong>l <strong>W</strong>r <strong>D</strong>r</p>
<p>If <strong>W</strong>l or <strong>W</strong>r is zero then there is a sub-mobile hanging from that end and the following lines define the the sub-mobile. In this case we compute the weight of the sub-mobile as the sum of weights of all its objects, disregarding the weight of the wires and strings. If both <strong>W</strong>l and <strong>W</strong>rare zero then the following lines define two sub-mobiles: first the left then the right one.</p>
<h2 id="-6"><a href="#-6" class="headerlink" title=""></a></h2><p>For each test case, the output must follow the description below. The outputs of two consecutive cases will be separated by a blank line.</p>
<p>Write <code>YES&#39; if the mobile is in equilibrium, write </code>NO’ otherwise.</p>
<h2 id="-7"><a href="#-7" class="headerlink" title=""></a></h2><p>1 0 2 0 4 0 3 0 1 1 1 1 1 2 4 4 2 1 6 3 2</p>
<h2 id="-8"><a href="#-8" class="headerlink" title=""></a></h2><p>YES</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>XTU1238 Segment Tree (线段树·区间最值更新)</title>
    <url>/posts/oj/ds/XTU1238%20Segment%20Tree%20(%E7%BA%BF%E6%AE%B5%E6%A0%91%C2%B7%E5%8C%BA%E9%97%B4%E6%9C%80%E5%80%BC%E6%9B%B4%E6%96%B0)/</url>
    <content><![CDATA[<p>题意 对一个数组有四种操作</p>
<p>对每个操作4输出对应最小值和最大值</p>
<p>基础的线段树 在湘潭卡了好久没写出来<br>线段树维护三个值 区间最大值 maxv, 区间最小值minv, 区间增加的值add<br>操作1是很容易实现的 操作2和3比1要复杂些 初一想要对每个值单独进行操作 这样肯定会T的 毕竟那样用线段树就没意义了 后来发现每次更新时对应区间包含的所有最大区间节点的maxv 和 minv是可以确定的</p>
<p>然后知道了父区间的maxv,minv后 通过pashdown函数就可以在需要时再对子区间进行更新 因为子区间的所有值都是在父区间的minv和maxv之间 然后就看代码吧</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">#define lc p&lt;&lt;<span class="number">1</span>, s, mid</span><br><span class="line">#define rc p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, e</span><br><span class="line">#define mid ((s+e)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">200005</span>;</span><br><span class="line">int maxv[N * <span class="number">4</span>], minv[N * <span class="number">4</span>], add[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pushup</span>(<span class="params">int p</span>)</span><br><span class="line">&#123;</span><br><span class="line">    maxv[p] = <span class="title function_">max</span>(maxv[p &lt;&lt; <span class="number">1</span>], maxv[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">    minv[p] = <span class="title function_">min</span>(minv[p &lt;&lt; <span class="number">1</span>], minv[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pushdown</span>(<span class="params">int p</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int l = p &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    int r = p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(add[p])</span><br><span class="line">    &#123;</span><br><span class="line">        add[l] += add[p];</span><br><span class="line">        add[r] += add[p];</span><br><span class="line">        minv[l] += add[p];</span><br><span class="line">        minv[r] += add[p];</span><br><span class="line">        maxv[l] += add[p];</span><br><span class="line">        maxv[r] += add[p];</span><br><span class="line">        add[p] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子区间的所有值肯定都父区间的minv~maxv之间</span></span><br><span class="line">    minv[l] = <span class="title function_">max</span>(minv[l], minv[p]);</span><br><span class="line">    minv[l] = <span class="title function_">min</span>(minv[l], maxv[p]);</span><br><span class="line">    maxv[l] = <span class="title function_">max</span>(maxv[l], minv[p]);</span><br><span class="line">    maxv[l] = <span class="title function_">min</span>(maxv[l], maxv[p]);</span><br><span class="line"></span><br><span class="line">    minv[r] = <span class="title function_">max</span>(minv[r], minv[p]);</span><br><span class="line">    minv[r] = <span class="title function_">min</span>(minv[r], maxv[p]);</span><br><span class="line">    maxv[r] = <span class="title function_">max</span>(maxv[r], minv[p]);</span><br><span class="line">    maxv[r] = <span class="title function_">min</span>(maxv[r], maxv[p]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">build</span>(<span class="params">int p, int s, int e</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;maxv[p]);</span><br><span class="line">        minv[p] = maxv[p];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">build</span>(lc);</span><br><span class="line">    <span class="title function_">build</span>(rc);</span><br><span class="line">    <span class="title function_">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span>(<span class="params">int p, int s, int e, int l, int r, int v, int op</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s &gt;= l &amp;&amp; e &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>) <span class="comment">//将[l,r]区间的所有值都加上v</span></span><br><span class="line">        &#123;</span><br><span class="line">            add[p] += v;</span><br><span class="line">            minv[p] += v;</span><br><span class="line">            maxv[p] += v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>)  <span class="comment">//将[l,r]区间中所有大于v的值都改为v</span></span><br><span class="line">        &#123;</span><br><span class="line">            maxv[p] = <span class="title function_">min</span>(maxv[p], v);</span><br><span class="line">            minv[p] = <span class="title function_">min</span>(minv[p], v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">//op = 3  将[l,r]区间中的所有小于v的值都改为v</span></span><br><span class="line">        &#123;</span><br><span class="line">            maxv[p] = <span class="title function_">max</span>(v, maxv[p]);</span><br><span class="line">            minv[p] = <span class="title function_">max</span>(v, minv[p]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="title function_">update</span>(lc, l, r, v, op);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="title function_">update</span>(rc, l, r, v, op);</span><br><span class="line">    <span class="title function_">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">query</span>(<span class="params">int p, int s, int e, int l, int r, int op</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == l &amp;&amp; e == r)<span class="comment">//op = 0 时查询最小值  op = 1 时查询最大值</span></span><br><span class="line">        <span class="keyword">return</span> op ? maxv[p] : minv[p];</span><br><span class="line">    <span class="title function_">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= mid) <span class="keyword">return</span> <span class="title function_">query</span>(lc, l, r, op);</span><br><span class="line">    <span class="keyword">if</span>(l &gt; mid) <span class="keyword">return</span> <span class="title function_">query</span>(rc, l, r, op);</span><br><span class="line">    <span class="keyword">if</span>(op) <span class="keyword">return</span> <span class="title function_">max</span>(<span class="title function_">query</span>(lc, l, mid, op), <span class="title function_">query</span>(rc, mid + <span class="number">1</span>, r, op));</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">min</span>(<span class="title function_">query</span>(lc, l, mid, op), <span class="title function_">query</span>(rc, mid + <span class="number">1</span>, r, op));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int T, n, q, l, r, op, c, ax, <span class="keyword">in</span>;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">memset</span>(add, <span class="number">0</span>, <span class="title function_">sizeof</span>(add));</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">        <span class="title function_">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">while</span>(q--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;op, &amp;l, &amp;r);</span><br><span class="line">            <span class="keyword">if</span>(op == <span class="number">4</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ax = <span class="title function_">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">in</span> = <span class="title function_">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r, <span class="number">0</span>);</span><br><span class="line">                <span class="title function_">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, <span class="keyword">in</span>, ax);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c);</span><br><span class="line">                <span class="title function_">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r, c, op);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Segment Tree</p>
<p>Problem Description:</p>
<p>A contest is not integrity without problems about data structure.<br>There is an array a[1],a[2],…,a[n]. And q questions of the following 4 types: • 1 l r c - Update a[k] with a[k]+c for all l≤k≤r<br>• 2 l r c - Update a[k] with min{a[k],c} for all l≤k≤r;<br>• 3 l r c - Update a[k] with max{a[k],c} for all l≤k≤r;<br>• 4 l r - Ask for min{a[k]:l≤k≤r} and max{a[k]:l≤k≤r}.</p>
<p>Input</p>
<p>The first line contains a integer T(no more than 5) which represents the number of test cases.</p>
<p>For each test case, the first line contains 2 integers n,q (1≤n,q≤200000).</p>
<p>The second line contains n integers a1,a2,…,an which indicates the initial values of the array (|ai|≤).</p>
<p>Each of the following q lines contains an integer t which denotes the type of i-th question. If t&#x3D;1,2,3, 3 integers l,r,c follows. If t&#x3D;4, 2 integers l,r follows. (1≤ti≤4,1≤li≤ri≤n)</p>
<p>If t&#x3D;1, |ci|≤2000;</p>
<p>If t&#x3D;2,3, |ci|≤10^9.</p>
<p>Output</p>
<p>For each question of type 4, output two integers denote the minimum and the maximum.</p>
<p>Sample Input</p>
<p>1<br>1 1<br>1<br>4 1 1</p>
<p>Sample Output</p>
<p>1 1</p>
<p>Source<br>XTU OnlineJudge</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>ZOJ 3447 Doraemon&#39;s Number Game(Java优先队列·BigInteger)</title>
    <url>/posts/oj/ds/ZOJ%203447%20Doraemon&#39;s%20Number%20Game(Java%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%C2%B7BigInteger)/</url>
    <content><![CDATA[<p>题意 给你一个数组 你每次可以从中删掉2到k个数 然后把删掉的数的积加入到原数组 直到最后只剩一个数 求这样能得到的最大值和最小值的差</p>
<p>每次选的数值越小 选的数量越少 最后得到的结果肯定越大 因为这样大的数可以乘以最大的倍数 运算的次数也是最多从而使+1的次数最多 这显然是有利于最后结果的增大的</p>
<p>同理 每次选的数越大 选的数越多 最后得到的结果越小</p>
<p>这样最大值就是每次取最小的两个数 最大值就是每次取最大的k个数了 很容易用优先队列实现 结果会很大 用Java的BigInteger实现比较方便</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.<span class="property">math</span>.<span class="property">BigInteger</span>;</span><br><span class="line"><span class="keyword">import</span> java.<span class="property">util</span>.*;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	public <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span> args[]</span>) &#123;</span><br><span class="line">		<span class="title class_">Scanner</span> <span class="keyword">in</span> = <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="title class_">System</span>.<span class="property">in</span>);</span><br><span class="line">		int N = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line">		<span class="title class_">PriorityQueue</span>&lt;<span class="title class_">BigInteger</span>&gt; inc = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;<span class="title class_">BigInteger</span>&gt;();</span><br><span class="line">		<span class="comment">//优先队列默认小的优先 是增序队列</span></span><br><span class="line">		<span class="title class_">PriorityQueue</span>&lt;<span class="title class_">BigInteger</span>&gt; dec = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;<span class="title class_">BigInteger</span>&gt;(N,</span><br><span class="line">				<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="title class_">BigInteger</span>&gt;() &#123;</span><br><span class="line">					public int <span class="title function_">compare</span>(<span class="params">BigInteger o1, BigInteger o2</span>) &#123;</span><br><span class="line">						<span class="keyword">return</span> -o1.<span class="title function_">compareTo</span>(o2);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;); <span class="comment">//匿名实现Comparator接口  降序大的优先</span></span><br><span class="line"></span><br><span class="line">		int n, k;</span><br><span class="line">		<span class="title class_">BigInteger</span> a, b, one = <span class="title class_">BigInteger</span>.<span class="property">ONE</span>;</span><br><span class="line">		<span class="title class_">List</span>&lt;<span class="title class_">BigInteger</span>&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="title class_">BigInteger</span>&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">in</span>.<span class="title function_">hasNext</span>()) &#123;</span><br><span class="line">			n = <span class="keyword">in</span>.<span class="title function_">nextInt</span>();</span><br><span class="line">			k = <span class="keyword">in</span>.<span class="title function_">nextInt</span>();</span><br><span class="line"></span><br><span class="line">			list.<span class="title function_">clear</span>();</span><br><span class="line">			<span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">				a = <span class="keyword">in</span>.<span class="title function_">nextBigInteger</span>();</span><br><span class="line">				list.<span class="title function_">add</span>(a);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			inc.<span class="title function_">addAll</span>(list);</span><br><span class="line">			<span class="keyword">while</span> (inc.<span class="title function_">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">				a = inc.<span class="title function_">poll</span>();</span><br><span class="line">				b = inc.<span class="title function_">poll</span>();</span><br><span class="line">				inc.<span class="title function_">add</span>(a.<span class="title function_">multiply</span>(b).<span class="title function_">add</span>(one));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			dec.<span class="title function_">addAll</span>(list);</span><br><span class="line">			<span class="keyword">while</span> (dec.<span class="title function_">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">				a = one;</span><br><span class="line">				<span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">					<span class="keyword">if</span> (dec.<span class="title function_">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">						a = a.<span class="title function_">multiply</span>(dec.<span class="title function_">poll</span>());</span><br><span class="line">				a = a.<span class="title function_">add</span>(one);</span><br><span class="line">				dec.<span class="title function_">add</span>(a);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(inc.<span class="title function_">poll</span>().<span class="title function_">subtract</span>(dec.<span class="title function_">poll</span>()));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">in</span>.<span class="title function_">close</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ZOJ Problem Set - 3447<br>Doraemon’s Number Game    Time Limit:2 Seconds Memory Limit:65536 KB</p>
<p>Doraemon and Nobita are playing a number game. First, Doraemon will give Nobita <em>N</em> positive numbers. Then Nobita can deal with these numbers for two rounds. Every time Nobita can delete <em>i</em> (2 ≤ <em>i</em> ≤ <em>K</em>) numbers from the number set. Assume that the numbers deleted is a[ 1 ], a[ 2 ] … a[ i ]. There should be a new number <em>X</em> &#x3D; ( a[ 1 ] &#x2F;* a[ 2 ] &#x2F;* … &#x2F;* a[ i ] + 1 ) to be inserted back into the number set. The operation will be applied to the number set over and over until there remains only one number in the set. The number is the result of round. Assume two results <em>A</em> and <em>B</em> are produced after two rounds. Nobita can get |<em>A</em> - <em>B</em>| scores.</p>
<p>Now Nobita wants to get the highest score. Please help him.</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>Input will contain no more than 10 cases. The first line of each case contains two positive integers <em>N</em> and <em>K</em> (1 ≤ <em>N</em> ≤ 100, 1 ≤ <em>K</em> ≤ 50). The following line contains <em>N</em> positive integers no larger than 50, indicating the numbers given by Doraemon.</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>For each case, you should output highest score in one line.</p>
<h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h4><p>6 3 1 3 4 10 7 15</p>
<h4 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h4><p>5563</p>
<h4 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h4><p>For most cases, <em>N</em> ≤ 20</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>hihoCoder 1078 线段树的区间修改</title>
    <url>/posts/oj/ds/hihoCoder%201078%20%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9/</url>
    <content><![CDATA[<p>还是最基础的线段树噢 这次是区间修改</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define lc p&lt;&lt;<span class="number">1</span>,s,mid</span><br><span class="line">#define rc p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,e</span><br><span class="line">#define mid (s+e)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">100005</span>;</span><br><span class="line">int sum[<span class="number">4</span> * N], setv[<span class="number">4</span> * N];</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pushup</span>(<span class="params">int p</span>)</span><br><span class="line">&#123;</span><br><span class="line">    sum[p] = (sum[p &lt;&lt; <span class="number">1</span>] + sum[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pushdown</span>(<span class="params">int p, int s, int e</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(setv[p] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    sum[p &lt;&lt; <span class="number">1</span>] = (mid - s + <span class="number">1</span>) * setv[p];</span><br><span class="line">    sum[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = (e - mid) * setv[p];</span><br><span class="line">    setv[p &lt;&lt; <span class="number">1</span>] = setv[p];</span><br><span class="line">    setv[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = setv[p];</span><br><span class="line">    setv[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">build</span>(<span class="params">int p, int s, int e</span>)</span><br><span class="line">&#123;</span><br><span class="line">    setv[p] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(s == e) <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;sum[p]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">build</span>(lc);</span><br><span class="line">        <span class="title function_">build</span>(rc);</span><br><span class="line">        <span class="title function_">pushup</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span>(<span class="params">int p, int s, int e, int l, int r, int v</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s &gt;= l &amp;&amp; e &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        setv[p] = v;</span><br><span class="line">        sum[p] = (e - s + <span class="number">1</span>) * v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">pushdown</span>(p, s, e);</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= mid) <span class="title function_">update</span>(lc, l, r, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l &gt; mid) <span class="title function_">update</span>(rc, l, r, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="title function_">update</span>(lc, l, mid, v), <span class="title function_">update</span>(rc, mid + <span class="number">1</span>, r, v);</span><br><span class="line">    <span class="title function_">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">query</span>(<span class="params">int p, int s, int e, int l, int r</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s &gt;= l &amp;&amp; e &lt;= r) <span class="keyword">return</span> sum[p];</span><br><span class="line">    <span class="title function_">pushdown</span>(p, s, e);</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= mid) <span class="keyword">return</span> <span class="title function_">query</span>(lc, l, r);</span><br><span class="line">    <span class="keyword">if</span>(l &gt; mid) <span class="keyword">return</span> <span class="title function_">query</span>(rc, l, r);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">query</span>(lc, l, mid) + <span class="title function_">query</span>(rc, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, m, a, b, c, op;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">            <span class="keyword">if</span>(op)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">                <span class="title function_">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, a, b, c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">                <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="title function_">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, a, b));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间限制: 10000ms</p>
<p>单点时限: 1000ms<br>内存限制: 256MB</p>
<h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>对于小Ho表现出的对线段树的理解，小Hi表示挺满意的，但是满意就够了么？于是小Hi将问题改了改，又出给了小Ho：</p>
<p>假设货架上从左到右摆放了N种商品，并且依次标号为1到N，其中标号为i的商品的价格为Pi。小Hi的每次操作分为两种可能，第一种是修改价格——小Hi给出一段区间[L, R]和一个新的价格NewP，所有标号在这段区间中的商品的价格都变成NewP。第二种操作是询问——小Hi给出一段区间[L, R]，而小Ho要做的便是计算出所有标号在这段区间中的商品的总价格，然后告诉小Hi。</p>
<p>那么这样的一个问题，小Ho该如何解决呢？</p>
<p><a href="http://hihocoder.com/problemset/problem/1078#">提示：推动科学发展的除了人的好奇心之外还有人的懒惰心！</a></p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>每个测试点（输入文件）有且仅有一组测试数据。</p>
<p>每组测试数据的第1行为一个整数N，意义如前文所述。</p>
<p>每组测试数据的第2行为N个整数，分别描述每种商品的重量，其中第i个整数表示标号为i的商品的重量Pi。</p>
<p>每组测试数据的第3行为一个整数Q，表示小Hi进行的操作数。</p>
<p>每组测试数据的第N+4~N+Q+3行，每行分别描述一次操作，每行的开头均为一个属于0或1的数字，分别表示该行描述一个询问和一次商品的价格的更改两种情况。对于第N+i+3行，如果该行描述一个询问，则接下来为两个整数Li, Ri，表示小Hi询问的一个区间[Li, Ri]；如果该行描述一次商品的价格的更改，则接下来为三个整数Li，Ri，NewP，表示标号在区间[Li, Ri]的商品的价格全部修改为NewP。</p>
<p>对于100%的数据，满足N&lt;&#x3D;10^5，Q&lt;&#x3D;10^5, 1&lt;&#x3D;Li&lt;&#x3D;Ri&lt;&#x3D;N，1&lt;&#x3D;Pi&lt;&#x3D;N, 0&lt;Pi, NewP&lt;&#x3D;10^4。</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>对于每组测试数据，对于每个小Hi的询问，按照在输入中出现的顺序，各输出一行，表示查询的结果：标号在区间[Li, Ri]中的所有商品的价格之和。<br>样例输入 10 4733 6570 8363 7391 4511 1433 2281 187 5166 378 6 1 5 10 1577 1 1 7 3649 0 8 10 0 1 4 1 6 8 157 1 3 4 1557 样例输出 4731 14596</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>hiho一下 37 (无序二分·k小数)</title>
    <url>/posts/oj/ds/hiho%E4%B8%80%E4%B8%8B%2037%20(%E6%97%A0%E5%BA%8F%E4%BA%8C%E5%88%86%C2%B7k%E5%B0%8F%E6%95%B0)/</url>
    <content><![CDATA[<p>题意 中文</p>
<p>可以先排序然后输出第k个 复杂度为O(N&#x2F;*logN) 但有更快的方法 其实二分时只要能保证mid左边的数都比mid小 mid右边的数都比mid大就能进行划分了 对于k不在的区间就不用管了于是可以用到快排的思想</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1000005</span>;</span><br><span class="line">int a[N];</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, k, l, r, le, ri, m;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i) <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">if</span>(n &lt; k) &#123;<span class="title function_">puts</span>(<span class="string">&quot;-1&quot;</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            m = a[le = l], ri = r;</span><br><span class="line">            <span class="keyword">while</span>(le &lt; ri)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(le &lt; ri &amp;&amp; a[ri] &gt; m) --ri;</span><br><span class="line">                a[le] = a[ri];</span><br><span class="line">                <span class="keyword">while</span>(le &lt; ri &amp;&amp; a[le] &lt; m) ++le;</span><br><span class="line">                a[ri] = a[le];</span><br><span class="line">            &#125;</span><br><span class="line">            a[le] = m;</span><br><span class="line">            <span class="keyword">if</span>(le &lt; k - <span class="number">1</span>) l = le + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = le - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[r + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间限制: 10000ms</p>
<p>单点时限: 1000ms<br>内存限制: 256MB</p>
<h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>在上一回里我们知道Nettle在玩《艦これ》，Nettle的镇守府有很多船位，但船位再多也是有限的。Nettle通过捞船又出了一艘稀有的船，但是已有的N(1≤N≤1,000,000)个船位都已经有船了。所以Nettle不得不把其中一艘船拆掉来让位给新的船。Nettle思考了很久，决定随机选择一个k，然后拆掉稀有度第k小的船。 已知每一艘船都有自己的稀有度，Nettle现在把所有船的稀有度值告诉你，希望你能帮他找出目标船。</p>
<p><a href="http://hihocoder.com/contest/hiho37/problem/1#">提示：非有序数组的二分查找之二</a></p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>第1行：2个整数N,k。N表示数组长度，<br>第2行：N个整数，表示a[1..N]，保证不会出现重复的数，1≤a[i]≤2,000,000,000。</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>第1行：一个整数t，表示t在数组中是第k小的数，若K不在数组中，输出-1。<br>样例输入 10 4 1732 4176 2602 6176 1303 6207 3125 1 1011 6600 样例输出 1732</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Data structure</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>CF 505B Mr. Kitayuta&#39;s Colorful Graph(最短路)</title>
    <url>/posts/oj/graph/CF%20505B%20Mr.%20Kitayuta&#39;s%20Colorful%20Graph(%E6%9C%80%E7%9F%AD%E8%B7%AF)/</url>
    <content><![CDATA[<p>题意 求两点之间有多少不同颜色的路径</p>
<p>范围比较小 可以直接floyd</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">105</span>;</span><br><span class="line">int d[N][N][N], ans;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int a, b, c, n, m, q;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">memset</span>(d, <span class="number">0</span>, <span class="title function_">sizeof</span>(d));</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">            d[c][a][b] = d[c][b][a] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(c = <span class="number">1</span>; c &lt;= m; ++c)</span><br><span class="line">        <span class="keyword">for</span>(int k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span>(!d[c][i][j]) d[c][i][j] = d[c][j][i] = (d[c][i][k] &amp;&amp; d[c][k][j]);</span><br><span class="line"></span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">        <span class="keyword">while</span>(q--)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="number">0</span>;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">for</span>(int c = <span class="number">1</span>; c &lt;= m; ++c)</span><br><span class="line">                <span class="keyword">if</span>(d[c][a][b]) ++ans;</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>B. Mr. Kitayuta’s Colorful Graph<br>Mr. Kitayuta has just bought an undirected graph consisting of <em>n</em> vertices and <em>m</em> edges. The vertices of the graph are numbered from 1 to <em>n</em>. Each edge, namely edge <em>i</em>, has a color <em>c**i</em>, connecting vertex <em>a**i</em> and <em>b**i</em>.</p>
<p>Mr. Kitayuta wants you to process the following <em>q</em> queries.</p>
<p>In the <em>i</em>-th query, he gives you two integers — <em>u**i</em> and <em>v**i</em>.</p>
<p>Find the number of the colors that satisfy the following condition: the edges of that color connect vertex <em>u**i</em> and vertex <em>v**i</em> directly or indirectly.</p>
<p>Input</p>
<p>The first line of the input contains space-separated two integers — <em>n</em> and <em>m</em> (2 ≤ <em>n</em> ≤ 100, 1 ≤ <em>m</em> ≤ 100), denoting the number of the vertices and the number of the edges, respectively.</p>
<p>The next <em>m</em> lines contain space-separated three integers — <em>a**i</em>, <em>b**i</em> (1 ≤ <em>a**i</em> &lt; <em>b**i</em> ≤ <em>n</em>) and <em>c**i</em> (1 ≤ <em>c**i</em> ≤ <em>m</em>). Note that there can be multiple edges between two vertices. However, there are no multiple edges of the same color between two vertices, that is, if <em>i</em> ≠ <em>j</em>, (<em>a**i</em>, <em>b**i</em>, <em>c**i</em>) ≠ (<em>a**j</em>, <em>b**j</em>, <em>c**j</em>).</p>
<p>The next line contains a integer — <em>q</em> (1 ≤ <em>q</em> ≤ 100), denoting the number of the queries.</p>
<p>Then follows <em>q</em> lines, containing space-separated two integers — <em>u**i</em> and <em>v**i</em> (1 ≤ <em>u**i</em>, <em>v**i</em> ≤ <em>n</em>). It is guaranteed that <em>u**i</em> ≠ <em>v**i</em>.<br>Output</p>
<p>For each query, print the answer in a separate line.</p>
<p>Sample test(s)</p>
<p>input 4 5 1 2 1 1 2 2 2 3 1 2 3 3 2 4 3 3 1 2 3 4 1 4</p>
<p>output 2 1 0<br>input 5 7 1 5 1 2 5 1 3 5 1 4 5 1 1 2 2 2 3 2 3 4 2 5 1 5 5 1 2 5 1 5 1 4</p>
<p>output 1 1 1 1 2</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1385 Minimum Transport Cost (字典序打印最短路)</title>
    <url>/posts/oj/graph/HDU%201385%20Minimum%20Transport%20Cost%20(%E5%AD%97%E5%85%B8%E5%BA%8F%E6%89%93%E5%8D%B0%E6%9C%80%E7%9F%AD%E8%B7%AF)/</url>
    <content><![CDATA[<p>题意 给你一个无向图的邻接矩阵 和途径每个点需要的额外花费首尾没有额外花费 求图中某两点之间的最短路并打印字典序最小路径</p>
<p>要求多组点之间的就用floyd咯 打印路径也比较方便 nex[i][j]表示从i点到j点最短路的第一个途经点 那么如果路径中加入一个节点k后 nex[i][j]应该更新为nex[i][k] 因为要途径k了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">100</span>,<span class="variable constant_">INF</span>=<span class="number">0x3f3f3f</span>;</span><br><span class="line">int cost[N][N], tax[N], nex[N][N];</span><br><span class="line">int s, t, n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">floyd</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int tmp;</span><br><span class="line">    <span class="keyword">for</span>(int k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = cost[i][k] + cost[k][j] + tax[k];</span><br><span class="line">        <span class="keyword">if</span>(cost[i][j] &gt; tmp || (cost[i][j] == tmp &amp;&amp; nex[i][j] &gt; nex[i][k]))</span><br><span class="line">        &#123;</span><br><span class="line">            nex[i][j] = nex[i][k];</span><br><span class="line">            cost[i][j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">memset</span>(nex,<span class="number">0</span>,<span class="title function_">sizeof</span>(nex));</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cost[i][j]);</span><br><span class="line">                <span class="keyword">if</span>(cost[i][j] &lt; <span class="number">0</span>) cost[i][j]=<span class="variable constant_">INF</span>;</span><br><span class="line">                <span class="keyword">else</span> nex[i][j]=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)  <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tax[i]);</span><br><span class="line">        <span class="title function_">floyd</span>();</span><br><span class="line">        <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;s, &amp;t), s &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            int k=s;</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;From %d to %d :\nPath: %d&quot;</span>, s, t, s);</span><br><span class="line">            <span class="keyword">while</span>(k!=t) <span class="title function_">printf</span>(<span class="string">&quot;--&gt;%d&quot;</span>, k=nex[k][t]);</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;\nTotal cost : %d\n\n&quot;</span>, cost[s][t]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Minimum-Transport-Cost"><a href="#Minimum-Transport-Cost" class="headerlink" title="Minimum Transport Cost"></a>Minimum Transport Cost</h1><p>Problem Description</p>
<p>These are N cities in Spring country. Between each pair of cities there may be one transportation track or none. Now there is some cargo that should be delivered from one city to another. The transportation fee consists of two parts:<br>The cost of the transportation on the path between these cities, and<br>a certain tax which will be charged whenever any cargo passing through one city, except for the source and the destination cities.<br>You must write a program to find the route which has the minimum cost.<br>Input</p>
<p>First is N, number of cities. N &#x3D; 0 indicates the end of input.<br>The data of path cost, city tax, source and destination cities are given in the input, which is of the form:<br>a11 a12 … a1N<br>a21 a22 … a2N<br>……………<br>aN1 aN2 … aNN<br>b1 b2 … bN<br>c d<br>e f<br>…<br>g h<br>where aij is the transport cost from city i to city j, aij &#x3D; -1 indicates there is no direct path between city i and city j. bi represents the tax of passing through city i. And the cargo is to be delivered from city c to city d, city e to city f, …, and g &#x3D; h &#x3D; -1. You must output the sequence of cities passed by and the total cost which is of the form:<br>Output</p>
<p>From c to d :<br>Path: c–&gt;c1–&gt;……–&gt;ck–&gt;d<br>Total cost : ……<br>……<br>From e to f :<br>Path: e–&gt;e1–&gt;……….–&gt;ek–&gt;f<br>Total cost : ……<br>Note: if there are more minimal paths, output the lexically smallest one. Print a blank line after each test case.<br>Sample Input</p>
<p>5 0 3 22 -1 4 3 0 5 -1 -1 22 5 0 9 20 -1 -1 9 0 4 4 -1 20 4 0 5 17 8 3 1 1 3 3 5 2 4 -1 -1 0<br>Sample Output</p>
<p>From 1 to 3 : Path: 1–&gt;5–&gt;4–&gt;3 Total cost : 21 From 3 to 5 : Path: 3–&gt;4–&gt;5 Total cost : 16 From 2 to 4 : Path: 2–&gt;1–&gt;5–&gt;4 Total cost : 17<br>Source</p>
<p><a href="http://acm.hdu.edu.cn/search.php?field=problem&key=Asia+1996,+Shanghai+(Mainland+China)&source=1&searchmode=source">Asia 1996, Shanghai (Mainland China)</a></p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1863 畅通工程 (最小生成树是否存在)</title>
    <url>/posts/oj/graph/HDU%201863%20%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%20(%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8)/</url>
    <content><![CDATA[<p>题意 中文</p>
<p>入门最小生成树 prim大法好</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">105</span>;</span><br><span class="line">int cost[N], mat[N][N], n, m, ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">prim</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">memset</span>(cost, <span class="number">0x3f</span>, <span class="title function_">sizeof</span>(cost));</span><br><span class="line">    cost[<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">    int cur = <span class="number">1</span>, next = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cost[j] == -<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(cost[j] &gt; mat[cur][j]) cost[j] = mat[cur][j];</span><br><span class="line">            <span class="keyword">if</span>(cost[j] &lt; cost[next]) next = j;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += cost[next], cost[cur = next] = -<span class="number">1</span>, next = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int a, b, c;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n), m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">memset</span>(mat, <span class="number">0x3f</span>, <span class="title function_">sizeof</span>(mat));</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">            <span class="keyword">if</span>(c &lt; mat[a][b]) mat[a][b] = mat[b][a] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="title function_">prim</span>();</span><br><span class="line">        <span class="keyword">if</span>(ans &gt;= cost[<span class="number">0</span>]) <span class="title function_">printf</span>(<span class="string">&quot;?\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="畅通工程"><a href="#畅通工程" class="headerlink" title="畅通工程"></a>畅通工程</h1><p>Problem Description</p>
<p>省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可）。经过调查评估，得到的统计表中列出了有可能建设公路的若干条道路的成本。现请你编写程序，计算出全省畅通需要的最低成本。<br>Input</p>
<p>测试输入包含若干测试用例。每个测试用例的第1行给出评估的道路条数 N、村庄数目M ( &lt; 100 )；随后的 N<br>行对应村庄间道路的成本，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间道路的成本（也是正整数）。为简单起见，村庄从1到M编号。当N为0时，全部输入结束，相应的结果不要输出。<br>Output</p>
<p>对每个测试用例，在1行里输出全省畅通需要的最低成本。若统计数据不足以保证畅通，则输出“?”。<br>Sample Input</p>
<p>3 3 1 2 1 1 3 2 2 3 4 1 3 2 3 2 0 100<br>Sample Output</p>
<p>3 ?</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1874 畅通工程续 (基础最短路)</title>
    <url>/posts/oj/graph/HDU%201874%20%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%E7%BB%AD%20(%E5%9F%BA%E7%A1%80%E6%9C%80%E7%9F%AD%E8%B7%AF)/</url>
    <content><![CDATA[<p>题意 中文</p>
<p>最基础的最短路 注意边可能多次给出 取最小的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">205</span>, M = <span class="number">1005</span>;</span><br><span class="line">int mat[N][N], v[N], d[N], n, m, s, t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dijkstra</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">memset</span>(d, <span class="number">0x3f</span>, <span class="title function_">sizeof</span>(d));</span><br><span class="line">    <span class="title function_">memset</span>(v, <span class="number">0</span>, <span class="title function_">sizeof</span>(v));</span><br><span class="line">    <span class="keyword">for</span>(int i = d[s] = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        int cur=n;   <span class="comment">//d[n]是INF,cur为当前未标记且到s距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            <span class="keyword">if</span>(!v[j] &amp;&amp; d[j] &lt; d[cur]) cur = j;</span><br><span class="line"></span><br><span class="line">        v[cur] = <span class="number">1</span>; <span class="keyword">if</span>(cur == t) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(d[j] &gt; d[cur] + mat[cur][j])</span><br><span class="line">                d[j] = d[cur] + mat[cur][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int a, b, x;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">memset</span>(mat, <span class="number">0x3f</span>, <span class="title function_">sizeof</span>(mat));</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;x);</span><br><span class="line">            <span class="keyword">if</span>(mat[a][b]&gt;x)   <span class="comment">//注意路径可能有多条</span></span><br><span class="line">                mat[a][b] = mat[b][a] = x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;s, &amp;t);</span><br><span class="line">        <span class="title function_">dijkstra</span>();</span><br><span class="line">        <span class="keyword">if</span>(d[t] &gt;= d[n]) <span class="title function_">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d[t]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="畅通工程续"><a href="#畅通工程续" class="headerlink" title="畅通工程续"></a>畅通工程续</h1><p>Problem Description</p>
<p>某省自从实行了很多年的畅通工程计划后，终于修建了很多路。不过路多了也不好，每次要从一个城镇到另一个城镇时，都有许多种道路方案可以选择，而某些方案要比另一些方案行走的距离要短很多。这让行人很困扰。<br>现在，已知起点和终点，请你计算出要从起点到终点，最短需要行走多少距离。<br>Input</p>
<p>本题目包含多组数据，请处理到文件结束。<br>每组数据第一行包含两个正整数N和M(0&lt;N&lt;200,0&lt;M&lt;1000)，分别代表现有城镇的数目和已修建的道路的数目。城镇分别以0～N-1编号。<br>接下来是M行道路信息。每一行有三个整数A,B,X(0&lt;&#x3D;A,B&lt;N,A!&#x3D;B,0&lt;X&lt;10000),表示城镇A和城镇B之间有一条长度为X的双向道路。<br>再接下一行有两个整数S,T(0&lt;&#x3D;S,T&lt;N)，分别代表起点和终点。<br>Output</p>
<p>对于每组数据，请在一行里输出最短需要行走的距离。如果不存在从S到T的路线，就输出-1.<br>Sample Input</p>
<p>3 3 0 1 1 0 2 3 1 2 1 0 2 3 1 0 1 1 1 2<br>Sample Output</p>
<p>2 -1</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 3080 The plan of city rebuild(除点最小生成树)</title>
    <url>/posts/oj/graph/HDU%203080%20The%20plan%20of%20city%20rebuild(%E9%99%A4%E7%82%B9%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91)/</url>
    <content><![CDATA[<p>题意 一个城市原来有l个村庄 e1条道路 又增加了n个村庄 e2条道路 后来后销毁了m个村庄 与m相连的道路也销毁了 求使所有未销毁村庄相互连通最小花费 不能连通输出what a pity!</p>
<p>还是很裸的最小生成树 把销毁掉的标记下 然后prim咯 结果是无穷大就是不能连通的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">300</span>;</span><br><span class="line">int mat[N][N], des[N], d[N], ans, n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">prim</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">memset</span>(d, <span class="number">0x3f</span>, <span class="title function_">sizeof</span>(d));</span><br><span class="line">    int s = <span class="number">0</span>;  <span class="keyword">while</span>(des[s]) ++s;</span><br><span class="line">    d[s] = -<span class="number">1</span>;</span><br><span class="line">    int cur = s, next = n;</span><br><span class="line">    <span class="keyword">for</span>(int k = <span class="number">1</span>; k &lt; n - m; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(des[i] || d[i] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            d[i] = <span class="title function_">min</span>(d[i], mat[cur][i]);</span><br><span class="line">            <span class="keyword">if</span>(d[i] &lt; d[next]) next = i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += d[next], d[next] = -<span class="number">1</span>, cur = next, next = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas, l, e1, e2, a, b, c;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span>(cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">memset</span>(mat, <span class="number">0x3f</span>, <span class="title function_">sizeof</span>(mat));</span><br><span class="line">        <span class="title function_">memset</span>(des, <span class="number">0</span>, <span class="title function_">sizeof</span>(des));</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;l, &amp;e1);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; e1; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">            <span class="keyword">if</span>(c &lt; mat[a][b]) mat[a][b] = mat[b][a] = c;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;e2);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; e2; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">            <span class="keyword">if</span>(c &lt; mat[a][b]) mat[a][b] = mat[b][a] = c;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n = n + l;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">            des[a] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span>;  <span class="title function_">prim</span>();</span><br><span class="line">        <span class="keyword">if</span>(ans &lt; d[n]) <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">        <span class="keyword">else</span> <span class="title function_">printf</span>(<span class="string">&quot;what a pity!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="The-plan-of-city-rebuild"><a href="#The-plan-of-city-rebuild" class="headerlink" title="The plan of city rebuild"></a>The plan of city rebuild</h1><p>Problem Description</p>
<p>News comes!~City W will be rebuilt with the expectation to become a center city. There are some villages and roads in the city now, however. In order to make the city better, some new villages should be built and some old ones should be destroyed. Then the officers have to make a new plan, now you , as the designer, have the task to judge if the plan is practical, which means there are roads(direct or indirect) between every two villages(of course the village has not be destroyed), if the plan is available, please output the minimum cost, or output”what a pity!”.<br>Input</p>
<p>Input contains an integer T in the first line, which means there are T cases, and then T lines follow.<br>Each case contains three parts. The first part contains two integers l(0&lt;l&lt;100), e1, representing the original number of villages and roads between villages(the range of village is from 0 to l-1), then follows e1 lines, each line contains three integers a, b, c (0&lt;&#x3D;a, b&lt;l, 0&lt;&#x3D;c&lt;&#x3D;1000), a, b indicating the village numbers and c indicating the road cost of village a and village b . The second part first contains an integer n(0&lt;n&lt;100), e2, representing the number of new villages and roads(the range of village is from l to l+n-1), then follows e2 lines, each line contains three integers x, y, z (0&lt;&#x3D;x, y&lt;l+n, 0&lt;&#x3D;z&lt;&#x3D;1000), x, y indicating the village numbers and z indicating the road cost of village x and village y. The third part contains an integer m(0&lt;m&lt;l+n), representing the number of deserted villages, next line comes m integers, p1,p2,…,pm,(0&lt;&#x3D;p1,p2,…,pm&lt;l+n) indicating the village number.<br>Pay attention: if one village is deserted, the roads connected are deserted, too.<br>Output</p>
<p>For each test case, If all villages can connect with each other(direct or indirect), output the minimum cost, or output “what a pity!”.<br>Sample Input</p>
<p>2 4 5 0 1 10 0 2 20 2 3 40 1 3 10 1 2 70 1 1 4 1 60 2 2 3 3 3 0 1 20 2 1 40 2 0 70 2 3 0 3 10 1 4 90 2 4 100 0<br>Sample Output</p>
<p>70 160</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1094 Sorting It All Out（拓扑排序·判断+实现）</title>
    <url>/posts/oj/graph/POJ%201094%20Sorting%20It%20All%20Out%EF%BC%88%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%C2%B7%E5%88%A4%E6%96%AD+%E5%AE%9E%E7%8E%B0%EF%BC%89/</url>
    <content><![CDATA[<p>题意 由一些不同元素组成的升序序列是可以用若干个小于号将所有的元素按从小到大的顺序 排列起来的序列。例如，排序后的序列为 A, B, C, D，这意味着 A &lt; B、B &lt; C和C &lt; D。在本题中， 给定一组形如 A &lt; B的关系式，你的任务是判定是否存在一个有序序列。 输出到哪一项可以确定顺序或者在这一项最先出现冲突，若所有的小于关系都处理完了都不能确定顺序也没有出现冲突，就输出不能确定</p>
<p>每来一个小于关系就进行一次拓扑排序 直到出现冲突（也就是出现了环）或者已经能确定顺序 当结果已经确定时 后面的小于关系也就没有必要处理了 因此可以用一个flag标记结果是否已经确定</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">30</span>;</span><br><span class="line">int n, m, <span class="keyword">in</span>[N];</span><br><span class="line">char ans[N], q[N];</span><br><span class="line">vector&lt;int&gt; e[N];</span><br><span class="line"></span><br><span class="line">int <span class="title function_">topoSort</span>() <span class="comment">//拓扑排序</span></span><br><span class="line">&#123;</span><br><span class="line">    int d[N], ret = <span class="number">1</span>;</span><br><span class="line">    <span class="title function_">memcpy</span>(d, <span class="keyword">in</span>, <span class="title function_">sizeof</span>(d));</span><br><span class="line">    int front  = <span class="number">0</span>, rear = <span class="number">0</span>, p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">if</span>(d[i] == <span class="number">0</span>) q[rear++] = i;</span><br><span class="line">    <span class="keyword">while</span>(front &lt; rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(rear - front &gt; <span class="number">1</span>) ret = <span class="number">0</span>; <span class="comment">//顺序不能确定</span></span><br><span class="line">        int cur = q[front++];</span><br><span class="line">        ans[p++] = <span class="string">&#x27;A&#x27;</span> + cur;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; e[cur].<span class="title function_">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            int j = e[cur][i];</span><br><span class="line">            <span class="keyword">if</span>((--d[j]) == <span class="number">0</span>) q[rear++] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p &lt; n) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">//有环</span></span><br><span class="line">    ans[p] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    char a, b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m), n || m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i) e[i].<span class="title function_">clear</span>();</span><br><span class="line">        <span class="title function_">memset</span>(<span class="keyword">in</span>, <span class="number">0</span>, <span class="title function_">sizeof</span>(<span class="keyword">in</span>));</span><br><span class="line">        int flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot; %c&lt;%c&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            a -= <span class="string">&#x27;A&#x27;</span>, b -= <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            e[a].<span class="title function_">push_back</span>(b);</span><br><span class="line">            ++<span class="keyword">in</span>[b];</span><br><span class="line">            flag = <span class="title function_">topoSort</span>();</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">1</span>)</span><br><span class="line">                <span class="title function_">printf</span>(<span class="string">&quot;Sorted sequence determined after %d relations: %s.\n&quot;</span>, i + <span class="number">1</span>, ans);</span><br><span class="line">            <span class="keyword">if</span>(flag == -<span class="number">1</span>)</span><br><span class="line">                <span class="title function_">printf</span>(<span class="string">&quot;Inconsistency found after %d relations.\n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="title function_">puts</span>(<span class="string">&quot;Sorted sequence cannot be determined.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Last modified :  2015-08-19 13:45 CST</span></span><br></pre></td></tr></table></figure>

<p>Sorting It All Out</p>
<p>Description<br>An ascending sorted sequence of distinct values is one in which some form of a less-than operator is used to order the elements from smallest to largest. For example, the sorted sequence A, B, C, D implies that A &lt; B, B &lt; C and C &lt; D. in this problem, we will give you a set of relations of the form A &lt; B and ask you to determine whether a sorted order has been specified or not.</p>
<p>Input</p>
<p>Input consists of multiple problem instances. Each instance starts with a line containing two positive integers n and m. the first value indicated the number of objects to sort, where 2 &lt;&#x3D; n &lt;&#x3D; 26. The objects to be sorted will be the first n characters of the uppercase alphabet. The second value m indicates the number of relations of the form A &lt; B which will be given in this problem instance. Next will be m lines, each containing one such relation consisting of three characters: an uppercase letter, the character “&lt;” and a second uppercase letter. No letter will be outside the range of the first n letters of the alphabet. Values of n &#x3D; m &#x3D; 0 indicate end of input.</p>
<p>Output</p>
<p>For each problem instance, output consists of one line. This line should be one of the following three:<br>Sorted sequence determined after xxx relations: yyy…y.<br>Sorted sequence cannot be determined.<br>Inconsistency found after xxx relations.<br>where xxx is the number of relations processed at the time either a sorted sequence is determined or an inconsistency is found, whichever comes first, and yyy…y is the sorted, ascending sequence.</p>
<p>Sample Input</p>
<p>4 6 A&lt;B A&lt;C B&lt;C C&lt;D B&lt;D A&lt;B 3 2 A&lt;B B&lt;A 26 1 A&lt;Z 0 0</p>
<p>Sample Output</p>
<p>Sorted sequence determined after 4 relations: ABCD. Inconsistency found after 2 relations. Sorted sequence cannot be determined.</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1128 Frame Stacking（拓扑排序·打印字典序）</title>
    <url>/posts/oj/graph/POJ%201128%20Frame%20Stacking%EF%BC%88%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%C2%B7%E6%89%93%E5%8D%B0%E5%AD%97%E5%85%B8%E5%BA%8F%EF%BC%89/</url>
    <content><![CDATA[<p>题意 给你一些矩形框堆叠后的俯视图 判断这些矩形框的堆叠顺序 每个矩形框满足每边都至少有一个点可见 输入保证至少有一个解 按字典序输出所有可行解</p>
<p>和上一题有点像 只是这个要打印所有的可行方案 建图还是类似 因为每个矩形框的四边都有点可见 所以每个矩形框的左上角和右下角的坐标是可以确定的 然后一个矩形框上有其它字符时 就让这个矩形框对应的字符和那个其它字符建立一个小于关系 由于要打印方案 所以在有多个入度为0的点时需要用DFS对每种选择都进行一遍拓扑排序</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">50</span>;</span><br><span class="line">char ans[N], g[N][N], tp[N][N];</span><br><span class="line">int x1[N], y1[N], x2[N], y2[N];</span><br><span class="line"><span class="comment">//(x1,y1)为对应字母的左上角坐标  (x2,y2)为右下</span></span><br><span class="line">int <span class="keyword">in</span>[N], n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addTopo</span>(<span class="params">int i, int j, int c</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int t = g[i][j] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(t != c &amp;&amp; !tp[c][t])</span><br><span class="line">    &#123;</span><br><span class="line">        ++<span class="keyword">in</span>[t];</span><br><span class="line">        tp[c][t] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">build</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">memset</span>(tp, <span class="number">0</span>, <span class="title function_">sizeof</span>(tp)); <span class="comment">//tp[i][j] = 1表示有i &lt; j的关系</span></span><br><span class="line">    <span class="keyword">for</span>(int c = n = <span class="number">0</span>; c &lt; <span class="number">26</span>; ++c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">in</span>[c] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = x1[c]; i &lt;= x2[c]; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">addTopo</span>(i, y1[c], c);</span><br><span class="line">            <span class="title function_">addTopo</span>(i, y2[c], c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(int j = y1[c]; j &lt;= y2[c]; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">addTopo</span>(x1[c], j, c);</span><br><span class="line">            <span class="title function_">addTopo</span>(x2[c], j, c);</span><br><span class="line">        &#125;</span><br><span class="line">        ++n;<span class="comment">//统计出现了多少个字符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">topoSort</span>(<span class="params">int k</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == n)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[k] = <span class="number">0</span>;</span><br><span class="line">        <span class="title function_">puts</span>(ans);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从前往后找入度为0的点保证升序</span></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">in</span>[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[k] = i + <span class="string">&#x27;A&#x27;</span>; <span class="comment">//这一位放i</span></span><br><span class="line">            <span class="keyword">in</span>[i] = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)</span><br><span class="line">                <span class="keyword">if</span>(tp[i][j]) --<span class="keyword">in</span>[j];</span><br><span class="line"></span><br><span class="line">            <span class="title function_">topoSort</span>(k + <span class="number">1</span>); <span class="comment">//找下一位</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">in</span>[i] = <span class="number">0</span>; <span class="comment">//回溯</span></span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)</span><br><span class="line">                <span class="keyword">if</span>(tp[i][j]) ++<span class="keyword">in</span>[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int h, w, c;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;h, &amp;w))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            x1[i] = y1[i] = N;</span><br><span class="line">            x2[i] = y2[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">memset</span>(<span class="keyword">in</span>, -<span class="number">1</span>, <span class="title function_">sizeof</span>(<span class="keyword">in</span>));</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; h; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, g[i]);</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; w; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((c = g[i][j] - <span class="string">&#x27;A&#x27;</span>) &lt; <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">//g[i][j] =&#x27;.&#x27;</span></span><br><span class="line">                <span class="keyword">if</span>(i &lt; x1[c]) x1[c] = i;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; x2[c]) x2[c] = i;</span><br><span class="line">                <span class="keyword">if</span>(j &lt; y1[c]) y1[c] = j;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; y2[c]) y2[c] = j;</span><br><span class="line">                <span class="keyword">in</span>[c] = <span class="number">0</span>;  <span class="comment">//出现过的字母in初始为0  否则为-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">build</span>();</span><br><span class="line">        <span class="title function_">topoSort</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Frame Stacking</p>
<p>Description<br>Consider the following 5 picture frames placed on an 9 x 8 array.<br>…….. …….. …….. …….. .CCC…. EEEEEE.. …….. …….. ..BBBB.. .C.C…. E….E.. DDDDDD.. …….. ..B..B.. .C.C…. E….E.. D….D.. …….. ..B..B.. .CCC…. E….E.. D….D.. ….AAAA ..B..B.. …….. E….E.. D….D.. ….A..A ..BBBB.. …….. E….E.. DDDDDD.. ….A..A …….. …….. E….E.. …….. ….AAAA …….. …….. EEEEEE.. …….. …….. …….. …….. 1 2 3 4 5<br>Now place them on top of one another starting with 1 at the bottom and ending up with 5 on top. If any part of a frame covers another it hides that part of the frame below.<br>Viewing the stack of 5 frames we see the following.<br>.CCC…. ECBCBB.. DCBCDB.. DCCC.B.. D.B.ABAA D.BBBB.A DDDDAD.A E…AAAA EEEEEE..<br>In what order are the frames stacked from bottom to top? The answer is EDABC.<br>Your problem is to determine the order in which the frames are stacked from bottom to top given a picture of the stacked frames. Here are the rules:</p>
<ol>
<li>The width of the frame is always exactly 1 character and the sides are never shorter than 3 characters.</li>
<li>It is possible to see at least one part of each of the four sides of a frame. A corner shows two sides.</li>
<li>The frames will be lettered with capital letters, and no two frames will be assigned the same letter.</li>
</ol>
<p>Input</p>
<p>Each input block contains the height, h (h&lt;&#x3D;30) on the first line and the width w (w&lt;&#x3D;30) on the second. A picture of the stacked frames is then given as h strings with w characters each.<br>Your input may contain multiple blocks of the format described above, without any blank lines in between. All blocks in the input must be processed sequentially.</p>
<p>Output</p>
<p>Write the solution to the standard output. Give the letters of the frames in the order they were stacked from bottom to top. If there are multiple possibilities for an ordering, list all such possibilities in alphabetical order, each one on a separate line. There will always be at least one legal ordering for each input block. List the output for all blocks in the input sequentially, without any blank lines (not even between blocks).</p>
<p>Sample Input</p>
<p>9 8 .CCC…. ECBCBB.. DCBCDB.. DCCC.B.. D.B.ABAA D.BBBB.A DDDDAD.A E…AAAA EEEEEE..</p>
<p>Sample Output</p>
<p>EDABC</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1135 Domino Effect(最短路 多米诺骨牌)</title>
    <url>/posts/oj/graph/POJ%201135%20Domino%20Effect(%E6%9C%80%E7%9F%AD%E8%B7%AF%20%E5%A4%9A%E7%B1%B3%E8%AF%BA%E9%AA%A8%E7%89%8C)/</url>
    <content><![CDATA[<p>题意</p>
<p>题目描述：<br>你知道多米诺骨牌除了用来玩多米诺骨牌游戏外，还有其他用途吗？多米诺骨牌游戏：取一 些多米诺骨牌，竖着排成连续的一行，两张骨牌之间只有很短的空隙。如果排列得很好，当你推 倒第 1张骨牌，会使其他骨牌连续地倒下（这就是短语“多米诺效应”的由来）。 然而当骨牌数量很少时，这种玩法就没多大意思了，所以一些人在 80 年代早期开创了另一个 极端的多米诺骨牌游戏：用上百万张不同颜色、不同材料的骨牌拼成一幅复杂的图案。他们开创 了一种流行的艺术。在这种骨牌游戏中，通常有多行骨牌同时倒下。 你的任务是编写程序，给定这样的多米诺骨牌游戏，计算后倒下的是哪一张骨牌、在什么 时间倒下。这些多米诺骨牌游戏包含一些“关键牌”，他们之间由一行普通骨牌连接。当一张关键 牌倒下时，连接这张关键牌的所有行都开始倒下。当倒下的行到达其他还没倒下的关键骨牌时， 则这些关键骨牌也开始倒下，同样也使得连接到它的所有行开始倒下。每一行骨牌可以从两个端 点中的任何一张关键牌开始倒下，甚至两个端点的关键牌都可以分别倒下，在这种情形下，该行 后倒下的骨牌为中间的某张骨牌。假定骨牌倒下的速度一致。</p>
<p>输入描述：<br>输入文件包含多个测试数据，每个测试数据描述了一个多米诺骨牌游戏。每个测试数据的第 1行为两个整数：n和m，n表示关键牌的数目，1≤n&lt;500；m表示这 n张牌之间用 m行普通骨 牌连接。n 张关键牌的编号为 1～n。每两张关键牌之间至多有一行普通牌，并且多米诺骨牌图案 是连通的，也就是说从一张骨牌可以通过一系列的行连接到其他每张骨牌。 接下来有 m行，每行为 3个整数：a、b和t，表示第 a张关键牌和第 b张关键牌之间有一行 普通牌连接，这一行从一端倒向另一端需要 t 秒。每个多米诺骨牌游戏都是从推倒第 1 张关键牌 开始的。 输入文件后一行为 n &#x3D; m &#x3D; 0，表示输入结束。</p>
<p>输出描述：<br>对输入文件中的每个测试数据，首先输出一行”System &#x2F;#k”，其中 k为测试数据的序号；然后 再输出一行，首先是后一块骨牌倒下的时间，精确到小数点后一位有效数字，然后是后倒下 骨牌的位置，这张后倒下的骨牌要么是关键牌，要么是两张关键牌之间的某张普通牌。输出格 式如样例输出所示。如果存在多个解，则输出任意一个。每个测试数据的输出之后输出一个空行。</p>
<p>先用最短路算出每个关键牌i的倒下时间d[i] 然后两个关键牌i,j间最后倒下的时间应该为 (d[i]+d[j]+mat[i][j])&#x2F;2 取时间最大的就是答案了 注意当i&#x3D;&#x3D;j时说明最后倒下的是关键节点 此时输出有所不同</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">505</span>;</span><br><span class="line">int d[N], v[N], mat[N][N], n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dijkstra</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">memset</span>(d, <span class="number">0x3f</span>, <span class="title function_">sizeof</span>(d));</span><br><span class="line">    <span class="title function_">memset</span>(v, <span class="number">0</span>, <span class="title function_">sizeof</span>(v));</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i =  <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        int cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span>(!v[j] &amp;&amp; d[j] &lt; d[cur]) cur = j;</span><br><span class="line">        v[cur] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span>(d[j] &gt; d[cur] + mat[cur][j])</span><br><span class="line">                d[j] = d[cur] + mat[cur][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int pi, pj, ans, a, b, c, cas = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">memset</span>(mat, <span class="number">0x3f</span>, <span class="title function_">sizeof</span>(mat));</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i) mat[i][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">            mat[a][b] = mat[b][a] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">dijkstra</span>();</span><br><span class="line"></span><br><span class="line">        int ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = i; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(mat[i][j] &gt;= d[<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(d[i] + d[j] + mat[i][j] &gt; ans || (i == j &amp;&amp; <span class="number">2</span> * d[i] &gt;= ans))</span><br><span class="line">                &#123;</span><br><span class="line">                    ans = d[i] + d[j] + mat[i][j];</span><br><span class="line">                    pi = i, pj = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        double t = ans / <span class="number">2.0</span>;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;System #%d\nThe last domino falls after %.1f seconds, &quot;</span>, ++cas, t);</span><br><span class="line">        <span class="keyword">if</span>(pi == pj)  <span class="title function_">printf</span>(<span class="string">&quot;at key domino %d.\n\n&quot;</span>, pi);</span><br><span class="line">        <span class="keyword">else</span>   <span class="title function_">printf</span>(<span class="string">&quot;between key dominoes %d and %d.\n\n&quot;</span>, pi, pj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Domino Effect</p>
<p>Description<br>Did you know that you can use domino bones for other things besides playing Dominoes? Take a number of dominoes and build a row by standing them on end with only a small distance in between. If you do it right, you can tip the first domino and cause all others to fall down in succession (this is where the phrase <code>domino effect&#39;&#39; comes from). While this is somewhat pointless with only a few dominoes, some people went to the opposite extreme in the early Eighties. Using millions of dominoes of different colors and materials to fill whole halls with elaborate patterns of falling dominoes, they created (short-lived) pieces of art. In these constructions, usually not only one but several rows of dominoes were falling at the same time. As you can imagine, timing is an essential factor here. It is now your task to write a program that, given such a system of rows formed by dominoes, computes when and where the last domino falls. The system consists of several </code>key dominoes’’ connected by rows of simple dominoes. When a key domino falls, all rows connected to the domino will also start falling (except for the ones that have already fallen). When the falling rows reach other key dominoes that have not fallen yet, these other key dominoes will fall as well and set off the rows connected to them. Domino rows may start collapsing at either end. It is even possible that a row is collapsing on both ends, in which case the last domino falling in that row is somewhere between its key dominoes. You can assume that rows fall at a uniform rate.</p>
<p>Input</p>
<p>The input file contains descriptions of several domino systems. The first line of each description contains two integers: the number n of key dominoes (1 &lt;&#x3D; n &lt; 500) and the number m of rows between them. The key dominoes are numbered from 1 to n. There is at most one row between any pair of key dominoes and the domino graph is connected, i.e. there is at least one way to get from a domino to any other domino by following a series of domino rows.<br>The following m lines each contain three integers a, b, and l, stating that there is a row between key dominoes a and b that takes l seconds to fall down from end to end.<br>Each system is started by tipping over key domino number 1.<br>The file ends with an empty system (with n &#x3D; m &#x3D; 0), which should not be processed.</p>
<p>Output</p>
<p>For each case output a line stating the number of the case (‘System &#x2F;#1’, ‘System &#x2F;#2’, etc.). Then output a line containing the time when the last domino falls, exact to one digit to the right of the decimal point, and the location of the last domino falling, which is either at a key domino or between two key dominoes(in this case, output the two numbers in ascending order). Adhere to the format shown in the output sample. The test data will ensure there is only one solution. Output a blank line after each system.</p>
<p>Sample Input</p>
<p>2 1 1 2 27 3 3 1 2 5 1 3 5 2 3 5 0 0</p>
<p>Sample Output</p>
<p>System &#x2F;#1 The last domino falls after 27.0 seconds, at key domino 2. System &#x2F;#2 The last domino falls after 7.5 seconds, between key dominoes 2 and 3.</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1251 Jungle Roads（最小生成树）</title>
    <url>/posts/oj/graph/POJ%201251%20Jungle%20Roads%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89/</url>
    <content><![CDATA[<p>题意 有n个村子 输入n 然后n-1行先输入村子的序号和与该村子相连的村子数t 后面依次输入t组s和tt s为村子序号 tt为与当前村子的距离 求链接所有村子的最短路径</p>
<p>还是裸的最小生成树咯</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N=<span class="number">30</span>,M=<span class="number">1000</span>;</span><br><span class="line">int par[N],n,m,ans;</span><br><span class="line">struct edge&#123;int u,v,w;&#125; e[M];</span><br><span class="line">bool <span class="title function_">cmp</span>(<span class="params">edge a,edge b</span>) &#123;<span class="keyword">return</span> a.<span class="property">w</span>&lt;b.<span class="property">w</span>;&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title class_">Find</span>(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int r=x,tmp;</span><br><span class="line">    <span class="keyword">while</span>(par[r]&gt;=<span class="number">0</span>) r=par[r];</span><br><span class="line">    <span class="keyword">while</span>(x!=r)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=par[x];</span><br><span class="line">        par[x]=r;</span><br><span class="line">        x=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title class_">Union</span> (int u,int v)</span><br><span class="line">&#123;</span><br><span class="line">    int ru=<span class="title class_">Find</span>(u),rv=<span class="title class_">Find</span>(v),tmp=par[ru]+par[rv];</span><br><span class="line">    <span class="keyword">if</span>(par[ru]&lt;par[rv])</span><br><span class="line">        par[rv]=ru,par[ru]=tmp;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        par[ru]=rv,par[rv]=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">kruskal</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">memset</span>(par,-<span class="number">1</span>,<span class="title function_">sizeof</span>(par));</span><br><span class="line">    int cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        int u=e[i].<span class="property">u</span>,v=e[i].<span class="property">v</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Find</span>(u)!=<span class="title class_">Find</span>(v))</span><br><span class="line">        &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            ans+=e[i].<span class="property">w</span>;</span><br><span class="line">            <span class="title class_">Union</span>(u,v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=n-<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    char s[<span class="number">2</span>]; int t,tt;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),n)</span><br><span class="line">    &#123;</span><br><span class="line">        m=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,s,&amp;t);</span><br><span class="line">            <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=t;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="title function_">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,s,&amp;tt);</span><br><span class="line">                e[++m].<span class="property">u</span>=i,e[m].<span class="property">v</span>=s[<span class="number">0</span>]-<span class="string">&#x27;A&#x27;</span>+<span class="number">1</span>,e[m].<span class="property">w</span>=tt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">sort</span>(e+<span class="number">1</span>,e+m+<span class="number">1</span>,cmp);</span><br><span class="line">        ans=<span class="number">0</span>; <span class="title function_">kruskal</span>();</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Jungle Roads</p>
<p>Description</p>
<p><img src="/../images/es-1251_1.jpg.png"><br>The Head Elder of the tropical island of Lagrishan has a problem. A burst of foreign aid money was spent on extra roads between villages some years ago. But the jungle overtakes roads relentlessly, so the large road network is too expensive to maintain. The Council of Elders must choose to stop maintaining some roads. The map above on the left shows all the roads in use now and the cost in aacms per month to maintain them. Of course there needs to be some way to get between all the villages on maintained roads, even if the route is not as short as before. The Chief Elder would like to tell the Council of Elders what would be the smallest amount they could spend in aacms per month to maintain roads that would connect all the villages. The villages are labeled A through I in the maps above. The map on the right shows the roads that could be maintained most cheaply, for 216 aacms per month. Your task is to write a program that will solve such problems.</p>
<p>Input</p>
<p>The input consists of one to 100 data sets, followed by a final line containing only 0. Each data set starts with a line containing only a number n, which is the number of villages, 1 &lt; n &lt; 27, and the villages are labeled with the first n letters of the alphabet, capitalized. Each data set is completed with n-1 lines that start with village labels in alphabetical order. There is no line for the last village. Each line for a village starts with the village label followed by a number, k, of roads from this village to villages with labels later in the alphabet. If k is greater than 0, the line continues with data for each of the k roads. The data for each road is the village label for the other end of the road followed by the monthly maintenance cost in aacms for the road. Maintenance costs will be positive integers less than 100. All data fields in the row are separated by single blanks. The road network will always allow travel between all the villages. The network will never have more than 75 roads. No village will have more than 15 roads going to other villages (before or after in the alphabet). In the sample input below, the first data set goes with the map above.</p>
<p>Output</p>
<p>The output is one integer per line for each data set: the minimum cost in aacms per month to maintain a road system that connect all the villages. Caution: A brute force solution that examines every possible set of roads will not finish within the one minute time limit.</p>
<p>Sample Input</p>
<p>9 A 2 B 12 I 25 B 3 C 10 H 40 I 8 C 2 D 18 G 55 D 1 E 44 E 2 F 60 G 38 F 0 G 1 H 35 H 1 I 35 3 A 2 B 10 C 40 B 1 C 20 0</p>
<p>Sample Output</p>
<p>216 30</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1258 Agri-Net（最小生成树 Kruskal）</title>
    <url>/posts/oj/graph/POJ%201258%20Agri-Net%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%20Kruskal%EF%BC%89/</url>
    <content><![CDATA[<p>题意 给你农场的邻接矩阵 求连通所有农场的最小消耗</p>
<p>和上一题一样裸的最小生成树</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">105</span>, M = <span class="number">10050</span>;</span><br><span class="line">int par[N], ans, n, m, t;</span><br><span class="line">struct edge &#123; int u, v, w;&#125; e[M];</span><br><span class="line">bool <span class="title function_">cmp</span>(<span class="params">edge a, edge b</span>)&#123; <span class="keyword">return</span> a.<span class="property">w</span> &lt; b.<span class="property">w</span>;&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title class_">Find</span>(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int r = x, tmp;</span><br><span class="line">    <span class="keyword">while</span>(par[r] &gt;= <span class="number">0</span>) r = par[r];</span><br><span class="line">    <span class="keyword">while</span>(x != r)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = par[x];</span><br><span class="line">        par[x] = r;</span><br><span class="line">        x = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title class_">Union</span>(int u, int v)</span><br><span class="line">&#123;</span><br><span class="line">    int ru = <span class="title class_">Find</span>(u), rv = <span class="title class_">Find</span>(v), tmp = par[ru] + par[rv];</span><br><span class="line">    <span class="keyword">if</span>(par[ru] &lt; par[rv])</span><br><span class="line">        par[rv] = ru, par[ru] = tmp;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        par[ru] = rv, par[rv] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">kruskal</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cur = <span class="number">0</span>, u, v;</span><br><span class="line">    <span class="title function_">memset</span>(par, -<span class="number">1</span>, <span class="title function_">sizeof</span>(par));</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        u = e[i].<span class="property">u</span>, v = e[i].<span class="property">v</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Find</span>(u) != <span class="title class_">Find</span>(v))</span><br><span class="line">        &#123;</span><br><span class="line">            ans += e[i].<span class="property">w</span>;</span><br><span class="line">            <span class="title class_">Union</span>(u, v);</span><br><span class="line">            ++cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur &gt;= n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        ans = m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">                <span class="keyword">if</span>(j &lt; i) e[++m].<span class="property">u</span> = i, e[m].<span class="property">v</span> = j, e[m].<span class="property">w</span> = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">sort</span>(e + <span class="number">1</span>, e + m + <span class="number">1</span>, cmp);</span><br><span class="line">        <span class="title function_">kruskal</span>();</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Agri-Net</p>
<p>Description<br>Farmer John has been elected mayor of his town! One of his campaign promises was to bring internet connectivity to all farms in the area. He needs your help, of course.<br>Farmer John ordered a high speed connection for his farm and is going to share his connectivity with the other farmers. To minimize cost, he wants to lay the minimum amount of optical fiber to connect his farm to all the other farms.<br>Given a list of how much fiber it takes to connect each pair of farms, you must find the minimum amount of fiber needed to connect them all together. Each farm must connect to some other farm such that a packet can flow from any one farm to any other farm.<br>The distance between any two farms will not exceed 100,000.</p>
<p>Input</p>
<p>The input includes several cases. For each case, the first line contains the number of farms, N (3 &lt;&#x3D; N &lt;&#x3D; 100). The following lines contain the N x N conectivity matrix, where each element shows the distance from on farm to another. Logically, they are N lines of N space-separated integers. Physically, they are limited in length to 80 characters, so some lines continue onto others. Of course, the diagonal will be 0, since the distance from farm i to itself is not interesting for this problem.</p>
<p>Output</p>
<p>For each case, output a single integer length that is the sum of the minimum length of fiber required to connect the entire set of farms.</p>
<p>Sample Input</p>
<p>4 0 4 9 21 4 0 8 17 9 8 0 16 21 17 16 0</p>
<p>Sample Output</p>
<p>28</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1287 Networking（最小生成树）</title>
    <url>/posts/oj/graph/POJ%201287%20Networking%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89/</url>
    <content><![CDATA[<p>题意 给你n个点 m条边 求最小生成树的权</p>
<p>这是最裸的最小生成树了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">55</span>, M = <span class="number">3000</span>;</span><br><span class="line">int par[N], n, m, ans;</span><br><span class="line">struct edge&#123;int u, v, w;&#125; e[M];</span><br><span class="line">bool <span class="title function_">cmp</span>(<span class="params">edge a, edge b</span>)&#123;<span class="keyword">return</span> a.<span class="property">w</span> &lt; b.<span class="property">w</span>;&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title class_">Find</span>(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int r = x, tmp;</span><br><span class="line">    <span class="keyword">while</span>(par[r] &gt;= <span class="number">0</span>) r = par[r];</span><br><span class="line">    <span class="keyword">while</span>(x != r)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = par[x];</span><br><span class="line">        par[x] = r;</span><br><span class="line">        x = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title class_">Union</span> (int u, int v)</span><br><span class="line">&#123;</span><br><span class="line">    int ru = <span class="title class_">Find</span>(u), rv = <span class="title class_">Find</span>(v), tmp = par[ru] + par[rv];</span><br><span class="line">    <span class="keyword">if</span>(par[ru] &lt; par[rv])</span><br><span class="line">        par[rv] = ru, par[ru] = tmp;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        par[ru] = rv, par[rv] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">kruskal</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">memset</span>(par, -<span class="number">1</span>, <span class="title function_">sizeof</span>(par));</span><br><span class="line">    int cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        int u = e[i].<span class="property">u</span>, v = e[i].<span class="property">v</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Find</span>(u) != <span class="title class_">Find</span>(v))</span><br><span class="line">        &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            ans += e[i].<span class="property">w</span>;</span><br><span class="line">            <span class="title class_">Union</span>(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt;= n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int u, v, w;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            e[i].<span class="property">u</span> = u, e[i].<span class="property">v</span> = v, e[i].<span class="property">w</span> = w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">sort</span>(e + <span class="number">1</span>, e + m + <span class="number">1</span>, cmp);</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="title function_">kruskal</span>();</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  Networking    Time Limit:2 Seconds Memory Limit:65536 KB</p>
<p>You are assigned to design network connections between certain points in a wide area. You are given a set of points in the area, and a set of possible routes for the cables that may connect pairs of points. For each possible route between two points, you are given the length of the cable that is needed to connect the points over that route. Note that there may exist many possible routes between two given points. It is assumed that the given possible routes connect (directly or indirectly) each two points in the area.<br>Your task is to design the network for the area, so that there is a connection (direct or indirect) between every two points (i.e., all the points are interconnected, but not necessarily by a direct cable), and that the total length of the used cable is minimal.</p>
<p><strong>Input</strong></p>
<p>The input file consists of a number of data sets. Each data set defines one required network. The first line of the set contains two integers: the first defines the number P of the given points, and the second the number R of given routes between the points. The following R lines define the given routes between the points, each giving three integer numbers: the first two numbers identify the points, and the third gives the length of the route. The numbers are separated with white spaces. A data set giving only one number P&#x3D;0 denotes the end of the input. The data sets are separated with an empty line.<br>The maximal number of points is 50. The maximal length of a given route is 100. The number of possible routes is unlimited. The nodes are identified with integers between 1 and P (inclusive). The routes between two points i and j may be given as i j or as j i.</p>
<p><strong>Output</strong></p>
<p>For each data set, print one number on a separate line that gives the total length of the cable used for the entire designed network.</p>
<p><strong>Sample Input</strong></p>
<p>1 0<br>2 3<br>1 2 37<br>2 1 17<br>1 2 68</p>
<p>3 7<br>1 2 19<br>2 3 11<br>3 1 7<br>1 3 5<br>2 3 89<br>3 1 91<br>1 2 32</p>
<p>5 7<br>1 2 5<br>2 3 7<br>2 4 8<br>4 5 11<br>3 5 10<br>1 5 6<br>4 2 12</p>
<p>0</p>
<p><strong>Sample Output</strong></p>
<p>0<br>17<br>16<br>26</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1300 Door Man（欧拉通路）</title>
    <url>/posts/oj/graph/POJ%201300%20Door%20Man%EF%BC%88%E6%AC%A7%E6%8B%89%E9%80%9A%E8%B7%AF%EF%BC%89/</url>
    <content><![CDATA[<p>题目描述：</p>
<p>你是一座大庄园的管家。庄园有很多房间，编号为 0、1、2、3，…。你的主人是一个心不在 焉的人，经常沿着走廊随意地把房间的门打开。多年来，你掌握了一个诀窍：沿着一个通道，穿 过这些大房间，并把房门关上。你的问题是能否找到一条路径经过所有开着门的房间，并使得： 1) 通过门后立即把门关上； 2) 关上了的门不再打开； 3) 后回到你自己的房间（房间 0），并且所有的门都已经关闭了。 在本题中，给定房间列表，及连通房间的、开着的门，并给定一个起始房间，判断是否存在 这样的一条路径。不需要输出这样的路径，只需判断是否存在。假定任意两个房间之间都是连通 的（可能需要经过其他房间）。</p>
<p>输入描述：</p>
<p>输入文件包含多个（多可达 100 个）测试数据，每个测试数据之间没有空行隔开。 每个测试数据包括 3部分： 起始行－格式为“START M N”，其中 M 为管理员起始所处的房间号，N 为房间的总数（1 ≤N≤20）； 房间列表－一共 N行，每行列出了一个房间通向其他房间的房间号（只需列出比它的号码大 的房间号，可能有多个，按升序排列），比如房间 3有门通向房间 1、5、7，则房间 3的信息行内 容为“5 7”，第一行代表房间 0，后一行代表行间 N-1。有可能有些行为空行，当然后一行肯 定是空行，因为 N-1 是大的房间号；两个房间之间可能有多扇门连通。 终止行－内容为”END”。 输入文件后一行是”ENDOFINPUT”，表示输入结束。</p>
<p>输出描述：</p>
<p>每个测试数据对应一行输出，如果能找到一条路关闭所有的门，并且回到房间 0，则输出”YES X”，X是他关闭的门的总数，否则输出”NO”。</p>
<p>就是判断能否构成欧拉通路·咯</p>
<p>无向图存在欧拉通路的充要条件：</p>
<ol>
<li><p>是连通图</p>
</li>
<li><p>奇度节点个数为0或2,其中为0时为欧拉回路,为2时是以这两个点节点为端点的欧拉通路</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">21</span>;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int door, cnt, m, n, deg[N];</span><br><span class="line">    char s[N], c;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, s), <span class="title function_">strcmp</span>(s, <span class="string">&quot;ENDOFINPUT&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">memset</span>(deg, <span class="number">0</span>, <span class="title function_">sizeof</span>(deg));</span><br><span class="line">        door = cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d %d\n&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;c))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="title function_">isdigit</span>(c)) ++door, ++deg[i], ++deg[c - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27; &#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(deg[i] % <span class="number">2</span>) ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        bool ok = (cnt == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span> ) || (m &amp;&amp; cnt == <span class="number">2</span> &amp;&amp; deg[m] % <span class="number">2</span> );</span><br><span class="line">        <span class="keyword">if</span>(ok) <span class="title function_">printf</span>(<span class="string">&quot;YES %d\n&quot;</span>, door);</span><br><span class="line">        <span class="keyword">else</span> <span class="title function_">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>Door Man</p>
<p>Description<br>You are a butler in a large mansion. This mansion has so many rooms that they are merely referred to by number (room 0, 1, 2, 3, etc…). Your master is a particularly absent-minded lout and continually leaves doors open throughout a particular floor of the house. Over the years, you have mastered the art of traveling in a single path through the sloppy rooms and closing the doors behind you. Your biggest problem is determining whether it is possible to find a path through the sloppy rooms where you:<br>  Always shut open doors behind you immediately after passing through<br> Never open a closed door<br> End up in your chambers (room 0) with all doors closed<br> In this problem, you are given a list of rooms and open doors between them (along with a starting room). It is not needed to determine a route, only if one is possible.</p>
<p>Input</p>
<p>Input to this problem will consist of a (non-empty) series of up to 100 data sets. Each data set will be formatted according to the following description, and there will be no blank lines separating data sets.<br>A single data set has 3 components:<br>  Start line - A single line, “START M N”, where M indicates the butler’s starting room, and N indicates the number of rooms in the house (1 &lt;&#x3D; N &lt;&#x3D; 20).<br> Room list - A series of N lines. Each line lists, for a single room, every open door that leads to a room of higher number. For example, if room 3 had open doors to rooms 1, 5, and 7, the line for room 3 would read “5 7”. The first line in the list represents room 0. The second line represents room 1, and so on until the last line, which represents room (N - 1). It is possible for lines to be empty (in particular, the last line will always be empty since it is the highest numbered room). On each line, the adjacent rooms are always listed in ascending order. It is possible for rooms to be connected by multiple doors!<br> End line - A single line, “END”<br> Following the final data set will be a single line, “ENDOFINPUT”.<br>Note that there will be no more than 100 doors in any single data set.</p>
<p>Output</p>
<p>For each data set, there will be exactly one line of output. If it is possible for the butler (by following the rules in the introduction) to walk into his chambers and close the final open door behind him, print a line “YES X”, where X is the number of doors he closed. Otherwise, print “NO”.</p>
<p>Sample Input</p>
<p>START 1 2 1 END START 0 5 1 2 2 3 3 4 4 END START 0 10 1 9 2 3 4 5 6 7 8 9 END ENDOFINPUT</p>
<p>Sample Output</p>
<p>YES 1 NO YES 10</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1386 Play on Words（有向欧拉通路 连通图）</title>
    <url>/posts/oj/graph/POJ%201386%20Play%20on%20Words%EF%BC%88%E6%9C%89%E5%90%91%E6%AC%A7%E6%8B%89%E9%80%9A%E8%B7%AF%20%E8%BF%9E%E9%80%9A%E5%9B%BE%EF%BC%89/</url>
    <content><![CDATA[<p>题意 见下方中文翻译</p>
<p>每个单词可以看成首尾两个字母相连的一条边 然后就是输入m条边 判断能否构成有向欧拉通路了</p>
<p>有向图存在欧拉通路的充要条件：</p>
<ol>
<li><p>有向图的基图连通；</p>
</li>
<li><p>所有点的出度和入度相等或者只有两个入度和出度不相等的点 且这两点入度与出度的差一个为-1（起点）一个为1（终点）.</p>
</li>
</ol>
<p>判断是否连通就是应用并查集了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">30</span>, M = <span class="number">100010</span>;</span><br><span class="line">struct edge&#123;int u, v; &#125; e[M];</span><br><span class="line">int vis[N], <span class="keyword">in</span>[N], out[N], par[N], m, ok;</span><br><span class="line"></span><br><span class="line">int <span class="title class_">Find</span>(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int r = x, tmp;</span><br><span class="line">    <span class="keyword">while</span>(par[r] &gt;= <span class="number">0</span>) r = par[r];</span><br><span class="line">    <span class="keyword">while</span>(x != r)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = par[x];</span><br><span class="line">        par[x] = r;</span><br><span class="line">        x = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title class_">Union</span>(int u, int v)</span><br><span class="line">&#123;</span><br><span class="line">    int ru = <span class="title class_">Find</span>(u), rv = <span class="title class_">Find</span>(v), tmp = par[ru] + par[rv];</span><br><span class="line">    <span class="keyword">if</span>(par[ru] &lt; par[rv]) par[rv] = ru, par[ru] = tmp;</span><br><span class="line">    <span class="keyword">else</span> par[ru] = rv, par[rv] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">connect</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">memset</span>(par, -<span class="number">1</span>, <span class="title function_">sizeof</span>(par)); <span class="comment">//初始化并查集</span></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        int u = e[i].<span class="property">u</span>, v = e[i].<span class="property">v</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Find</span>(u) != <span class="title class_">Find</span>(v)) <span class="title class_">Union</span>(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)</span><br><span class="line">            <span class="keyword">if</span>(vis[i] &amp;&amp; vis[j] &amp;&amp; <span class="title class_">Find</span>(i) != <span class="title class_">Find</span>(j)) ok = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    char s[<span class="number">1005</span>];</span><br><span class="line">    int u, v, cas;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span>(cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">            vis[i] = <span class="keyword">in</span>[i] = out[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">            u = s[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>, v = s[<span class="title function_">strlen</span>(s) - <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            vis[u] = vis[v] = <span class="number">1</span>;</span><br><span class="line">            e[i].<span class="property">u</span> = u, e[i].<span class="property">v</span> = v;</span><br><span class="line">            ++<span class="keyword">in</span>[u], ++out[v];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int id = <span class="number">0</span>, od = <span class="number">0</span>;<span class="comment">//i[d]记录入度比出度大1的点的个数 o[d]小1</span></span><br><span class="line">        ok = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">            int k = <span class="keyword">in</span>[i] - out[i];</span><br><span class="line">            <span class="keyword">if</span>(k &lt; -<span class="number">1</span> || k &gt; <span class="number">1</span>) &#123;ok = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">1</span>) ++id;</span><br><span class="line">            <span class="keyword">if</span>(k == -<span class="number">1</span>) ++od;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(id &gt; <span class="number">1</span> || od &gt; <span class="number">1</span> || id - od) ok = <span class="number">0</span>;</span><br><span class="line">        <span class="title function_">connect</span>();</span><br><span class="line">        <span class="keyword">if</span>(ok)  <span class="title function_">printf</span>(<span class="string">&quot;Ordering is possible.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="title function_">printf</span>(<span class="string">&quot;The door cannot be opened.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 题目描述：<br>有些秘门带有一个有趣的词迷。考古学家必须解开词迷才能打开门。由于没有其他方法可以 打开门，因此词迷就变得很重要。 每个门上有许多磁盘。每个盘上有一个单词，这些磁盘必须重新排列使得每个单词第一个字 母跟前一个单词后一个字母相同。例如单词”acm”可以跟在单词”motorola”的后面。你的任务是 编写一个程序，读入一组单词，然后判定是否可以经过重组使得每个单词第一个字母跟前一个单 词后一个字母相同，这样才能打开门。</p>
<p>输入描述：</p>
<p>输入文件中包含 T 个测试数据。输入文件的第一行就是 T，接下来是 T 个测试数据。每个测 试数据的第一行是一个整数 N，表示单词的个数（1≤N≤100000）；接下来有 N行，每行是一个 单词；每个单词至少有 2个、至多有 1000 个小写字母，即单词中只可能出现字母’a’～’z’；在同一 个测试数据中，一个单词可能出现多次。</p>
<p>输出描述：</p>
<p>如果通过重组单词可以达到要求，输出”Ordering is possible.”，否则输出”The door cannot be opened.”。</p>
<p>Sample Input<br>3 2 acm ibm 3 acm malform mouse 2 ok ok</p>
<p>Sample Output</p>
<p>The door cannot be opened. Ordering is possible. The door cannot be opened.</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1659 Frogs&#39; Neighborhood(度序列构图)</title>
    <url>/posts/oj/graph/POJ%201659%20Frogs&#39;%20Neighborhood(%E5%BA%A6%E5%BA%8F%E5%88%97%E6%9E%84%E5%9B%BE)/</url>
    <content><![CDATA[<p>题意 中文</p>
<p>根据Havel-Hakimi定理构图就行咯 先把顶点按度数从大到小排序 可图的话 度数大的顶点与它后面的度数个顶点相连肯定是满足的 出现了-1就说明不可图了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">20</span>;</span><br><span class="line">int mat[N][N], ord[N];</span><br><span class="line"></span><br><span class="line">bool <span class="title function_">cmp</span>(<span class="params">int i, int j</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mat[i][<span class="number">0</span>] &gt; mat[j][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas, i, j, k, t, n;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span>(cas--)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">memset</span>(mat, <span class="number">0</span>, <span class="title function_">sizeof</span>(mat));</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;mat[i][<span class="number">0</span>]);</span><br><span class="line">            ord[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">sort</span>(ord + i, ord + n + <span class="number">1</span>, cmp);</span><br><span class="line">            t = ord[i];</span><br><span class="line">            <span class="keyword">if</span>(mat[t][<span class="number">0</span>] &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= mat[t][<span class="number">0</span>]; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                k = ord[i + j];</span><br><span class="line">                mat[t][k] = mat[k][t] = <span class="number">1</span>;</span><br><span class="line">                --mat[k][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &lt;= n) <span class="title function_">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">                    <span class="title function_">printf</span>(<span class="string">&quot;%d &quot;</span>, mat[i][j]);</span><br><span class="line">                <span class="title function_">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cas) <span class="title function_">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Frogs’ Neighborhood</p>
<p>Description<br>未名湖附近共有<em>N</em>个大小湖泊<em>L</em>1, <em>L</em>2, …, <em>Ln</em>(其中包括未名湖)，每个湖泊<em>Li</em>里住着一只青蛙<em>Fi</em>(1 ≤ <em>i</em> ≤ <em>N</em>)。如果湖泊<em>Li</em>和<em>Lj</em>之间有水路相连，则青蛙<em>Fi</em>和<em>Fj</em>互称为邻居。现在已知每只青蛙的邻居数目<em>x</em>1, <em>x</em>2, …, <em>xn</em>，请你给出每两个湖泊之间的相连关系。</p>
<p>Input</p>
<p>第一行是测试数据的组数<em>T</em>(0 ≤ <em>T</em> ≤ 20)。每组数据包括两行，第一行是整数N(2 &lt; <em>N</em> &lt; 10)，第二行是<em>N</em>个整数，<em>x</em>1, <em>x</em>2,…, <em>x</em>n(0 ≤ <em>xi</em> ≤ <em>N</em>)。</p>
<p>Output</p>
<p>对输入的每组测试数据，如果不存在可能的相连关系，输出”NO”。否则输出”YES”，并用<em>N</em>×<em>N</em>的矩阵表示湖泊间的相邻关系，即如果湖泊<em>i</em>与湖泊<em>j</em>之间有水路相连，则第<em>i</em>行的第<em>j</em>个数字为1，否则为0。每两个数字之间输出一个空格。如果存在多种可能，只需给出一种符合条件的情形。相邻两组测试数据之间输出一个空行。</p>
<p>Sample Input</p>
<p>3 7 4 3 1 5 4 2 1 6 4 3 1 4 2 0 6 2 3 1 1 2 1</p>
<p>Sample Output</p>
<p>YES 0 1 0 1 1 0 1 1 0 0 1 1 0 0 0 0 0 1 0 0 0 1 1 1 0 1 1 0 1 1 0 1 0 1 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 NO YES 0 1 0 0 1 0 1 0 0 1 1 0 0 0 0 0 0 1 0 1 0 0 0 0 1 1 0 0 0 0 0 0 1 0 0 0</p>
<p>Source</p>
<p><a href="http://poj.org/searchproblem?field=source&key=POJ+Monthly--2004.05.15+Alcyone@pku">POJ Monthly–2004.05.15 Alcyone@pku</a></p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1789 Truck History（最小生成树）</title>
    <url>/posts/oj/graph/POJ%201789%20Truck%20History%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89/</url>
    <content><![CDATA[<p>题意 有n辆卡车 每辆卡车用7个字符表示 输入n 再输入n行字符 第i行与第j行的两个字符串有多少个对应位置的字符不同 i与j之间的距离就是几 求连接所有卡车的最短长度 题目不是这个意思 这样理解就行了</p>
<p>prim啦啦啦啦</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">2005</span>;</span><br><span class="line">int cost[N], dis[N][N], n, ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">prim</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">memset</span>(cost, <span class="number">0x3f</span>, <span class="title function_">sizeof</span>(cost));</span><br><span class="line">    cost[<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">    int cur = <span class="number">1</span>, next = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cost[j] == -<span class="number">1</span> || cur == j) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dis[cur][j] &lt; cost[j]) cost[j] = dis[cur][j];</span><br><span class="line">            <span class="keyword">if</span>(cost[j] &lt; cost[next]) next = j;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = next, next = <span class="number">0</span>, ans += cost[cur], cost[cur] = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    char s[N][<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">memset</span>(dis, <span class="number">0</span>, <span class="title function_">sizeof</span>(dis));</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[i]);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">                <span class="keyword">for</span>(int k = <span class="number">0</span>; k &lt; <span class="number">7</span>; ++k)</span><br><span class="line">                    <span class="keyword">if</span>(s[i][k] != s[j][k]) ++dis[i][j];</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="title function_">prim</span>();</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;The highest possible quality is 1/%d.\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Truck History</p>
<p>Description<br>Advanced Cargo Movement, Ltd. uses trucks of different types. Some trucks are used for vegetable delivery, other for furniture, or for bricks. The company has its own code describing each type of a truck. The code is simply a string of exactly seven lowercase letters (each letter on each position has a very special meaning but that is unimportant for this task). At the beginning of company’s history, just a single truck type was used but later other types were derived from it, then from the new types another types were derived, and so on.<br>Today, ACM is rich enough to pay historians to study its history. One thing historians tried to find out is so called derivation plan – i.e. how the truck types were derived. They defined the distance of truck types as the number of positions with different letters in truck type codes. They also assumed that each truck type was derived from exactly one other truck type (except for the first truck type which was not derived from any other type). The quality of a derivation plan was then defined as<br><strong>1&#x2F;Σ(to,td)d(to,td)</strong><br>where the sum goes over all pairs of types in the derivation plan such that t o is the original type and t d the type derived from it and d(t o,t d) is the distance of the types.<br>Since historians failed, you are to write a program to help them. Given the codes of truck types, your program should find the highest possible quality of a derivation plan.</p>
<p>Input</p>
<p>The input consists of several test cases. Each test case begins with a line containing the number of truck types, N, 2 &lt;&#x3D; N &lt;&#x3D; 2 000. Each of the following N lines of input contains one truck type code (a string of seven lowercase letters). You may assume that the codes uniquely describe the trucks, i.e., no two of these N lines are the same. The input is terminated with zero at the place of number of truck types.</p>
<p>Output</p>
<p>For each test case, your program should output the text “The highest possible quality is 1&#x2F;Q.”, where 1&#x2F;Q is the quality of the best derivation plan.</p>
<p>Sample Input</p>
<p>4 aaaaaaa baaaaaa abaaaaa aabaaaa 0</p>
<p>Sample Output</p>
<p>The highest possible quality is 1&#x2F;3.</p>
<p>Source</p>
<p><a href="http://poj.org/searchproblem?field=source&key=CTU+Open+2003">CTU Open 2003</a></p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1861 Network(隐含最小生成树 打印方案)</title>
    <url>/posts/oj/graph/POJ%201861%20Network(%E9%9A%90%E5%90%AB%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%20%E6%89%93%E5%8D%B0%E6%96%B9%E6%A1%88)/</url>
    <content><![CDATA[<p>题意 求n个点m条边的图的连通子图中最长边的最小值</p>
<p>实际上就是求最小生成树中的最长边 因为最小生成树的最长边肯定是所有生成树中最长边最小的 那么就也变成了最小生成树了 不要被样例坑到了 样例并不是最佳方案 只是最长边与最小生成树的最长边相等 题目是特判 直接用最小生成树做就行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1005</span>, M = <span class="number">15005</span>;</span><br><span class="line">struct edge&#123;int u, v, w;&#125; e[M];</span><br><span class="line">int par[N], ea[N], n, m, num, ans;</span><br><span class="line">bool <span class="title function_">cmp</span>(<span class="params">edge a, edge b</span>)&#123; <span class="keyword">return</span> a.<span class="property">w</span> &lt; b.<span class="property">w</span>; &#125;</span><br><span class="line"></span><br><span class="line">int <span class="title class_">Find</span>(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int r = x, tmp;</span><br><span class="line">    <span class="keyword">while</span>(par[r] &gt;= <span class="number">0</span>) r = par[r];</span><br><span class="line">    <span class="keyword">while</span>(x != r)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = par[x];</span><br><span class="line">        par[x] = r;</span><br><span class="line">        x = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title class_">Union</span>(int u, int v)</span><br><span class="line">&#123;</span><br><span class="line">    int ru = <span class="title class_">Find</span>(u), rv = <span class="title class_">Find</span>(v), tmp = par[ru] + par[rv];</span><br><span class="line">    <span class="keyword">if</span>(par[ru] &gt; par[rv])</span><br><span class="line">        par[ru] = rv, par[rv] = tmp;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        par[rv] = ru, par[ru] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">kruskal</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">memset</span>(par, -<span class="number">1</span>, <span class="title function_">sizeof</span>(par));</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        int u = e[i].<span class="property">u</span>, v = e[i].<span class="property">v</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Find</span>(u) != <span class="title class_">Find</span>(v))</span><br><span class="line">        &#123;</span><br><span class="line">            ea[++num] = i;</span><br><span class="line">            ans = <span class="title function_">max</span>(ans, e[i].<span class="property">w</span>);</span><br><span class="line">            <span class="title class_">Union</span>(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num &gt;= n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int u, v, w;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            e[i].<span class="property">u</span> = u, e[i].<span class="property">v</span> = v, e[i].<span class="property">w</span> = w;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">sort</span>(e + <span class="number">1</span>, e + m + <span class="number">1</span>, cmp);</span><br><span class="line">        ans = num = <span class="number">0</span>;</span><br><span class="line">        <span class="title function_">kruskal</span>();</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n%d\n&quot;</span>, ans, num);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= num; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            int j = ea[i];</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, e[j].<span class="property">u</span>, e[j].<span class="property">v</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Network</p>
<p>Description<br>Andrew is working as system administrator and is planning to establish a new network in his company. There will be N hubs in the company, they can be connected to each other using cables. Since each worker of the company must have access to the whole network, each hub must be accessible by cables from any other hub (with possibly some intermediate hubs).<br>Since cables of different types are available and shorter ones are cheaper, it is necessary to make such a plan of hub connection, that the maximum length of a single cable is minimal. There is another problem — not each hub can be connected to any other one because of compatibility problems and building geometry limitations. Of course, Andrew will provide you all necessary information about possible hub connections.<br>You are to help Andrew to find the way to connect hubs so that all above conditions are satisfied.</p>
<p>Input</p>
<p>The first line of the input contains two integer numbers: N - the number of hubs in the network (2 &lt;&#x3D; N &lt;&#x3D; 1000) and M - the number of possible hub connections (1 &lt;&#x3D; M &lt;&#x3D; 15000). All hubs are numbered from 1 to N. The following M lines contain information about possible connections - the numbers of two hubs, which can be connected and the cable length required to connect them. Length is a positive integer number that does not exceed 106. There will be no more than one way to connect two hubs. A hub cannot be connected to itself. There will always be at least one way to connect all hubs.</p>
<p>Output</p>
<p>Output first the maximum length of a single cable in your hub connection plan (the value you should minimize). Then output your plan: first output P - the number of cables used, then output P pairs of integer numbers - numbers of hubs connected by the corresponding cable. Separate numbers by spaces and&#x2F;or line breaks.</p>
<p>Sample Input</p>
<p>4 6 1 2 1 1 3 1 1 4 2 2 3 1 3 4 1 2 4 1</p>
<p>Sample Output</p>
<p>1 4 1 2 1 3 2 3 3 4</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1979 Red and Black(DFS 连通块中元素数量)</title>
    <url>/posts/oj/graph/POJ%201979%20Red%20and%20Black(DFS%20%E8%BF%9E%E9%80%9A%E5%9D%97%E4%B8%AD%E5%85%83%E7%B4%A0%E6%95%B0%E9%87%8F)/</url>
    <content><![CDATA[<p>题意 求矩阵中包含‘@’的’.’连通块中元素数量 ‘@’也看做’.’</p>
<p>最基础的dfs了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">30</span>;</span><br><span class="line">char mat[N][N];</span><br><span class="line">int dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;, dy[<span class="number">4</span>] = &#123; -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">int ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span>(<span class="params">int r, int c</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(mat[r][c] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    mat[r][c] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        int x = r + dx[i], y = c + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(mat[x][y] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">dfs</span>(x, y);</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int m, n, sx, sy;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n), m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">memset</span>(mat, <span class="number">0</span>, <span class="title function_">sizeof</span>(mat));</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, mat[i] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">                <span class="keyword">if</span>(mat[i][j] == <span class="string">&#x27;@&#x27;</span>) sx = i, sy = j;</span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">        <span class="title function_">dfs</span>(sx, sy);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Red and Black</p>
<p>Description<br>There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can’t move on red tiles, he can move only on black tiles.<br>Write a program to count the number of black tiles which he can reach by repeating the moves described above.</p>
<p>Input</p>
<p>The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20.<br>There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows.<br>‘.’ - a black tile<br>‘&#x2F;#’ - a red tile<br>‘@’ - a man on a black tile(appears exactly once in a data set)<br>The end of the input is indicated by a line consisting of two zeros.</p>
<p>Output</p>
<p>For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself).</p>
<p>Sample Input</p>
<p>6 9 ….&#x2F;#. …..&#x2F;# …… …… …… …… …… &#x2F;#@…&#x2F;# .&#x2F;#..&#x2F;#. 11 9 .&#x2F;#……… .&#x2F;#.&#x2F;#&#x2F;#&#x2F;#&#x2F;#&#x2F;#&#x2F;#&#x2F;#. .&#x2F;#.&#x2F;#…..&#x2F;#. .&#x2F;#.&#x2F;#.&#x2F;#&#x2F;#&#x2F;#.&#x2F;#. .&#x2F;#.&#x2F;#..@&#x2F;#.&#x2F;#. .&#x2F;#.&#x2F;#&#x2F;#&#x2F;#&#x2F;#&#x2F;#.&#x2F;#. .&#x2F;#…….&#x2F;#. .&#x2F;#&#x2F;#&#x2F;#&#x2F;#&#x2F;#&#x2F;#&#x2F;#&#x2F;#&#x2F;#. ……….. 11 6 ..&#x2F;#..&#x2F;#..&#x2F;#.. ..&#x2F;#..&#x2F;#..&#x2F;#.. ..&#x2F;#..&#x2F;#..&#x2F;#&#x2F;#&#x2F;# ..&#x2F;#..&#x2F;#..&#x2F;#@. ..&#x2F;#..&#x2F;#..&#x2F;#.. ..&#x2F;#..&#x2F;#..&#x2F;#.. 7 7 ..&#x2F;#.&#x2F;#.. ..&#x2F;#.&#x2F;#.. &#x2F;#&#x2F;#&#x2F;#.&#x2F;#&#x2F;#&#x2F;# ...@… &#x2F;#&#x2F;#&#x2F;#.&#x2F;#&#x2F;#&#x2F;# ..&#x2F;#.&#x2F;#.. ..&#x2F;#.&#x2F;#.. 0 0</p>
<p>Sample Output</p>
<p>45 59 6 13</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2031 Building a Space Station</title>
    <url>/posts/oj/graph/POJ%202031%20Building%20a%20Space%20Station/</url>
    <content><![CDATA[<p>题意 有n个空间站 接下n行依次输入n个空间站的x,y,z坐标和半径 求连接所有空间站总共至少要修多长的桥</p>
<p>也是裸的最小生成树 注意距离不会小于0 就是两个空间站相交的时候</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">105</span>, M = <span class="number">10050</span>;</span><br><span class="line">int par[N], n, m;</span><br><span class="line">double ans;</span><br><span class="line">struct edge&#123;int u, v; double w;&#125; e[M];</span><br><span class="line">bool <span class="title function_">cmp</span>(<span class="params">edge a, edge b</span>)&#123;<span class="keyword">return</span> a.<span class="property">w</span> &lt; b.<span class="property">w</span>;&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title class_">Find</span>(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int r = x, tmp;</span><br><span class="line">    <span class="keyword">while</span>(par[r] &gt;= <span class="number">0</span>) r = par[r];</span><br><span class="line">    <span class="keyword">while</span>(x != r)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = par[x];</span><br><span class="line">        par[x] = r;</span><br><span class="line">        x = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title class_">Union</span> (int u, int v)</span><br><span class="line">&#123;</span><br><span class="line">    int ru = <span class="title class_">Find</span>(u), rv = <span class="title class_">Find</span>(v), tmp = par[ru] + par[rv];</span><br><span class="line">    <span class="keyword">if</span>(par[ru] &lt; par[rv])</span><br><span class="line">        par[rv] = ru, par[ru] = tmp;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        par[ru] = rv, par[rv] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">kruskal</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">memset</span>(par, -<span class="number">1</span>, <span class="title function_">sizeof</span>(par));</span><br><span class="line">    int cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        int u = e[i].<span class="property">u</span>, v = e[i].<span class="property">v</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Find</span>(u) != <span class="title class_">Find</span>(v))</span><br><span class="line">        &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            ans += e[i].<span class="property">w</span>;</span><br><span class="line">            <span class="title class_">Union</span>(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt;= n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    double x[N], y[N], z[N], r[N], dis;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%lf%lf%lf%lf&quot;</span>, &amp;x[i], &amp;y[i], &amp;z[i], &amp;r[i]);</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                double tx = x[i] - x[j], ty = y[i] - y[j], tz = z[i] - z[j];</span><br><span class="line">                double dis = <span class="title function_">sqrt</span>(tx * tx + ty * ty + tz * tz) - r[i] - r[j];</span><br><span class="line">                e[++m].<span class="property">u</span> = i, e[m].<span class="property">v</span> = j, e[m].<span class="property">w</span> = <span class="title function_">max</span>(<span class="number">0.0</span>, dis);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">sort</span>(e + <span class="number">1</span>, e + m + <span class="number">1</span>, cmp);</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="title function_">kruskal</span>();</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%.3f\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Building a Space Station</p>
<p>Description<br>You are a member of the space station engineering team, and are assigned a task in the construction process of the station. You are expected to write a computer program to complete the task.<br>The space station is made up with a number of units, called cells. All cells are sphere-shaped, but their sizes are not necessarily uniform. Each cell is fixed at its predetermined position shortly after the station is successfully put into its orbit. It is quite strange that two cells may be touching each other, or even may be overlapping. In an extreme case, a cell may be totally enclosing another one. I do not know how such arrangements are possible.<br>All the cells must be connected, since crew members should be able to walk from any cell to any other cell. They can walk from a cell A to another cell B, if, (1) A and B are touching each other or overlapping, (2) A and B are connected by a &#96;corridor’, or (3) there is a cell C such that walking from A to C, and also from B to C are both possible. Note that the condition (3) should be interpreted transitively.<br>You are expected to design a configuration, namely, which pairs of cells are to be connected with corridors. There is some freedom in the corridor configuration. For example, if there are three cells A, B and C, not touching nor overlapping each other, at least three plans are possible in order to connect all three cells. The first is to build corridors A-B and A-C, the second B-C and B-A, the third C-A and C-B. The cost of building a corridor is proportional to its length. Therefore, you should choose a plan with the shortest total length of the corridors.<br>You can ignore the width of a corridor. A corridor is built between points on two cells’ surfaces. It can be made arbitrarily long, but of course the shortest one is chosen. Even if two corridors A-B and C-D intersect in space, they are not considered to form a connection path between (for example) A and C. In other words, you may consider that two corridors never intersect.</p>
<p>Input</p>
<p>The input consists of multiple data sets. Each data set is given in the following format.<br>n<br>x1 y1 z1 r1<br>x2 y2 z2 r2<br>…<br>xn yn zn rn<br>The first line of a data set contains an integer n, which is the number of cells. n is positive, and does not exceed 100.<br>The following n lines are descriptions of cells. Four values in a line are x-, y- and z-coordinates of the center, and radius (called r in the rest of the problem) of the sphere, in this order. Each value is given by a decimal fraction, with 3 digits after the decimal point. Values are separated by a space character.<br>Each of x, y, z and r is positive and is less than 100.0.<br>The end of the input is indicated by a line containing a zero.</p>
<p>Output</p>
<p>For each data set, the shortest total length of the corridors should be printed, each in a separate line. The printed values should have 3 digits after the decimal point. They may not have an error greater than 0.001.<br>Note that if no corridors are necessary, that is, if all the cells are connected without corridors, the shortest total length of the corridors is 0.000.</p>
<p>Sample Input</p>
<p>3 10.000 10.000 50.000 10.000 40.000 10.000 50.000 10.000 40.000 40.000 50.000 10.000 2 30.000 30.000 30.000 20.000 40.000 40.000 40.000 20.000 5 5.729 15.143 3.996 25.837 6.013 14.372 4.818 10.671 80.115 63.292 84.477 15.120 64.095 80.924 70.029 14.881 39.472 85.116 71.369 5.553 0</p>
<p>Sample Output</p>
<p>20.000 0.000 73.834</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2240 Arbitrage(最短路 套汇)</title>
    <url>/posts/oj/graph/POJ%202240%20Arbitrage(%E6%9C%80%E7%9F%AD%E8%B7%AF%20%E5%A5%97%E6%B1%87)/</url>
    <content><![CDATA[<p>题意 给你n种币种之间的汇率关系 判断能否形成套汇现象 即某币种多次换为其它币种再换回来结果比原来多</p>
<p>基础的最短路 只是加号换为了乘号</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">map&lt;string, int&gt; na;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">31</span>;</span><br><span class="line">double d[N], rate[N][N], r;</span><br><span class="line">int n, m, ans;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">bellman</span>(<span class="params">int s</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">memset</span>(d, <span class="number">0</span>, <span class="title function_">sizeof</span>(d));</span><br><span class="line">    d[s] = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">                <span class="keyword">if</span>(d[i] &lt; d[j]*rate[j][i])</span><br><span class="line">                    d[i] = d[j] * rate[j][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[s] &gt; <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas = <span class="number">0</span>;</span><br><span class="line">    char s[<span class="number">100</span>], a[<span class="number">100</span>], b[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        na.<span class="title function_">clear</span>();</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="title function_">memset</span>(rate, <span class="number">0</span>, <span class="title function_">sizeof</span>(rate));</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            rate[i][i] = <span class="number">1.0</span>;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">            na[s] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s%lf%s&quot;</span>, a, &amp;r, b);</span><br><span class="line">            rate[na[a]][na[b]] = r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_">bellman</span>(i))</span><br><span class="line">            &#123;</span><br><span class="line">                ans = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;Case %d: %s\n&quot;</span>, ++cas, ans ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Arbitrage</p>
<p>Description<br>Arbitrage is the use of discrepancies in currency exchange rates to transform one unit of a currency into more than one unit of the same currency. For example, suppose that 1 US Dollar buys 0.5 British pound, 1 British pound buys 10.0 French francs, and 1 French franc buys 0.21 US dollar. Then, by converting currencies, a clever trader can start with 1 US dollar and buy 0.5 &#x2F;* 10.0 &#x2F;* 0.21 &#x3D; 1.05 US dollars, making a profit of 5 percent.<br>Your job is to write a program that takes a list of currency exchange rates as input and then determines whether arbitrage is possible or not.</p>
<p>Input</p>
<p>The input will contain one or more test cases. Om the first line of each test case there is an integer n (1&lt;&#x3D;n&lt;&#x3D;30), representing the number of different currencies. The next n lines each contain the name of one currency. Within a name no spaces will appear. The next line contains one integer m, representing the length of the table to follow. The last m lines each contain the name ci of a source currency, a real number rij which represents the exchange rate from ci to cj and a name cj of the destination currency. Exchanges which do not appear in the table are impossible.<br>Test cases are separated from each other by a blank line. Input is terminated by a value of zero (0) for n.</p>
<p>Output</p>
<p>For each test case, print one line telling whether arbitrage is possible or not in the format “Case case: Yes” respectively “Case case: No”.</p>
<p>Sample Input</p>
<p>3 USDollar BritishPound FrenchFranc 3 USDollar 0.5 BritishPound BritishPound 10.0 FrenchFranc FrenchFranc 0.21 USDollar 3 USDollar BritishPound FrenchFranc 6 USDollar 0.5 BritishPound USDollar 4.9 FrenchFranc BritishPound 10.0 FrenchFranc BritishPound 1.99 USDollar FrenchFranc 0.09 BritishPound FrenchFranc 0.19 USDollar 0</p>
<p>Sample Output</p>
<p>Case 1: Yes Case 2: No</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2253 Frogger(最小最大距离)</title>
    <url>/posts/oj/graph/POJ%202253%20Frogger(%E6%9C%80%E5%B0%8F%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB)/</url>
    <content><![CDATA[<p>题意 给你n个点的坐标 求第1个点到第2个点的所有路径中两点间最大距离的最小值</p>
<p>很水的floyd咯</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N=<span class="number">205</span>;</span><br><span class="line">double d[N][N];</span><br><span class="line">int x[N],y[N],n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">floyd</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(int k=<span class="number">1</span>;k&lt;=n;++k)</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">        d[i][j]=<span class="title function_">min</span>(d[i][j],<span class="title function_">max</span>(d[i][k],d[k][j]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">memset</span>(d,<span class="number">0x3f</span>,<span class="title function_">sizeof</span>(d));</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x[i],&amp;y[i]);</span><br><span class="line">            <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;i;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                int tx=x[i]-x[j],ty=y[i]-y[j];</span><br><span class="line">                d[i][j]=d[j][i]=<span class="title function_">sqrt</span>(tx*tx+ty*ty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">floyd</span>();</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;Scenario #%d\nFrog Distance = %.3f\n\n&quot;</span>,++cas,d[<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Frogger</p>
<p>Description<br>Freddy Frog is sitting on a stone in the middle of a lake. Suddenly he notices Fiona Frog who is sitting on another stone. He plans to visit her, but since the water is dirty and full of tourists’ sunscreen, he wants to avoid swimming and instead reach her by jumping.<br>Unfortunately Fiona’s stone is out of his jump range. Therefore Freddy considers to use other stones as intermediate stops and reach her by a sequence of several small jumps.<br>To execute a given sequence of jumps, a frog’s jump range obviously must be at least as long as the longest jump occuring in the sequence.<br>The frog distance (humans also call it minimax distance) between two stones therefore is defined as the minimum necessary jump range over all possible paths between the two stones.<br>You are given the coordinates of Freddy’s stone, Fiona’s stone and all other stones in the lake. Your job is to compute the frog distance between Freddy’s and Fiona’s stone.</p>
<p>Input</p>
<p>The input will contain one or more test cases. The first line of each test case will contain the number of stones n (2&lt;&#x3D;n&lt;&#x3D;200). The next n lines each contain two integers xi,yi (0 &lt;&#x3D; xi,yi &lt;&#x3D; 1000) representing the coordinates of stone &#x2F;#i. Stone &#x2F;#1 is Freddy’s stone, stone &#x2F;#2 is Fiona’s stone, the other n-2 stones are unoccupied. There’s a blank line following each test case. Input is terminated by a value of zero (0) for n.</p>
<p>Output</p>
<p>For each test case, print a line saying “Scenario &#x2F;#x” and a line saying “Frog Distance &#x3D; y” where x is replaced by the test case number (they are numbered from 1) and y is replaced by the appropriate real number, printed to three decimals. Put a blank line after each test case, even after the last one.</p>
<p>Sample Input</p>
<p>2 0 0 3 4 3 17 4 19 4 18 5 0</p>
<p>Sample Output</p>
<p>Scenario &#x2F;#1 Frog Distance &#x3D; 5.000 Scenario &#x2F;#2 Frog Distance &#x3D; 1.414</p>
<p>Source</p>
<p><a href="http://poj.org/searchproblem?field=source&key=Ulm+Local+1997">Ulm Local 1997</a></p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2421 Constructing Roads（最小生成树）</title>
    <url>/posts/oj/graph/POJ%202421%20Constructing%20Roads%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89/</url>
    <content><![CDATA[<p>题意 在n个村庄之间修路使所有村庄连通 其中有些路已经修好了 求至少还需要修多长路</p>
<p>还是裸的最小生成树 修好的边权值为0就行咯</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">105</span>, M = <span class="number">10050</span>;</span><br><span class="line">int par[N], n, m, mat[N][N];</span><br><span class="line">int ans;</span><br><span class="line">struct edge&#123;int u, v, w;&#125; e[M];</span><br><span class="line">bool <span class="title function_">cmp</span>(<span class="params">edge a, edge b</span>)&#123;<span class="keyword">return</span> a.<span class="property">w</span> &lt; b.<span class="property">w</span>;&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title class_">Find</span>(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int r = x, tmp;</span><br><span class="line">    <span class="keyword">while</span>(par[r] &gt;= <span class="number">0</span>) r = par[r];</span><br><span class="line">    <span class="keyword">while</span>(x != r)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = par[x];</span><br><span class="line">        par[x] = r;</span><br><span class="line">        x = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title class_">Union</span> (int u, int v)</span><br><span class="line">&#123;</span><br><span class="line">    int ru = <span class="title class_">Find</span>(u), rv = <span class="title class_">Find</span>(v), tmp = par[ru] + par[rv];</span><br><span class="line">    <span class="keyword">if</span>(par[ru] &lt; par[rv])</span><br><span class="line">        par[rv] = ru, par[ru] = tmp;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        par[ru] = rv, par[rv] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">kruskal</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">memset</span>(par, -<span class="number">1</span>, <span class="title function_">sizeof</span>(par));</span><br><span class="line">    int cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        int u = e[i].<span class="property">u</span>, v = e[i].<span class="property">v</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Find</span>(u) != <span class="title class_">Find</span>(v))</span><br><span class="line">        &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            ans += e[i].<span class="property">w</span>;</span><br><span class="line">            <span class="title class_">Union</span>(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt;= n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int t, u, v;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;mat[i][j]);</span><br><span class="line">                <span class="keyword">if</span>(j &lt; i) e[++m].<span class="property">u</span> = i, e[m].<span class="property">v</span> = j, e[m].<span class="property">w</span> = mat[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">        <span class="keyword">while</span>(t--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">            e[++m].<span class="property">u</span> = u, e[m].<span class="property">v</span> = v, e[m].<span class="property">w</span> = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">sort</span>(e + <span class="number">1</span>, e + m + <span class="number">1</span>, cmp);</span><br><span class="line">        ans = <span class="number">0</span>; <span class="title function_">kruskal</span>();</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Constructing Roads</p>
<p><strong>Time Limit:</strong> 2000MS  <strong>Memory Limit:</strong> 65536K <strong>Total Submissions:</strong> 19755  <strong>Accepted:</strong> 8250</p>
<p>Description<br>There are N villages, which are numbered from 1 to N, and you should build some roads such that every two villages can connect to each other. We say two village A and B are connected, if and only if there is a road between A and B, or there exists a village C such that there is a road between A and C, and C and B are connected.<br>We know that there are already some roads between some villages and your job is the build some roads such that all the villages are connect and the length of all the roads built is minimum.</p>
<p>Input</p>
<p>The first line is an integer N (3 &lt;&#x3D; N &lt;&#x3D; 100), which is the number of villages. Then come N lines, the i-th of which contains N integers, and the j-th of these N integers is the distance (the distance should be an integer within [1, 1000]) between village i and village j.<br>Then there is an integer Q (0 &lt;&#x3D; Q &lt;&#x3D; N &#x2F;* (N + 1) &#x2F; 2). Then come Q lines, each line contains two integers a and b (1 &lt;&#x3D; a &lt; b &lt;&#x3D; N), which means the road between village a and village b has been built.</p>
<p>Output</p>
<p>You should output a line contains an integer, which is the length of all the roads to be built such that all the villages are connected, and this value is minimum.</p>
<p>Sample Input</p>
<p>3 0 990 692 990 0 179 692 179 0 1 1 2</p>
<p>Sample Output</p>
<p>179</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2570 Fiber Network（最短路 二进制处理）</title>
    <url>/posts/oj/graph/POJ%202570%20Fiber%20Network%EF%BC%88%E6%9C%80%E7%9F%AD%E8%B7%AF%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%A4%84%E7%90%86%EF%BC%89/</url>
    <content><![CDATA[<p>题目翻译</p>
<p>一些公司决定搭建一个更快的网络，称为“光纤网”。他们已经在全世界建立了许多站点，这 些站点的作用类似于路由器。不幸的是，这些公司在关于站点之间的接线问题上存在争论，这样“光纤网”项目就被迫终止了，留下的是每个公司自己在某些站点之间铺设的线路。 现在，Internet 服务供应商，当想从站点 A传送数据到站点 B，就感到困惑了，到底哪个公司 能够提供必要的连接。请帮助供应商回答他们的查询，查询所有可以提供从站点 A到站定 B的线 路连接的公司。</p>
<p>输入描述：</p>
<p>输入文件包含多个测试数据。每个测试数据第 1行为一个整数 n，代表网络中站点的个数，n &#x3D; 0 代表输入结束，否则 n的范围为：1≤n≤200。站点的编号为 1, …, n。接下来列出了这些站 点之间的连接。每对连接占一行，首先是两个整数 A和B，A &#x3D; B &#x3D; 0 代表连接列表结束，否则 A、 B的范围为：1≤A, B≤n，表示站点 A和站点 B之间的单向连接；每行后面列出了拥有站点 A到 B之间连接的公司，公司用小写字母标识，多个公司的集合为包含小写字母的字符串。 连接列表之后，是供应商查询的列表。每个查询包含两个整数 A和B，A &#x3D; B &#x3D; 0 代表查询列 表结束，也代表整个测试数据结束，否则 A、B 的范围为：1≤A, B≤n，代表查询的起始和终止 站点。假定任何一对连接和查询的两个站点都不相同。</p>
<p>输出描述：</p>
<p>对测试数据中的每个查询，输出一行，为满足以下条件的所有公司的标识：这些公司可以通 过自己的线路为供应商提供从查询的起始站点到终止站点的数据通路。如果没有满足条件的公司， 则仅输出字符”-“。每个测试数据的输出之后输出一个空行。</p>
<p>公司最多有26个 可以用2进制来表示站点间的连接关系 如果提供站点 1 到站点 2 的连接的公司集合为{ ‘a’, ‘b’, ‘c’ }，可以用 “00000000000000000000000000000111”表示，提供站点 2到站点 3的连接的公司集合为{ ‘a’, ‘d’ }，用“00000000000000000000000000001001”表示，这两个整数进行二进制与运算后 得到“00000000000000000000000000000001”，表示通过中间站点 2，提供站点 1到站点 3的连 接的公司集合为{ ‘a’ }。</p>
<p>这样就floyd进行处理就类似最短路问题了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">205</span>;</span><br><span class="line">int d[N][N], n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">floyd</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(int k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        d[i][j] |= (d[i][k] &amp; d[k][j]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    char s[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">memset</span>(d, <span class="number">0</span>, <span class="title function_">sizeof</span>(d));</span><br><span class="line">        <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b), a)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">            <span class="keyword">for</span>(int i = <span class="number">0</span>; s[i] != <span class="string">&#x27;\0&#x27;</span>; ++i)</span><br><span class="line">                d[a][b] = d[a][b] | (<span class="number">1</span> &lt;&lt; s[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">floyd</span>();</span><br><span class="line">        <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b), a)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(char c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; ++c)</span><br><span class="line">                <span class="keyword">if</span>(d[a][b] &amp; (<span class="number">1</span> &lt;&lt; c - <span class="string">&#x27;a&#x27;</span>)) <span class="title function_">printf</span>(<span class="string">&quot;%c&quot;</span>, c);</span><br><span class="line">            <span class="keyword">if</span>(d[a][b] == <span class="number">0</span>) <span class="title function_">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Fiber Network</p>
<p>Description<br>Several startup companies have decided to build a better Internet, called the “FiberNet”. They have already installed many nodes that act as routers all around the world. Unfortunately, they started to quarrel about the connecting lines, and ended up with every company laying its own set of cables between some of the nodes.<br>Now, service providers, who want to send data from node A to node B are curious, which company is able to provide the necessary connections. Help the providers by answering their queries.</p>
<p>Input</p>
<p>The input contains several test cases. Each test case starts with the number of nodes of the network n. Input is terminated by n&#x3D;0. Otherwise, 1&lt;&#x3D;n&lt;&#x3D;200. Nodes have the numbers 1, …, n. Then follows a list of connections. Every connection starts with two numbers A, B. The list of connections is terminated by A&#x3D;B&#x3D;0. Otherwise, 1&lt;&#x3D;A,B&lt;&#x3D;n, and they denote the start and the endpoint of the unidirectional connection, respectively. For every connection, the two nodes are followed by the companies that have a connection from node A to node B. A company is identified by a lower-case letter. The set of companies having a connection is just a word composed of lower-case letters.<br>After the list of connections, each test case is completed by a list of queries. Each query consists of two numbers A, B. The list (and with it the test case) is terminated by A&#x3D;B&#x3D;0. Otherwise, 1&lt;&#x3D;A,B&lt;&#x3D;n, and they denote the start and the endpoint of the query. You may assume that no connection and no query contains identical start and end nodes.</p>
<p>Output</p>
<p>For each query in every test case generate a line containing the identifiers of all the companies, that can route data packages on their own connections from the start node to the end node of the query. If there are no companies, output “-“ instead. Output a blank line after each test case. <img src="/../images/es-2570_1.jpg.png"></p>
<p>Sample Input</p>
<p>3 1 2 abc 2 3 ad 1 3 b 3 1 de 0 0 1 3 2 1 3 2 0 0 2 1 2 z 0 0 1 2 2 1 0 0 0</p>
<p>Sample Output</p>
<p>ab d - z -</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2585 Window Pains（拓扑排序·窗口覆盖）</title>
    <url>/posts/oj/graph/POJ%202585%20Window%20Pains%EF%BC%88%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%C2%B7%E7%AA%97%E5%8F%A3%E8%A6%86%E7%9B%96%EF%BC%89/</url>
    <content><![CDATA[<p>题意 有一个4&#x2F;*4的显示器 有9个程序 每个程序占2&#x2F;*2个格子 他们的位置如图所示 当你运行某个程序时 这个程序就会显示在顶层覆盖其它的程序 给你某个时刻显示器的截图 判断此时电脑是否死机了（出现了不合法的覆盖关系）</p>
<p>拓扑排序的应用 关键是建图 当一个程序A的区域上有其它程序B时 说明A是在B之前运行的 那么我们可以建立一个A&lt;B的拓扑关系 最后判断是否有环就行了 个人认为下标换为0操作起来比较方便 所以都还为了0</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">10</span>;</span><br><span class="line">int g[N][N], <span class="keyword">in</span>[N], q[N];</span><br><span class="line">vector&lt;int&gt; e[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">build</span>() <span class="comment">//建图</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">memset</span>(<span class="keyword">in</span>, <span class="number">0</span>, <span class="title function_">sizeof</span>(<span class="keyword">in</span>));</span><br><span class="line">    <span class="keyword">for</span>(int k = <span class="number">0</span>; k &lt; <span class="number">9</span>; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        e[k].<span class="title function_">clear</span>();</span><br><span class="line">        int i = k / <span class="number">3</span>, j = k % <span class="number">3</span>, t; <span class="comment">//获取程序k的左上角坐标</span></span><br><span class="line">        <span class="keyword">for</span>(int x = <span class="number">0</span>; x &lt; <span class="number">2</span>; ++x)</span><br><span class="line">        <span class="keyword">for</span>(int y = <span class="number">0</span>; y &lt; <span class="number">2</span>; ++y)</span><br><span class="line">        &#123;</span><br><span class="line">            t = g[i + x][j + y];</span><br><span class="line">            <span class="keyword">if</span>(t != k) <span class="comment">//程序k在程序t之前运行 k &lt; t</span></span><br><span class="line">            &#123;</span><br><span class="line">                e[k].<span class="title function_">push_back</span>(t);</span><br><span class="line">                ++<span class="keyword">in</span>[t];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool <span class="title function_">topo</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">build</span>();</span><br><span class="line">    int front = <span class="number">0</span>, rear = <span class="number">0</span>, cur;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">in</span>[i]) q[rear++] = i;</span><br><span class="line">    <span class="keyword">while</span>(front &lt; rear)</span><br><span class="line">    &#123;</span><br><span class="line">        cur = q[front++];</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; e[cur].<span class="title function_">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            int j = e[cur][i];</span><br><span class="line">            <span class="keyword">if</span>(!(--<span class="keyword">in</span>[j])) q[rear++] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> front &gt;= <span class="number">9</span>; <span class="comment">//front &lt; 9 时有环</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    char s[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, s), s[<span class="number">0</span>] != <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">                <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;g[i][j]), --g[i][j];</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;THESE WINDOWS ARE &quot;</span>);</span><br><span class="line">        <span class="title function_">puts</span>(<span class="title function_">topo</span>() ? <span class="string">&quot;CLEAN&quot;</span> : <span class="string">&quot;BROKEN&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Window Pains</p>
<p>Description<br>Boudreaux likes to multitask, especially when it comes to using his computer. Never satisfied with just running one application at a time, he usually runs nine applications, each in its own window. Due to limited screen real estate, he overlaps these windows and brings whatever window he currently needs to work with to the foreground. If his screen were a 4 x 4 grid of squares, each of Boudreaux’s windows would be represented by the following 2 x 2 windows:<br>1 1 . . 1 1 . . . . . . . . . . . 2 2 . . 2 2 . . . . . . . . . . . 3 3 . . 3 3 . . . . . . . . . . . . 4 4 . . 4 4 . . . . . . . . . . . 5 5 . . 5 5 . . . . . . . . . . . 6 6 . . 6 6 . . . . . . . . . . . . 7 7 . . 7 7 . . . . . . . . . . . 8 8 . . 8 8 . . . . . . . . . . . 9 9 . . 9 9 When Boudreaux brings a window to the foreground, all of its squares come to the top, overlapping any squares it shares with other windows. For example, if window 1 <em>and then</em>window 2 were brought to the foreground, the resulting representation would be: 1 2 2 ? 1 2 2 ? ? ? ? ? ? ? ? ? If window 4 were then brought to the foreground: 1 2 2 ? 4 4 2 ? 4 4 ? ? ? ? ? ? . . . and so on . . .<br>Unfortunately, Boudreaux’s computer is very unreliable and crashes often. He could easily tell if a crash occurred by looking at the windows and seeing a graphical representation that should not occur if windows were being brought to the foreground correctly. And this is where you come in . . .</p>
<p>Input</p>
<p>Input to this problem will consist of a (non-empty) series of up to 100 data sets. Each data set will be formatted according to the following description, and there will be no blank lines separating data sets.<br>A single data set has 3 components:</p>
<p>After the last data set, there will be a single line:<br>ENDOFINPUT<br>Note that each piece of visible window will appear only in screen areas where the window could appear when brought to the front. For instance, a 1 can only appear in the top left quadrant.</p>
<p>Output</p>
<p>For each data set, there will be exactly one line of output. If there exists a sequence of bringing windows to the foreground that would result in the graphical representation of the windows on Boudreaux’s screen, the output will be a single line with the statement:<br>THESE WINDOWS ARE CLEAN<br>Otherwise, the output will be a single line with the statement:<br>THESE WINDOWS ARE BROKEN</p>
<p>Sample Input</p>
<p>START 1 2 3 3 4 5 6 6 7 8 9 9 7 8 9 9 END START 1 1 3 3 4 1 3 3 7 7 9 9 7 7 9 9 END ENDOFINPUT</p>
<p>Sample Output</p>
<p>THESE WINDOWS ARE CLEAN THESE WINDOWS ARE BROKEN</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 10305 Ordering Tasks(拓扑排序)</title>
    <url>/posts/oj/graph/UVa%2010305%20Ordering%20Tasks(%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F)/</url>
    <content><![CDATA[<p>题意 输出n个数m组小于关系的一种可能的拓扑排序</p>
<p>应用dfs拓扑排序 访问j时 若存在i&lt;j且i没被访问 就访问i</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">105</span>;</span><br><span class="line">int n, m, t, v[N], tpo[N], g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span>(<span class="params">int j</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(v[j]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span>(g[i][j]) <span class="title function_">dfs</span>(i);</span><br><span class="line">    v[j] = <span class="number">1</span>;</span><br><span class="line">    tpo[++t] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int a, b, i;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">memset</span>(g, <span class="number">0</span>, <span class="title function_">sizeof</span>(g));</span><br><span class="line">        <span class="title function_">memset</span>(v, <span class="number">0</span>, <span class="title function_">sizeof</span>(v));</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            g[a][b] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(!v[i]) <span class="title function_">dfs</span>(i);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;%d &quot;</span>, tpo[i]);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tpo[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>John has n tasks to do. Unfortunately, the tasks are not independent and the execution of one task is only possible if other tasks have already been executed.</p>
<p><strong>Input</strong></p>
<p>The input will consist of several instances of the problem. Each instance begins with a line containing two integers, <strong>1 &lt;&#x3D; n &lt;&#x3D; 100</strong> and<strong>m</strong>. <strong>n</strong> is the number of tasks (numbered from <strong>1</strong> to <strong>n</strong>) and <strong>m</strong> is the number of direct precedence relations between tasks. After this, there will be <strong>m</strong> lines with two integers <strong>i</strong> and <strong>j</strong>, representing the fact that task <strong>i</strong> must be executed before task <strong>j</strong>. An instance with <strong>n &#x3D; m &#x3D; 0</strong>will finish the input.</p>
<p><strong>Output</strong></p>
<p>5 4 1 2 2 3 1 3 1 5 0 0</p>
<p>1 4 2 5 3</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>ZOJ 1203 Swordfish(最小生成树 kruskal)</title>
    <url>/posts/oj/graph/ZOJ%201203%20Swordfish(%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%20kruskal)/</url>
    <content><![CDATA[<p>题意 给你n个点的坐标 每个点都可与其它n-1个点相连 求这n个点的最小生成树的权重</p>
<p>裸的最小生成树 直接kruskal咯</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">105</span>, M = <span class="number">10050</span>;</span><br><span class="line">double x[N], y[N], ans;</span><br><span class="line">int n, m , par[N];</span><br><span class="line"></span><br><span class="line">struct edge &#123;</span><br><span class="line">    int u, v;</span><br><span class="line">    double w;</span><br><span class="line">&#125; e[M];</span><br><span class="line"></span><br><span class="line">bool <span class="title function_">cmp</span>(<span class="params">edge a, edge b</span>)  &#123; <span class="keyword">return</span> a.<span class="property">w</span> &lt; b.<span class="property">w</span>;&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title class_">Find</span>(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int r = x;</span><br><span class="line">    <span class="keyword">while</span>(par[r] &gt;= <span class="number">0</span>) r = par[r];</span><br><span class="line">    <span class="keyword">while</span>(x != r) <span class="comment">//压缩</span></span><br><span class="line">    &#123;</span><br><span class="line">        int tmp = par[x];</span><br><span class="line">        par[x] = r;</span><br><span class="line">        x = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title class_">Union</span>(int u, int v)</span><br><span class="line">&#123;</span><br><span class="line">    int ru = <span class="title class_">Find</span>(u), rv = <span class="title class_">Find</span>(v), tmp = par[ru] + par[rv];</span><br><span class="line">    <span class="keyword">if</span>(par[ru] &gt; par[rv])</span><br><span class="line">        par[ru] = rv, par[rv] = tmp;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        par[rv] = ru, par[ru] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">kruskal</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cur = <span class="number">0</span>, u, v;</span><br><span class="line">    <span class="title function_">memset</span>(par, -<span class="number">1</span>, <span class="title function_">sizeof</span>(par)); <span class="comment">//初始化并查集</span></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        u = e[i].<span class="property">u</span>, v = e[i].<span class="property">v</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Find</span>(u) != <span class="title class_">Find</span>(v))</span><br><span class="line">        &#123;</span><br><span class="line">            ans += e[i].<span class="property">w</span>;</span><br><span class="line">            ++cur;</span><br><span class="line">            <span class="title class_">Union</span>(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur &gt;= n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cas) <span class="title function_">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>, &amp;x[i], &amp;y[i]);</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                double dis = <span class="title function_">sqrt</span>((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]));</span><br><span class="line">                e[++m].<span class="property">u</span> = i, e[m].<span class="property">v</span> = j, e[m].<span class="property">w</span> = dis;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">sort</span>(e + <span class="number">1</span>, e + <span class="number">1</span> + m, cmp);</span><br><span class="line">        ans = <span class="number">0</span>; <span class="title function_">kruskal</span>();</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;Case #%d:\nThe minimal distance is: %.2f\n&quot;</span>, ++cas, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Swordfish    Time Limit:2 Seconds Memory Limit:65536 KB    There exists a world within our world<br>A world beneath what we call cyberspace.<br>A world protected by firewalls,<br>passwords and the most advanced<br>security systems.<br>In this world we hide<br>our deepest secrets,<br>our most incriminating information,<br>and of course, a shole lot of money.<br>This is the world of Swordfish.<br>  We all remember that in the movie Swordfish, Gabriel broke into the World Bank Investors Group in West Los Angeles, to rob $9.5 billion. And he needed Stanley, the best hacker in the world, to help him break into the password protecting the bank system. Stanley’s lovely daughter Holly was seized by Gabriel, so he had to work for him. But at the last moment, Stanley made some little trick in his hacker mission: he injected a trojan horse in the bank system, so the money would jump from one account to another account every 60 seconds, and would continue jumping in the next 10 years. Only Stanley knew when and where to get the money. If Gabriel killed Stanley, he would never get a single dollar. Stanley wanted Gabriel to release all these hostages and he would help him to find the money back.<br>You who has watched the movie know that Gabriel at last got the money by threatening to hang Ginger to death. Why not Gabriel go get the money himself? Because these money keep jumping, and these accounts are scattered in different cities. In order to gather up these money Gabriel would need to build money transfering tunnels to connect all these cities. Surely it will be really expensive to construct such a transfering tunnel, so Gabriel wants to find out the minimal total length of the tunnel required to connect all these cites. Now he asks you to write a computer program to find out the minimal length. Since Gabriel will get caught at the end of it anyway, so you can go ahead and write the program without feeling guilty about helping a criminal.<br>Input:<br>The input contains several test cases. Each test case begins with a line contains only one integer N (0 &lt;&#x3D; N &lt;&#x3D;100), which indicates the number of cities you have to connect. The next N lines each contains two real numbers X and Y(-10000 &lt;&#x3D; X,Y &lt;&#x3D; 10000), which are the citie’s Cartesian coordinates (to make the problem simple, we can assume that we live in a flat world). The input is terminated by a case with N&#x3D;0 and you must not print any output for this case.<br>Output:<br>You need to help Gabriel calculate the minimal length of tunnel needed to connect all these cites. You can saftly assume that such a tunnel can be built directly from one city to another. For each of the input cases, the output shall consist of two lines: the first line contains “Case &#x2F;#n:”, where n is the case number (starting from 1); and the next line contains “The minimal distance is: d”, where d is the minimal distance, rounded to 2 decimal places. Output a blank line between two test cases.<br>Sample Input:<br> 5 0 0 0 1 1 1 1 0 0.5 0.5 0 Sample Output:<br> Case &#x2F;#1: The minimal distance is: 2.83</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>ZOJ 1364 Machine Schedule(二分图最大匹配)</title>
    <url>/posts/oj/graph/ZOJ%201364%20Machine%20Schedule(%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D)/</url>
    <content><![CDATA[<p>题意 机器调度问题 有两个机器A，B A有n种工作模式0…n-1 B有m种工作模式0…m-1 然后又k个任务要做 每个任务可以用A机器的模式i或b机器的模式j来完成 机器开始都处于模式0 每次换模式时都要重启 问完成所有任务机器至少重启多少次</p>
<p>最基础的二分图最大匹配问题 对于每个任务把i和j之间连一条边就可以构成一个二分图 那么每个任务都可以对应一条边 那么现在就是要找最少的点 使这些点能覆盖所有的边 即点覆盖数 又因为二分图的点覆盖数 &#x3D; 匹配数 那么就是裸的求二分图最大匹配问题了 两边的点数都不超过100直接DFS增广就行了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">105</span>;</span><br><span class="line">int g[N][N], a[N], b[N], vis[N];</span><br><span class="line">int n, m, k, ans;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">dfs</span>(int i)   <span class="comment">//DFS增广</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt; m; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(g[i][j] &amp;&amp; !vis[j])</span><br><span class="line">        &#123;</span><br><span class="line">            vis[j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>( b[j] == -<span class="number">1</span> || <span class="title function_">dfs</span>(b[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//机器a的模式i与机器b的模式j匹配</span></span><br><span class="line">                a[i] = j;</span><br><span class="line">                b[j] = i;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int u, v, t;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">memset</span>(g, <span class="number">0</span>, <span class="title function_">sizeof</span>(g));</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;k);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;t, &amp;u, &amp;v);</span><br><span class="line">            g[u][v] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="title function_">memset</span>(a, -<span class="number">1</span>, <span class="title function_">sizeof</span>(a));</span><br><span class="line">        <span class="title function_">memset</span>(b, -<span class="number">1</span>, <span class="title function_">sizeof</span>(b));</span><br><span class="line">        <span class="comment">//状态0不需要重启  所以可以忽略0</span></span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == -<span class="number">1</span>)  <span class="comment">//i没被匹配 以i为起点找一条增广路</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="title function_">memset</span>(vis, <span class="number">0</span>, <span class="title function_">sizeof</span>(vis));</span><br><span class="line">                ans += <span class="title function_">dfs</span>(i);  <span class="comment">//</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Last modified :   2015-07-10 14:50</span></span><br></pre></td></tr></table></figure>
<p>  Machine Schedule    Time Limit:2 Seconds Memory Limit:65536 KB</p>
<p>As we all know, machine scheduling is a very classical problem in computer science and has been studied for a very long history. Scheduling problems differ widely in the nature of the constraints that must be satisfied and the type of schedule desired. Here we consider a 2-machine scheduling problem.<br>There are two machines A and B. Machine A has n kinds of working modes, which is called mode_0, mode_1, ��, mode_n-1, likewise machine B has m kinds of working modes, mode_0, mode_1, �� , mode_m-1. At the beginning they are both work at mode_0.<br>For k jobs given, each of them can be processed in either one of the two machines in particular mode. For example, job 0 can either be processed in machine A at mode_3 or in machine B at mode_4, job 1 can either be processed in machine A at mode_2 or in machine B at mode_4, and so on. Thus, for job i, the constraint can be represent as a triple (i, x, y), which means it can be processed either in machine A at mode_x, or in machine B at mode_y.<br>Obviously, to accomplish all the jobs, we need to change the machine’s working mode from time to time, but unfortunately, the machine’s working mode can only be changed by restarting it manually. By changing the sequence of the jobs and assigning each job to a suitable machine, please write a program to minimize the times of restarting machines.</p>
<p><strong>Input</strong><br>The input file for this program consists of several configurations. The first line of one configuration contains three positive integers: n, m (n, m &lt; 100) and k (k &lt; 1000). The following k lines give the constrains of the k jobs, each line is a triple: i, x, y.<br>The input will be terminated by a line containing a single zero.</p>
<p><strong>Output</strong><br>The output should be one integer per line, which means the minimal times of restarting machine.</p>
<p><strong>Sample Input</strong></p>
<p>5 5 10<br>0 1 1<br>1 1 2<br>2 1 3<br>3 1 4<br>4 2 1<br>5 2 2<br>6 2 3<br>7 2 4<br>8 3 3<br>9 4 3<br>0</p>
<p><strong>Sample Output</strong></p>
<p>3</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>ZOJ 1586 QS Network(最小生成树 prim)</title>
    <url>/posts/oj/graph/ZOJ%201586%20QS%20Network(%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%20prim)/</url>
    <content><![CDATA[<p>题意 输入n 然后输入n个数 代表连接时每个站点自身的消耗 然后输入n&#x2F;*n的矩阵 第i行第j列的数代表第i个站点和第j个站点之间路上的花费 链接i,j两个节点的总花费为两站点自身花费加上路上的花费 求⑩这n个站点连通的最小总花费</p>
<p>又是裸的最小生成树 给点的就用prim咯</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1005</span>;</span><br><span class="line">int cost[N], mat[N][N], a[N], n, ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">prim</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">memset</span>(cost, <span class="number">0x3f</span>, <span class="title function_">sizeof</span>(cost));</span><br><span class="line">    cost[<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//cost[i]为把第i个节点加入到最小生成树的最小花费,-1代表已经加入</span></span><br><span class="line">    int cur = <span class="number">1</span>, next = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//cur为当前加入到最小生成树中的节点</span></span><br><span class="line">    <span class="comment">//next为下一个应该加入最小生成树的节点</span></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cost[j] == -<span class="number">1</span> || j == cur) <span class="keyword">continue</span>;</span><br><span class="line">            cost[j] = <span class="title function_">min</span>(cost[j], mat[cur][j]);</span><br><span class="line">            <span class="keyword">if</span>(cost[j] &lt; cost[next]) next = j;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += cost[next];</span><br><span class="line">        cur = next, cost[cur] = -<span class="number">1</span>, next = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas, t;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span>(cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">                mat[i][j] = a[i] + a[j] + t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="number">0</span>;  <span class="title function_">prim</span>();</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  QS Network    Time Limit:2 Seconds Memory Limit:65536 KB</p>
<h2 id="Sunny-Cup-2003-Preliminary-Round"><a href="#Sunny-Cup-2003-Preliminary-Round" class="headerlink" title="Sunny Cup 2003 - Preliminary Round"></a>Sunny Cup 2003 - Preliminary Round</h2><p>April 20th, 12:00 - 17:00</p>
<p>In the planet w-503 of galaxy cgb, there is a kind of intelligent creature named QS. QScommunicate with each other via networks. If two QS want to get connected, they need to buy two network adapters (one for each QS) and a segment of network cable. Please be advised that ONE NETWORK ADAPTER CAN ONLY BE USED IN A SINGLE CONNECTION.(ie. if a QS want to setup four connections, it needs to buy four adapters). In the procedure of communication, a QS broadcasts its message to all the QS it is connected with, the group of QS who receive the message broadcast the message to all the QS they connected with, the procedure repeats until all the QS’s have received the message.</p>
<p>A sample is shown below:</p>
<p><img src="/../images/cn-onlinejudge-showImage.do-name=0000/1586/1586.gif.png"></p>
<p>A sample QS network, and QS A want to send a message.<br>Step 1. QS A sends message to QS B and QS C;<br>Step 2. QS B sends message to QS A ; QS C sends message to QS A and QS D;<br>Step 3. the procedure terminates because all the QS received the message.</p>
<p>Each QS has its favorate brand of network adapters and always buys the brand in all of its connections. Also the distance between QS vary. Given the price of each QS’s favorate brand of network adapters and the price of cable between each pair of QS, your task is to write a program to determine the minimum cost to setup a QS network.</p>
<p><strong>Input</strong></p>
<p>The 1st line of the input contains an integer t which indicates the number of data sets.<br>From the second line there are t data sets.<br>In a single data set,the 1st line contains an interger n which indicates the number of QS.<br>The 2nd line contains n integers, indicating the price of each QS’s favorate network adapter.<br>In the 3rd line to the n+2th line contain a matrix indicating the price of cable between ecah pair of QS.</p>
<p>Constrains:</p>
<p>all the integers in the input are non-negative and not more than 1000.</p>
<p><strong>Output</strong></p>
<p>for each data set,output the minimum cost in a line. NO extra empty lines needed.</p>
<p><strong>Sample Input</strong></p>
<p>1<br>3<br>10 20 30<br>0 100 200<br>100 0 300<br>200 300 0</p>
<p><strong>Sample Output</strong></p>
<p>370</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>ZOJ 1649 Rescue(有敌人迷宫BFS)</title>
    <url>/posts/oj/graph/ZOJ%201649%20Rescue(%E6%9C%89%E6%95%8C%E4%BA%BA%E8%BF%B7%E5%AE%ABBFS)/</url>
    <content><![CDATA[<p>题意 求迷宫中从a的位置到r的位置需要的最少时间 经过’.’方格需要1s 经过‘x’方格需要两秒 ‘&#x2F;#’表示墙</p>
<p>由于有1s和2s两种情况 需要在基础迷宫bfs上加些判断</p>
<p>令到达每个点的时间初始为无穷大 当从一个点到达该点用的时间比他本来的时间小时 更新这个点的时间并将这个点入队 扫描完全图就得到答案咯</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">205</span>;</span><br><span class="line">char mat[N][N];</span><br><span class="line">int time[N][N], sx, sy;</span><br><span class="line">int dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">int dy[<span class="number">4</span>] = &#123; -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">struct grid</span><br><span class="line">&#123;</span><br><span class="line">    int x, y;</span><br><span class="line">    <span class="title function_">grid</span>(int xx = <span class="number">0</span>, int yy = <span class="number">0</span>): <span class="title function_">x</span>(xx), <span class="title function_">y</span>(<span class="params">yy</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">bfs</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">memset</span>(time, <span class="number">0x3f</span>, <span class="title function_">sizeof</span>(time));</span><br><span class="line">    time[sx][sy] = <span class="number">0</span>;</span><br><span class="line">    queue&lt;grid&gt; g;</span><br><span class="line">    g.<span class="title function_">push</span>(<span class="title function_">grid</span>(sx, sy));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!g.<span class="title function_">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        grid cur = g.<span class="title function_">front</span>();</span><br><span class="line">        g.<span class="title function_">pop</span>();</span><br><span class="line">        int cx = cur.<span class="property">x</span>, cy = cur.<span class="property">y</span>, ct = time[cx][cy];</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            int nx = cx + dx[i], ny = cy + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(mat[nx][ny] &amp;&amp; mat[nx][ny] != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                int tt = ct + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(mat[cx][cy] == <span class="string">&#x27;x&#x27;</span>) ++tt;</span><br><span class="line">                <span class="keyword">if</span>(tt &lt; time[nx][ny])</span><br><span class="line">                &#123;</span><br><span class="line">                    time[nx][ny] = tt;</span><br><span class="line">                    g.<span class="title function_">push</span>(<span class="title function_">grid</span>(nx, ny));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, m, ex, ey;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">memset</span>(mat, <span class="number">0</span>, <span class="title function_">sizeof</span>(mat));</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, mat[i] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">                <span class="keyword">if</span>(mat[i][j] == <span class="string">&#x27;a&#x27;</span>) sx = i, sy = j;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(mat[i][j] == <span class="string">&#x27;r&#x27;</span>) ex = i, ey = j;</span><br><span class="line">        <span class="title function_">bfs</span>();</span><br><span class="line">        <span class="keyword">if</span>(time[ex][ey] != time[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, time[ex][ey]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;Poor ANGEL has to stay in the prison all his life.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>ZOJ 2110 Tempter of the Bone(条件迷宫DFS,HDU1010)</title>
    <url>/posts/oj/graph/ZOJ%202110%20Tempter%20of%20the%20Bone(%E6%9D%A1%E4%BB%B6%E8%BF%B7%E5%AE%ABDFS,HDU1010)/</url>
    <content><![CDATA[<p>题意 一只狗要逃离迷宫 可以往上下左右4个方向走 每走一步耗时1s 每个格子只能走一次且迷宫的门只在t时刻打开一次 问狗是否有可能逃离这个迷宫</p>
<p>直接DFS 直道找到满足条件的路径 或者走完所有可能路径都不满足</p>
<p>注意剪枝 当前位置为(r,c) 终点为(ex,ey) 剩下的时间为lt 当前点到终点的直接距离为 d&#x3D;(ex-r)+(ey-c) 若多走的时间rt&#x3D;lt-d&lt;0 或为奇数时 肯定是不可能的 可以自己在纸上画一下 每个点只能走一次的图 走弯路的话多走的步数一定为偶数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">int dy[<span class="number">4</span>] = &#123; -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">10</span>;</span><br><span class="line">char mat[N][N];</span><br><span class="line">bool ans;</span><br><span class="line">int t, sx, sy, ex, ey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span>(<span class="params">int r, int c, int lt</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(mat[r][c] == <span class="string">&#x27;D&#x27;</span> &amp;&amp; lt == <span class="number">0</span>||ans)  <span class="comment">//满足条件或已经满足条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    char tc=mat[r][c];  <span class="comment">//保存原来的可能值 有&#x27;D&#x27;和&#x27;.&#x27;两种情况</span></span><br><span class="line">    mat[r][c] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    int rt = lt - <span class="title function_">abs</span>(ex - r) - <span class="title function_">abs</span>(ey - c);  <span class="comment">//比直线到达终点多用的时间</span></span><br><span class="line">    <span class="keyword">if</span>(rt &gt;= <span class="number">0</span> &amp;&amp; rt % <span class="number">2</span> == <span class="number">0</span>)   <span class="comment">//剪枝</span></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)   <span class="comment">//4个方向走</span></span><br><span class="line">    &#123;</span><br><span class="line">        int x = r + dx[i], y = c + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(mat[x][y] == <span class="string">&#x27;.&#x27;</span> || mat[x][y] == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">            <span class="title function_">dfs</span>(x, y, lt - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mat[r][c] = tc;  <span class="comment">//恢复原状</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;t), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, mat[i] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(mat[i][j] == <span class="string">&#x27;S&#x27;</span>) sx = i, sy = j;</span><br><span class="line">                <span class="keyword">if</span>(mat[i][j] == <span class="string">&#x27;D&#x27;</span>) ex = i, ey = j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        ans = <span class="literal">false</span>;</span><br><span class="line">        <span class="title function_">dfs</span>(sx, sy, t);</span><br><span class="line">        <span class="title function_">printf</span>(ans ? <span class="string">&quot;YES\n&quot;</span> : <span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  Tempter of the Bone    Time Limit:2 Seconds Memory Limit:65536 KB</p>
<p>The doggie found a bone in an ancient maze, which fascinated him a lot. However, when he picked it up, the maze began to shake, and the doggie could feel the ground sinking. He realized that the bone was a trap, and he tried desperately to get out of this maze.<br>The maze was a rectangle with sizes N by M. There was a door in the maze. At the beginning, the door was closed and it would open at the T-th second for a short period of time (less than 1 second). Therefore the doggie had to arrive at the door on exactly the T-th second. In every second, he could move one block to one of the upper, lower, left and right neighboring blocks. Once he entered a block, the ground of this block would start to sink and disappear in the next second. He could not stay at one block for more than one second, nor could he move into a visited block. Can the poor doggie survive? Please help him.</p>
<p><strong>Input</strong><br>The input consists of multiple test cases. The first line of each test case contains three integers N, M, and T (1 &lt; N, M &lt; 7; 0 &lt; T &lt; 50), which denote the sizes of the maze and the time at which the door will open, respectively. The next N lines give the maze layout, with each line containing M characters. A character is one of the following:<br>‘X’: a block of wall, which the doggie cannot enter;<br>‘S’: the start point of the doggie;<br>‘D’: the Door; or<br>‘.’: an empty block.<br>The input is terminated with three 0’s. This test case is not to be processed.</p>
<p><strong>Output</strong><br>For each test case, print in one line “YES” if the doggie can survive, or “NO” otherwise.</p>
<p><strong>Sample Input</strong><br>4 4 5<br>S.X.<br>..X.<br>..XD<br>….<br>3 4 5<br>S.X.<br>..X.<br>…D<br>0 0 0</p>
<p><strong>Sample Output</strong><br>NO<br>YES</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>ZOJ 2412 Farm Irrigation(DFS 条件连通块)</title>
    <url>/posts/oj/graph/ZOJ%202412%20Farm%20Irrigation(DFS%20%E6%9D%A1%E4%BB%B6%E8%BF%9E%E9%80%9A%E5%9D%97)/</url>
    <content><![CDATA[<p>题意 两块农田里面的管道可以直接连接的话 他们就可以共用一个水源 有11种农田 上面的管道位置是一定的 给你一个农田矩阵 问至少需要多少水源</p>
<p>DFS的连通块问题 两个相邻农田的管道可以直接连接的话他们就属于一个连通块 题目就是求连通块个数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">55</span>;</span><br><span class="line">char mat[N][N];</span><br><span class="line">int type[<span class="number">11</span>][<span class="number">4</span>] = &#123;   <span class="comment">//对应11种水管类型 按顺时针方向有管道的为1否则为0</span></span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">dfs</span>(<span class="params">int r, int c</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cur = mat[r][c] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(cur &lt; <span class="number">0</span> || cur &gt; <span class="number">10</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    mat[r][c] = <span class="number">0</span>;           <span class="comment">//标记已经访问 0-&#x27;A&#x27;是小于0的</span></span><br><span class="line">    int up = mat[r - <span class="number">1</span>][c] - <span class="string">&#x27;A&#x27;</span>, dw = mat[r + <span class="number">1</span>][c] - <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">        le = mat[r][c - <span class="number">1</span>] - <span class="string">&#x27;A&#x27;</span>, ri = mat[r][c + <span class="number">1</span>] - <span class="string">&#x27;A&#x27;</span>;  <span class="comment">//4个相邻块的管道类型</span></span><br><span class="line">    <span class="keyword">if</span>(up &gt; -<span class="number">1</span> &amp;&amp; up &lt; <span class="number">11</span> &amp;&amp; type[up][<span class="number">2</span>] &amp;&amp; type[cur][<span class="number">0</span>])  <span class="title function_">dfs</span>(r - <span class="number">1</span>, c);</span><br><span class="line">    <span class="keyword">if</span>(dw &gt; -<span class="number">1</span> &amp;&amp; dw &lt; <span class="number">11</span> &amp;&amp; type[dw][<span class="number">0</span>] &amp;&amp; type[cur][<span class="number">2</span>])  <span class="title function_">dfs</span>(r + <span class="number">1</span>, c);</span><br><span class="line">    <span class="keyword">if</span>(le &gt; -<span class="number">1</span> &amp;&amp; le &lt; <span class="number">11</span> &amp;&amp; type[le][<span class="number">1</span>] &amp;&amp; type[cur][<span class="number">3</span>])  <span class="title function_">dfs</span>(r, c - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ri &gt; -<span class="number">1</span> &amp;&amp; ri &lt; <span class="number">11</span> &amp;&amp; type[ri][<span class="number">3</span>] &amp;&amp; type[cur][<span class="number">1</span>])  <span class="title function_">dfs</span>(r, c + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;     <span class="comment">//一个连通块中只有一个返回1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, m, ans;</span><br><span class="line">    <span class="keyword">while</span> (<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m), n &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="title function_">memset</span>(mat, <span class="number">0</span>, <span class="title function_">sizeof</span>(mat));</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, mat[i] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">                ans += <span class="title function_">dfs</span>(i, j);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Farm Irrigation    Time Limit:2 Seconds Memory Limit:65536 KB</p>
<p>Benny has a spacious farm land to irrigate. The farm land is a rectangle, and is divided into a lot of samll squares. Water pipes are placed in these squares. Different square has a different type of pipe. There are 11 types of pipes, which is marked from A to K, as Figure 1 shows.<br><img src="/../images/cn-onlinejudge-showImage.do-name=0000/2412/1.gif.png"><br>Figure 1</p>
<p>Benny has a map of his farm, which is an array of marks denoting the distribution of water pipes over the whole farm. For example, if he has a map</p>
<p>ADC FJK IHE then the water pipes are distributed like  <img src="/../images/cn-onlinejudge-showImage.do-name=0000/2412/2.gif.png"><br>Figure 2</p>
<p>Several wellsprings are found in the center of some squares, so water can flow along the pipes from one square to another. If water flow crosses one square, the whole farm land in this square is irrigated and will have a good harvest in autumn.</p>
<p>Now Benny wants to know at least how many wellsprings should be found to have the whole farm land irrigated. Can you help him?</p>
<p>Note: In the above example, at least 3 wellsprings are needed, as those red points in Figure 2 show.<br>Input</p>
<p>There are several test cases! In each test case, the first line contains 2 integers M and N, then M lines follow. In each of these lines, there are N characters, in the range of ‘A’ to ‘K’, denoting the type of water pipe over the corresponding square. A negative M or N denotes the end of input, else you can assume 1 &lt;&#x3D; M, N &lt;&#x3D; 50.</p>
<p><strong>Output</strong></p>
<p>For each test case, output in one line the least number of wellsprings needed.</p>
<p><strong>Sample Input</strong><br>2 2 DK HF 3 3 ADC FJK IHE -1 -1 Sample Output 2 3</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>ZOJ 2913 Bus Pass (最近的最远BFS HDU2377)</title>
    <url>/posts/oj/graph/ZOJ%202913%20Bus%20Pass%20(%E6%9C%80%E8%BF%91%E7%9A%84%E6%9C%80%E8%BF%9CBFS%20HDU2377)/</url>
    <content><![CDATA[<p>题意 在所有城市中找一个中心满足这个中心到所有公交站点距离的最大值最小 输出最小距离和满足最小距离编号最小的中心</p>
<p>最基础的BFS 对每个公交站点BFS dis[i]表示编号为i的点到所有公交站点距离的最大值 bfs完所有站点后 dis[i]最小的点就是要求的点咯</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef set&lt;int&gt;::iterator it;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">10000</span>;</span><br><span class="line">int dis[N], tdis[N], link[N][<span class="number">12</span>];</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">set&lt;int&gt; zone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">bfs</span>(<span class="params">int o</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">memset</span>(tdis, <span class="number">0</span>, <span class="title function_">sizeof</span>(tdis));</span><br><span class="line">    tdis[o] = <span class="number">1</span>;</span><br><span class="line">    q.<span class="title function_">push</span>(o);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="title function_">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        int cur = q.<span class="title function_">front</span>();</span><br><span class="line">        q.<span class="title function_">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(tdis[cur] &gt; dis[cur]) dis[cur] = tdis[cur];</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= link[cur][<span class="number">0</span>]; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            int j = link[cur][i];</span><br><span class="line">            <span class="keyword">if</span>(tdis[j] == <span class="number">0</span>)  q.<span class="title function_">push</span>(j), tdis[j] = tdis[cur] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas, nz, nr, id, mz, mr, ans, t;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span>(cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        zone.<span class="title function_">clear</span>();</span><br><span class="line">        <span class="title function_">memset</span>(dis, <span class="number">0</span>, <span class="title function_">sizeof</span>(dis));</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;nz, &amp;nr);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= nz; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;id, &amp;mz);</span><br><span class="line">            link[id][<span class="number">0</span>] = mz;</span><br><span class="line">            zone.<span class="title function_">insert</span>(id);</span><br><span class="line">            <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= mz; ++i)</span><br><span class="line">                <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;link[id][i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= nr; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;mr);</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= mr; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">                <span class="title function_">bfs</span>(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        it i = zone.<span class="title function_">begin</span>();</span><br><span class="line">        ans = *i;</span><br><span class="line">        <span class="keyword">for</span>(++i; i != zone.<span class="title function_">end</span>(); ++i)</span><br><span class="line">            <span class="keyword">if</span>(dis[*i] &lt; dis[ans]) ans = *i;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, dis[ans], ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  Bus Pass    Time Limit:5 Seconds Memory Limit:32768 KB</p>
<p>You travel a lot by bus and the costs of all the seperate tickets are starting to add up.</p>
<p>Therefore you want to see if it might be advantageous for you to buy a bus pass.</p>
<p>The way the bus system works in your country (and also in the Netherlands) is as follows:</p>
<p>when you buy a bus pass, you have to indicate a center zone and a star value. You are allowed to travel freely in any zone which has a distance to your center zone which is less than your star value. For example, if you have a star value of one, you can only travel in your center zone. If you have a star value of two, you can also travel in all adjacent zones, et cetera.</p>
<p>You have a list of all bus trips you frequently make, and would like to determine the minimum star value you need to make all these trips using your buss pass. But this is not always an easy task. For example look at the following figure:</p>
<p><img src="/../images/cn-onlinejudge-showImage.do-name=0000/2913/Bus_Pass_1.jpg.png"><br>Here you want to be able to travel from A to B and from B to D. The best center zone is 7400, for which you only need a star value of 4. Note that you do not even visit this zone on your trips!</p>
<p><strong>Input</strong></p>
<p>On the first line an integer<em>t</em>(1 &lt;&#x3D;<em>t</em>&lt;&#x3D; 100): the number of test cases. Then for each test case:</p>
<p>One line with two integers<em>nz</em>(2 &lt;&#x3D;<em>nz</em>&lt;&#x3D; 9 999) and<em>nr</em>(1 &lt;&#x3D;<em>nr</em>&lt;&#x3D; 10): the number of zones and the number of bus trips, respectively.</p>
<p><em>nz</em> lines starting with two integers <em>idi</em> (1 &lt;&#x3D; idi &lt;&#x3D; 9 999) and <em>mzi</em> (1 &lt;&#x3D; <em>mzi</em> &lt;&#x3D; 10), a number identifying the i-th zone and the number of zones adjacent to it, followed by mzi integers: the numbers of the adjacent zones.</p>
<p><em>nr</em> lines starting with one integer <em>mri</em> (1 &lt;&#x3D; <em>mri</em> &lt;&#x3D; 20), indicating the number of zones the ith bus trip visits, followed by <em>mri</em> integers: the numbers of the zones through which the bus passes in the order in which they are visited.</p>
<p>All zones are connected, either directly or via other zones.</p>
<p><strong>Output</strong></p>
<p>For each test case:</p>
<p>One line with two integers, the minimum star value and the id of a center zone which achieves this minimum star value. If there are multiple possibilities, choose the zone with the lowest number.</p>
<p><strong>Sample Input</strong></p>
<p>1<br>17 2<br>7400 6 7401 7402 7403 7404 7405 7406<br>7401 6 7412 7402 7400 7406 7410 7411<br>7402 5 7412 7403 7400 7401 7411<br>7403 6 7413 7414 7404 7400 7402 7412<br>7404 5 7403 7414 7415 7405 7400<br>7405 6 7404 7415 7407 7408 7406 7400<br>7406 7 7400 7405 7407 7408 7409 7410 7401<br>7407 4 7408 7406 7405 7415<br>7408 4 7409 7406 7405 7407<br>7409 3 7410 7406 7408<br>7410 4 7411 7401 7406 7409<br>7411 5 7416 7412 7402 7401 7410<br>7412 6 7416 7411 7401 7402 7403 7413<br>7413 3 7412 7403 7414<br>7414 3 7413 7403 7404<br>7415 3 7404 7405 7407<br>7416 2 7411 7412<br>5 7409 7408 7407 7405 7415<br>6 7415 7404 7414 7413 7412 7416</p>
<p><strong>Sample Output</strong></p>
<p>4 7400</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 17A Noldbach problem(数学)</title>
    <url>/posts/oj/math/Codeforces%2017A%20Noldbach%20problem(%E6%95%B0%E5%AD%A6)/</url>
    <content><![CDATA[<p>题意 求n以内等于两个连续素数的和加上1的数的个数 n不大于1000</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;  </span><br><span class="line">#include&lt;cmath&gt;  </span><br><span class="line">#include&lt;algorithm&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1000</span>;  </span><br><span class="line">int n, k, ans;  </span><br><span class="line">bool isPrime (int a)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">2</span>; i &lt;= sqrt (a); ++i)  </span><br><span class="line">        <span class="keyword">if</span> (a % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    int ai = <span class="number">1</span>, bi = <span class="number">0</span>, a[N], b[N];  </span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">2</span>;  </span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">3</span>; i &lt;= N; ++i)  </span><br><span class="line">        <span class="keyword">if</span> (isPrime (i))  </span><br><span class="line">        &#123;  </span><br><span class="line">            a[++ai] = i;  </span><br><span class="line">            b[++bi] = a[ai] + a[ai - <span class="number">1</span>] + <span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);  </span><br><span class="line">    ans = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">13</span>; i &lt;= n; ++i)  </span><br><span class="line">        <span class="keyword">if</span> (isPrime (i) &amp;&amp; find (b + <span class="number">1</span>, b + bi + <span class="number">1</span>, i) != b + bi + <span class="number">1</span>)  </span><br><span class="line">            ans++;  </span><br><span class="line">    <span class="keyword">if</span> (ans &gt;= k) printf (<span class="string">&quot;YES\n&quot;</span>);  </span><br><span class="line">    <span class="keyword">else</span> printf (<span class="string">&quot;NO\n&quot;</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Nick is interested in prime numbers. Once he read about Goldbach problem. It states that every even integer greater than 2 can be expressed as the sum of two primes. That got Nick’s attention and he decided to invent a problem of his own and call it Noldbach problem. Since Nick is interested only in prime numbers, Noldbach problem states that at least <em>k</em> prime numbers from 2 to <em>n</em> inclusively can be expressed as the sum of three integer numbers: two neighboring prime numbers and 1. For example, 19 &#x3D; 7 + 11 + 1, or 13 &#x3D;5 + 7 + 1.</p>
<p>Two prime numbers are called neighboring if there are no other prime numbers between them.</p>
<p>You are to help Nick, and find out if he is right or wrong.<br>Input</p>
<p>The first line of the input contains two integers <em>n</em> (2 ≤ <em>n</em> ≤ 1000) and <em>k</em> (0 ≤ <em>k</em> ≤ 1000).</p>
<p>Output</p>
<p>Output YES if at least <em>k</em> prime numbers from 2 to <em>n</em> inclusively can be expressed as it was described above. Otherwise output NO.<br>Sample test(s)</p>
<p>input 27 2</p>
<p>output YES<br>input 45 7</p>
<p>output NO</p>
<p>Note</p>
<p>In the first sample the answer is YES since at least two numbers can be expressed as it was described (for example, 13 and 19). In the second sample the answer is NO since it is impossible to express 7 prime numbers from 2 to 45 in the desired form.</p>
<p>﻿﻿</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 535C Tavas and Karafs(二分)</title>
    <url>/posts/oj/math/Codeforces%20535C%20Tavas%20and%20Karafs(%E4%BA%8C%E5%88%86)/</url>
    <content><![CDATA[<p>题意 有一个等差数列 从A开始 公差为B然后n个询问 每个询问给定l,t,m然后要求如果每次可以最多选择m个数 使这m个数-1 那么在t次操作中可以使l为左端点的最长序列中使所有数为0 输出这个最长序列的右端序号</p>
<p>定理 序列h1,h2,…,hn 可以在t次时间内(每次至多让m个元素减少1) 全部减小为0 当且仅当</p>
<p>*<em>max(h1, h2, …, hn) &lt;&#x3D; t &amp;&amp; h1 + h2 + … + hn &lt;&#x3D; m&#x2F;<em>t</em></em></p>
<p>那么就可以二分右端点来解决了 下限为l 上限为hi不超过t的最大i</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">typedef long long <span class="variable constant_">LL</span>;</span><br><span class="line"><span class="variable constant_">LL</span> a, b, n, l, t, m;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">LL</span> <span class="title function_">getv</span>(<span class="params">LL p</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + (p - <span class="number">1</span>) * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">LL</span> <span class="title function_">getsum</span>(<span class="params">LL r</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="title function_">getv</span>(r) + <span class="title function_">getv</span>(l)) * (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;a, &amp;b, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;l, &amp;t, &amp;m);</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_">getv</span>(l) &gt; t) <span class="title function_">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="variable constant_">LL</span> le = l, ri = (t - a) / b + <span class="number">1</span>, mid;</span><br><span class="line">            <span class="keyword">while</span>(le &lt;= ri)</span><br><span class="line">            &#123;</span><br><span class="line">                mid = (ri + le) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="title function_">getsum</span>(mid) &lt;= t * m) le = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> ri = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, le - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C. Tavas and Karafs</p>
<p>Karafs is some kind of vegetable in shape of an 1 × <em>h</em> rectangle. Tavaspolis people love Karafs and they use Karafs in almost any kind of food. Tavas, himself, is crazy about Karafs.<br><img src="/../images/eforces.com-ea42fba30e24759438ea5bbfb0a4e6db9fa0050f-.png"></p>
<p>Each Karafs has a positive integer height. Tavas has an infinite 1-based sequence of Karafses. The height of the <em>i</em>-th Karafs is <em>s**i</em> &#x3D; <em>A</em> + (<em>i</em> - 1) × <em>B</em>.</p>
<p>For a given <em>m</em>, let’s define an <em>m</em>-bite operation as decreasing the height of at most <em>m</em> distinct not eaten Karafses by 1. Karafs is considered as eaten when its height becomes zero.</p>
<p>Now SaDDas asks you <em>n</em> queries. In each query he gives you numbers <em>l</em>, <em>t</em> and <em>m</em> and you should find the largest number <em>r</em> such that <em>l</em> ≤ <em>r</em>and sequence <em>s**l</em>, <em>s**l</em> + 1, …, <em>s**r</em> can be eaten by performing <em>m</em>-bite no more than <em>t</em> times or print -1 if there is no such number <em>r</em>.<br>Input</p>
<p>The first line of input contains three integers <em>A</em>, <em>B</em> and <em>n</em> (1 ≤ <em>A</em>, <em>B</em> ≤ 106, 1 ≤ <em>n</em> ≤ 105).</p>
<p>Next <em>n</em> lines contain information about queries. <em>i</em>-th line contains integers <em>l</em>, <em>t</em>, <em>m</em> (1 ≤ <em>l</em>, <em>t</em>, <em>m</em> ≤ 106) for <em>i</em>-th query.</p>
<p>Output</p>
<p>For each query, print its answer in a single line.<br>Sample test(s)</p>
<p>input 2 1 4 1 5 3 3 3 10 7 10 2 6 4 8</p>
<p>output 4 -1 8 -1<br>input 1 5 2 1 5 10 2 7 4</p>
<p>output 1 2</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1286 找新朋友(欧拉函数)</title>
    <url>/posts/oj/math/HDU%201286%20%E6%89%BE%E6%96%B0%E6%9C%8B%E5%8F%8B(%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0)/</url>
    <content><![CDATA[<p>题意 中文 就是求小于等于n的数中有多少个和n互质 即欧拉函数值</p>
<p>div[i] 表示i的最小质因数 eul[i]存储i的欧拉函数值</p>
<p>求欧拉函数的方法:</p>
<p>1.eul[1]&#x3D;1;</p>
<ol start="2">
<li><p>若i&#x3D;&#x3D;p^k (p是素数)eul[i]&#x3D;(p-1)&#x2F;*p^(k-1);</p>
</li>
<li><p>若m,n互质, eul[m&#x2F;*n]&#x3D;eul[m]&#x2F;*eul[n];</p>
</li>
</ol>
<p>可以推出欧拉函数的递推式</p>
<p>若(i&#x2F;div[i])%div[i]&#x3D;&#x3D;0 则 eul[i]&#x3D;eul[i&#x2F;div[i]]&#x2F;<em>div[i]否则eul[i]&#x3D;eul[i&#x2F;div[i]]&#x2F;</em>(div[i] -1)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">33000</span>;</span><br><span class="line">int div[N], eul[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">geneuller</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; N; ++i)   div[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">2</span>; i * i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(div[i] == i)</span><br><span class="line">            <span class="keyword">for</span>(int j = i * i; j &lt; N; j += i) div[j] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    eul[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">2</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        eul[i] = eul[i / div[i]];</span><br><span class="line">        <span class="keyword">if</span>((i / div[i]) % div[i] == <span class="number">0</span>) eul[i] *= div[i];</span><br><span class="line">        <span class="keyword">else</span> eul[i] *= div[i] - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas, n;</span><br><span class="line">    <span class="title function_">geneuller</span>();</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span>(cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, eul[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="找新朋友"><a href="#找新朋友" class="headerlink" title="找新朋友"></a>找新朋友</h1><p>Problem Description</p>
<p>新年快到了，“猪头帮协会”准备搞一个聚会，已经知道现有会员N人，把会员从1到N编号，其中会长的号码是N号，凡是和会长是老朋友的，那么该会员的号码肯定和N有大于1的公约数，否则都是新朋友，现在会长想知道究竟有几个新朋友？请你编程序帮会长计算出来。<br>Input</p>
<p>第一行是测试数据的组数CN（Case number，1&lt;CN&lt;10000），接着有CN行正整数N（1&lt;n&lt;32768），表示会员人数。<br>Output</p>
<p>对于每一个N，输出一行新朋友的人数，这样共有CN行输出。<br>Sample Input</p>
<p>2 25608 24027<br>Sample Output</p>
<p>7680 16016</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 2095 find your present(异或)</title>
    <url>/posts/oj/math/HDU%202095%20find%20your%20present(%E5%BC%82%E6%88%96)/</url>
    <content><![CDATA[<p>题意 求一组数中只出现过奇数次的数 输入保证只有一个数满足</p>
<p>知道一个数与自己的异或等于0 与0的异或等于自己就行咯</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, t, ans;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">            ans = ans ^ t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="find-your-present-2"><a href="#find-your-present-2" class="headerlink" title="find your present (2)"></a>find your present (2)</h1><p>Problem Description</p>
<p>In the new year party, everybody will get a “special present”.Now it’s your turn to get your special present, a lot of presents now putting on the desk, and only one of them will be yours.Each present has a card number on it, and your present’s card number will be the one that different from all the others, and you can assume that only one number appear odd times.For example, there are 5 present, and their card numbers are 1, 2, 3, 2, 1.so your present will be the one with the card number of 3, because 3 is the number that different from all the others.<br>Input</p>
<p>The input file will consist of several cases.<br>Each case will be presented by an integer n (1&lt;&#x3D;n&lt;1000000, and n is odd) at first. Following that, n positive integers will be given in a line, all integers will smaller than 2^31. These numbers indicate the card numbers of the presents.n &#x3D; 0 ends the input.<br>Output</p>
<p>For each case, output an integer in a line, which is the card number of your present.<br>Sample Input</p>
<p>5 1 1 3 2 2 3 1 2 1 0<br>Sample Output</p>
<p>3 2</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 3714 Error Curves(3分)</title>
    <url>/posts/oj/math/HDU%203714%20Error%20Curves(3%E5%88%86)/</url>
    <content><![CDATA[<p>题意 求分段函数的最低点 每个点函数值为n个 a&#x2F;*x^2 + b&#x2F;*x +c (a&gt;&#x3D;0, |b|&lt;5000, |c|&lt;5000) 函数的最大值</p>
<p>由于a是不小于0的 所以此分段函数的函数图像只可能是类似’V’形的 可以画图观察出来 那么求最小值就可以用三分来解决了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">const</span> double eps = <span class="number">1e-9</span>;</span><br><span class="line">int a[N], b[N], c[N], n;</span><br><span class="line"></span><br><span class="line">double <span class="title function_">getr</span>(<span class="params">double x</span>)</span><br><span class="line">&#123;</span><br><span class="line">    double r = a[<span class="number">0</span>] * x * x + b[<span class="number">0</span>] * x + c[<span class="number">0</span>], t;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t = a[i] * x * x + b[i] * x + c[i];</span><br><span class="line">        <span class="keyword">if</span>(t &gt; r) r = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span>(cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a[i], &amp;b[i], &amp;c[i]);</span><br><span class="line"></span><br><span class="line">        double l = <span class="number">0</span>, r = <span class="number">1000</span>, m, mm;</span><br><span class="line">        <span class="keyword">while</span>(l + eps &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            mm = (m + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_">getr</span>(m) &lt; <span class="title function_">getr</span>(mm)) r = mm;</span><br><span class="line">            <span class="keyword">else</span> l = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%.4f\n&quot;</span>, <span class="title function_">getr</span>(l));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Error-Curves"><a href="#Error-Curves" class="headerlink" title="Error Curves"></a>Error Curves</h1><p>Problem Description</p>
<p>Josephina is a clever girl and addicted to Machine Learning recently. She<br>pays much attention to a method called Linear Discriminant Analysis, which<br>has many interesting properties.<br>In order to test the algorithm’s efficiency, she collects many datasets.<br>What’s more, each data is divided into two parts: training data and test<br>data. She gets the parameters of the model on training data and test the<br>model on test data. To her surprise, she finds each dataset’s test error curve is just a parabolic curve. A parabolic curve corresponds to a quadratic function. In mathematics, a quadratic function is a polynomial function of the form f(x) &#x3D; ax2 + bx + c. The quadratic will degrade to linear function if a &#x3D; 0.<br>  <img src="/../images/cn-data-images-3714-1.jpg.png">  It’s very easy to calculate the minimal error if there is only one test error curve. However, there are several datasets, which means Josephina will obtain many parabolic curves. Josephina wants to get the tuned parameters that make the best performance on all datasets. So she should take all error curves into account, i.e., she has to deal with many quadric functions and make a new error definition to represent the total error. Now, she focuses on the following new function’s minimum which related to multiple quadric functions. The new function F(x) is defined as follows: F(x) &#x3D; max(Si(x)), i &#x3D; 1…n. The domain of x is [0, 1000]. Si(x) is a quadric function. Josephina wonders the minimum of F(x). Unfortunately, it’s too hard for her to solve this problem. As a super programmer, can you help her?<br>Input</p>
<p>The input contains multiple test cases. The first line is the number of cases T (T &lt; 100). Each case begins with a number n (n ≤ 10000). Following n lines, each line contains three integers a (0 ≤ a ≤ 100), b (|b| ≤ 5000), c (|c| ≤ 5000), which mean the corresponding coefficients of a quadratic function.<br>Output</p>
<p>For each test case, output the answer in a line. Round to 4 digits after the decimal point.<br>Sample Input</p>
<p>2 1 2 0 0 2 2 0 0 2 -4 2<br>Sample Output</p>
<p>0.0000 0.5000</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 5050 Divided Land(进制转换)</title>
    <url>/posts/oj/math/HDU%205050%20Divided%20Land(%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2)/</url>
    <content><![CDATA[<p>题意 给你两个二进制数m,n 求他们的最大公约数 用二进制表示 0&lt;m,n&lt;2^1000</p>
<p>先把二进制转换为十进制 求出最大公约数 再把结果转换为二进制 数比较大要用到大数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.<span class="property">util</span>.*;</span><br><span class="line"><span class="keyword">import</span> java.<span class="property">math</span>.*;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">wl6_9</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="title class_">BigInteger</span> two = <span class="title class_">BigInteger</span>.<span class="title function_">valueOf</span>(<span class="number">2</span>), one = <span class="title class_">BigInteger</span>.<span class="property">ONE</span>,</span><br><span class="line">			zero = <span class="title class_">BigInteger</span>.<span class="property">ZERO</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="title class_">BigInteger</span> <span class="title function_">gcd</span>(<span class="params">BigInteger a, BigInteger b</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span> (!(a.<span class="title function_">mod</span>(b).<span class="title function_">equals</span>(zero))) &#123;</span><br><span class="line">			<span class="title class_">BigInteger</span> t = a.<span class="title function_">mod</span>(b);</span><br><span class="line">			a = b;</span><br><span class="line">			b = t;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bprint</span>(<span class="params">BigInteger x</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x.<span class="title function_">equals</span>(zero))</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="title function_">bprint</span>(x.<span class="title function_">divide</span>(two));</span><br><span class="line">		<span class="keyword">if</span> (x.<span class="title function_">mod</span>(two).<span class="title function_">equals</span>(one))</span><br><span class="line">			<span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">print</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">print</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">		<span class="title class_">Scanner</span> <span class="keyword">in</span> = <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="title class_">System</span>.<span class="property">in</span>);</span><br><span class="line">		int T = <span class="keyword">in</span>.<span class="title function_">nextInt</span>();</span><br><span class="line">		<span class="title class_">String</span> a, b;</span><br><span class="line">		<span class="keyword">for</span> (int t = <span class="number">1</span>; t &lt;= T; t++) &#123;</span><br><span class="line">			a = <span class="keyword">in</span>.<span class="title function_">next</span>();</span><br><span class="line">			b = <span class="keyword">in</span>.<span class="title function_">next</span>();</span><br><span class="line">			int la = a.<span class="title function_">length</span>(), lb = b.<span class="title function_">length</span>();</span><br><span class="line"></span><br><span class="line">			<span class="title class_">BigInteger</span> m = zero, n = zero;</span><br><span class="line">			<span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; la; ++i) &#123;</span><br><span class="line">				m = m.<span class="title function_">multiply</span>(two);</span><br><span class="line">				<span class="keyword">if</span> (a.<span class="title function_">charAt</span>(i) == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">					m = m.<span class="title function_">add</span>(one);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; lb; ++i) &#123;</span><br><span class="line">				n = n.<span class="title function_">multiply</span>(two);</span><br><span class="line">				<span class="keyword">if</span> (b.<span class="title function_">charAt</span>(i) == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">					n = n.<span class="title function_">add</span>(one);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>, t);</span><br><span class="line">			<span class="title function_">bprint</span>(<span class="title function_">gcd</span>(m, n));</span><br><span class="line">			<span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">in</span>.<span class="title function_">close</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Divided-Land"><a href="#Divided-Land" class="headerlink" title="Divided Land"></a>Divided Land</h1><p>Problem Description</p>
<p>It’s time to fight the local despots and redistribute the land. There is a rectangular piece of land granted from the government, whose length and width are both in binary form. As the mayor, you must segment the land into multiple squares of equal size for the villagers. What are required is there must be no any waste and each single segmented square land has as large area as possible. The width of the segmented square land is also binary.<br>Input</p>
<p>The first line of the input is T (1 ≤ T ≤ 100), which stands for the number of test cases you need to solve.<br>Each case contains two binary number represents the length L and the width W of given land. (0 &lt; L, W ≤ 21000)<br>Output</p>
<p>For each test case, print a line “Case &#x2F;#t: ”(without quotes, t means the index of the test case) at the beginning. Then one number means the largest width of land that can be divided from input data. And it will be show in binary. Do not have any useless number or space.<br>Sample Input</p>
<p>3 10 100 100 110 10010 1100<br>Sample Output</p>
<p>Case &#x2F;#1: 10 Case &#x2F;#2: 10 Case &#x2F;#3: 110<br>Source</p>
<p><a href="http://acm.hdu.edu.cn/search.php?field=problem&key=2014+ACM/ICPC+Asia+Regional+Shanghai+Online&source=1&searchmode=source">2014 ACM&#x2F;ICPC Asia Regional Shanghai Online</a></p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ 1215 Finding LCM(数论)</title>
    <url>/posts/oj/math/LightOJ%201215%20Finding%20LCM(%E6%95%B0%E8%AE%BA)/</url>
    <content><![CDATA[<p>题意 已知LCM(a, b, c) &#x3D; L 和 a、b、L 求最小的满足等式的c.</p>
<p>把数展开为素因子积的形式后</p>
<p>GCD(a,b)就是a,b的公共素因子取在a、b中的较小指数</p>
<p>LCM(a,b)就是a,b的所有素因子取在a、b中的较大指数</p>
<p>令m &#x3D; LCM(a,b) 那么问题转化为了求最小的c满足 LCM(m, c) &#x3D; L</p>
<p>那么最小的c就是L中不在m中的素因子和L中指数大于m中指数的素因子取在L中的指数即积</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">ll <span class="title function_">gcd</span>(<span class="params">ll a, ll b</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="title function_">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int T;</span><br><span class="line">    ll a, b, l, c, d, m;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">for</span>(int cas = <span class="number">1</span>; cas &lt;= T; ++cas)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;Case %d: &quot;</span>, cas);</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;a, &amp;b, &amp;l);</span><br><span class="line">        m = a * b / <span class="title function_">gcd</span>(a, b); <span class="comment">//m为a,b的最大公约数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l % m) <span class="title function_">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//要使lcm(c,m) = l  c中至少要有l中不在m中的素因子和l中指数大于m中的素因子取在l中的指数</span></span><br><span class="line">            c = l / m;   <span class="comment">//现在c中包含了l中不在m中的素因子取l中指数 和 l中指数大于m中的素因子取指数差</span></span><br><span class="line">            <span class="comment">//那么现在c还需要乘上c和m的公共素因子取m中的指数</span></span><br><span class="line">            <span class="keyword">while</span>((d = <span class="title function_">gcd</span>(c, m)) != <span class="number">1</span>) <span class="comment">//gcd(c,m) 取c,m公共素因子的小指数积</span></span><br><span class="line">            &#123;</span><br><span class="line">                c = c * d, m = m / d;</span><br><span class="line">                d = <span class="title function_">gcd</span>(c, m);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1215 - Finding LCM<br><strong>LCM</strong> is an abbreviation used for <strong>L</strong>east <strong>C</strong>ommon <strong>M</strong>ultiple in Mathematics. We say <strong>LCM (a, b, c) &#x3D; L</strong> if and only if <strong>L</strong> is the least integer which is divisible by <strong>a, b</strong>and <strong>c</strong>.</p>
<p>You will be given <strong>a, b</strong> and <strong>L</strong>. You have to find <strong>c</strong> such that <strong>LCM (a, b, c) &#x3D; L</strong>. If there are several solutions, print the one where <strong>c</strong> is as small as possible. If there is no solution, report so.</p>
<h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>Input starts with an integer <strong>T (≤ 325)</strong>, denoting the number of test cases.</p>
<p>Each case starts with a line containing three integers <strong>a b L (1 ≤ a, b ≤ 106, 1 ≤ L ≤ 1012)</strong>.</p>
<h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>For each case, print the case number and the minimum possible value of <strong>c</strong>. If no solution is found, print <strong>‘impossible’</strong>.</p>
<h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><h1 id="Output-for-Sample-Input-3"><a href="#Output-for-Sample-Input-3" class="headerlink" title="Output for Sample Input 3"></a>Output for Sample Input 3</h1><p>3 5 30</p>
<p>209475 6992 77086800</p>
<p>2 6 10</p>
<p>Case 1: 2</p>
<p>Case 2: 1</p>
<p>Case 3: impossible</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ 1236 - Pairs Forming LCM (LCM·唯一分解)</title>
    <url>/posts/oj/math/LightOJ%201236%20-%20Pairs%20Forming%20LCM%20(LCM%C2%B7%E5%94%AF%E4%B8%80%E5%88%86%E8%A7%A3)/</url>
    <content><![CDATA[<p>题意 给你一个数n 求满足lcm(a, b) &#x3D;&#x3D; n， a &lt;&#x3D; b 的 (a,b) 的个数</p>
<p>容易知道 n 是a, b的所有素因子取在a, b中较大指数的积</p>
<p>先将n分解为素数指数积的形式 n &#x3D; π(pi^ei) 那么对于每个素因子pi pi在a,b中的指数ai, bi 至少有一个等于pi， 另一个小于等于pi</p>
<p>先不考虑a, b的大小 对于每个素因子pi</p>
<ol>
<li><p>在a中的指数 ai &#x3D;&#x3D; ei 那么 pi 在 b 中的指数可取 [0, ei] 中的所有数 有 ei + 1 种情况</p>
</li>
<li><p>在a中的指数 ai &lt; ei 即 ai 在 [0, ei) 中 那么 pi 在 b 中的指数只能取 ei 有 ei 种情况</p>
</li>
</ol>
<p>那么对与每个素因子都有 2&#x2F;<em>ei + 1种情况 也就是满足条件的 (a, b) 有 π(2&#x2F;<em>ei + 1)个 考虑大小时 除了 (n, n) 所有的情况都出现了两次 那么满足a&lt;&#x3D;b的有</em></em>(***<em>π(2&#x2F;<em>ei + 1)) &#x2F; 2 + 1</em></em> 个</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1e7</span> + <span class="number">5</span>;</span><br><span class="line">int pme[N / <span class="number">10</span>], m;</span><br><span class="line">bool vis[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">initPrime</span>() <span class="comment">//线性筛</span></span><br><span class="line">&#123;</span><br><span class="line">    m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">2</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) pme[m++] = i;</span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; m &amp;&amp; pme[j] * i &lt; N; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[pme[j] * i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % pme[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">initPrime</span>();</span><br><span class="line">    ll n, ans, c;</span><br><span class="line">    int T, cas = <span class="number">0</span>;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_">ll</span>(pme[i])*pme[i] &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            c = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>( n % pme[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                n /= pme[i];</span><br><span class="line">                ++c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c) ans *= c * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">1</span>) ans *= <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;Case %d: %lld\n&quot;</span>, ++cas, ans / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1236 - Pairs Forming LCM<br>Find the result of the following code:<br>long long pairsFormLCM( int n ) {<br>long long res &#x3D; 0;<br>for( int i &#x3D; 1; i &lt;&#x3D; n; i++ )<br>for( int j &#x3D; i; j &lt;&#x3D; n; j++ )<br>if( lcm(i, j) &#x3D;&#x3D;n ) res++; <em>&#x2F;&#x2F; lcm means least common multiple</em><br>return res;<br>}</p>
<p>A straight forward implementation of the code may time out. If you analyze the code, you will find that the code actually counts the number of pairs <strong>(i, j)</strong> for which <strong>lcm(i, j) &#x3D; n</strong> and <strong>(i ≤ j)</strong>.</p>
<h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>Input starts with an integer <strong>T (≤ 200)</strong>, denoting the number of test cases.</p>
<p>Each case starts with a line containing an integer <strong>n (1 ≤ n ≤ 1014)</strong>.</p>
<h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>For each case, print the case number and the value returned by the function <strong>‘pairsFormLCM(n)’</strong>.</p>
<h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><h1 id="Output-for-Sample-Input-15"><a href="#Output-for-Sample-Input-15" class="headerlink" title="Output for Sample Input 15"></a>Output for Sample Input 15</h1><p>2</p>
<p>3</p>
<p>4</p>
<p>6</p>
<p>8</p>
<p>10</p>
<p>12</p>
<p>15</p>
<p>18</p>
<p>20</p>
<p>21</p>
<p>24</p>
<p>25</p>
<p>27</p>
<p>29</p>
<p>Case 1: 2</p>
<p>Case 2: 2</p>
<p>Case 3: 3</p>
<p>Case 4: 5</p>
<p>Case 5: 4</p>
<p>Case 6: 5</p>
<p>Case 7: 8</p>
<p>Case 8: 5</p>
<p>Case 9: 8</p>
<p>Case 10: 8</p>
<p>Case 11: 5</p>
<p>Case 12: 11</p>
<p>Case 13: 3</p>
<p>Case 14: 4</p>
<p>Case 15: 2</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1365 Prime Land</title>
    <url>/posts/oj/math/POJ%201365%20Prime%20Land/</url>
    <content><![CDATA[<p>觉得这题最难的就是理解题意了 应该怪我英语太差了</p>
<p>题意 一个大于1的数可以 表示成p1^e1&#x2F;*p2^e2&#x2F;*p3^e3&#x2F;*p4^e4&#x2F;<em>p5^e5&#x2F;</em>…&#x2F;*pn^en的形式 其中p是素数 且p是递减的 p&lt; 32767</p>
<p>输入给你这个数的这种表达形式的所有p和e 第奇数个数为pi第偶数个数为ei 每行的所有数据表示一个数 你要求出这个数x然后输出x-1的这种表达形式；</p>
<p>理解了题意这个题就简单了 直接暴力可能会超时 所以还是打了个素数表 还要注意pow的前一个参数要乘以1.0 不然会精度丢失</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">33000</span>;</span><br><span class="line">int x, a, b , m , last , ans[N], vis[N], prime[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">initPrime</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int num = <span class="number">0</span>, m = sqrt (N + <span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">2</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> (int j = i * i; j &lt; N; j += i)</span><br><span class="line">                vis[j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">2</span>, t = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) prime[++num] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">initPrime</span>(); char c;</span><br><span class="line">    <span class="keyword">while</span> (scanf (<span class="string">&quot;%d&quot;</span>, &amp;a), a)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf (<span class="string">&quot;%d%c&quot;</span>, &amp;b, &amp;c);</span><br><span class="line">        x = pow (a*<span class="number">1.0</span>, b);</span><br><span class="line">        <span class="keyword">while</span> (c == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf (<span class="string">&quot;%d %d%c&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">            x = x * pow (a*<span class="number">1.0</span>, b);</span><br><span class="line">        &#125;</span><br><span class="line">        --x; last = <span class="number">0</span>;</span><br><span class="line">        <span class="title function_">memset</span>(ans,<span class="number">0</span>,<span class="title function_">sizeof</span>(ans));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; x &gt; <span class="number">1</span>; m=i,++i)</span><br><span class="line">            <span class="keyword">if</span> (x % prime[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!last) last = i;</span><br><span class="line">                <span class="keyword">while</span> (x % prime[i] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++ans[i];</span><br><span class="line">                    x /= prime[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (int i = m; i &gt;= last; --i)</span><br><span class="line">            <span class="keyword">if</span> (ans[i]) printf (i == last ? <span class="string">&quot;%d %d\n&quot;</span> : <span class="string">&quot;%d %d &quot;</span>, prime[i], ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Prime Land</p>
<p>Description<br>Everybody in the Prime Land is using a prime base number system. In this system, each positive integer x is represented as follows: Let {pi}i&#x3D;0,1,2,… denote the increasing sequence of all prime numbers. We know that x &gt; 1 can be represented in only one way in the form of product of powers of prime factors. This implies that there is an integer kx and uniquely determined integers ekx, ekx-1, …, e1, e0, (ekx &gt; 0), that <img src="/../images/es-1365_1.jpg.png"> The sequence<br>(ekx, ekx-1, … ,e1, e0)<br>is considered to be the representation of x in prime base number system.<br>It is really true that all numerical calculations in prime base number system can seem to us a little bit unusual, or even hard. In fact, the children in Prime Land learn to add to subtract numbers several years. On the other hand, multiplication and division is very simple.<br>Recently, somebody has returned from a holiday in the Computer Land where small smart things called computers have been used. It has turned out that they could be used to make addition and subtraction in prime base number system much easier. It has been decided to make an experiment and let a computer to do the operation &#96;&#96;minus one’’.<br>Help people in the Prime Land and write a corresponding program.<br>For practical reasons we will write here the prime base representation as a sequence of such pi and ei from the prime base representation above for which ei &gt; 0. We will keep decreasing order with regard to pi.</p>
<p>Input</p>
<p>The input consists of lines (at least one) each of which except the last contains prime base representation of just one positive integer greater than 2 and less or equal 32767. All numbers in the line are separated by one space. The last line contains number 0.</p>
<p>Output</p>
<p>The output contains one line for each but the last line of the input. If x is a positive integer contained in a line of the input, the line in the output will contain x - 1 in prime base representation. All numbers in the line are separated by one space. There is no line in the output corresponding to the last &#96;&#96;null’’ line of the input.</p>
<p>Sample Input</p>
<p>17 1 5 1 2 1 509 1 59 1 0</p>
<p>Sample Output</p>
<p>2 4 3 2 13 1 11 1 7 1 5 1 3 1 2 1</p>
<p>Prime Land</p>
<p><strong>Time Limit:</strong> 1000MS  <strong>Memory Limit:</strong> 10000K <strong>Total Submissions:</strong> 2972  <strong>Accepted:</strong> 1362</p>
<p>Description<br>Everybody in the Prime Land is using a prime base number system. In this system, each positive integer x is represented as follows: Let {pi}i&#x3D;0,1,2,… denote the increasing sequence of all prime numbers. We know that x &gt; 1 can be represented in only one way in the form of product of powers of prime factors. This implies that there is an integer kx and uniquely determined integers ekx, ekx-1, …, e1, e0, (ekx &gt; 0), that <img src="/../images/es-1365_1.jpg.png"> The sequence<br>(ekx, ekx-1, … ,e1, e0)<br>is considered to be the representation of x in prime base number system.<br>It is really true that all numerical calculations in prime base number system can seem to us a little bit unusual, or even hard. In fact, the children in Prime Land learn to add to subtract numbers several years. On the other hand, multiplication and division is very simple.<br>Recently, somebody has returned from a holiday in the Computer Land where small smart things called computers have been used. It has turned out that they could be used to make addition and subtraction in prime base number system much easier. It has been decided to make an experiment and let a computer to do the operation &#96;&#96;minus one’’.<br>Help people in the Prime Land and write a corresponding program.<br>For practical reasons we will write here the prime base representation as a sequence of such pi and ei from the prime base representation above for which ei &gt; 0. We will keep decreasing order with regard to pi.</p>
<p>Input</p>
<p>The input consists of lines (at least one) each of which except the last contains prime base representation of just one positive integer greater than 2 and less or equal 32767. All numbers in the line are separated by one space. The last line contains number 0.</p>
<p>Output</p>
<p>The output contains one line for each but the last line of the input. If x is a positive integer contained in a line of the input, the line in the output will contain x - 1 in prime base representation. All numbers in the line are separated by one space. There is no line in the output corresponding to the last &#96;&#96;null’’ line of the input.</p>
<p>Sample Input</p>
<p>17 1 5 1 2 1 509 1 59 1 0</p>
<p>Sample Output</p>
<p>2 4 3 2 13 1 11 1 7 1 5 1 3 1 2 1</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1434 Fill the Cisterns!（二分）</title>
    <url>/posts/oj/math/POJ%201434%20Fill%20the%20Cisterns!%EF%BC%88%E4%BA%8C%E5%88%86%EF%BC%89/</url>
    <content><![CDATA[<p>题意 有n个互相连通的长方体水箱 给出每个水箱的位置和长宽高 判断放v体积的水时水面的高度 精确到两位小数</p>
<p>可以把每个水箱的位置 底面积 和高存起来 然用体积v二分高度 就是要注意精度的处理 最好转换成整数运算</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.<span class="property">util</span>.*;</span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> int N = <span class="number">50005</span>;</span><br><span class="line">	<span class="keyword">static</span> long[] b = <span class="keyword">new</span> long[N];</span><br><span class="line">	<span class="keyword">static</span> long[] h = <span class="keyword">new</span> long[N];</span><br><span class="line">	<span class="keyword">static</span> long[] s = <span class="keyword">new</span> long[N];</span><br><span class="line">	<span class="keyword">static</span> int n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> long <span class="title function_">getv</span>(<span class="params">long k</span>) &#123;</span><br><span class="line">		long v = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (b[i] + h[i] &lt;= k) v += s[i] * h[i];</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (b[i] &lt; k) v += (k - b[i]) * s[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> v;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span> args[]</span>) &#123;</span><br><span class="line">		<span class="title class_">Scanner</span> <span class="keyword">in</span> = <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="title class_">System</span>.<span class="property">in</span>);</span><br><span class="line">		int cas = <span class="keyword">in</span>.<span class="title function_">nextInt</span>();</span><br><span class="line">		<span class="keyword">while</span> (cas-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			n = <span class="keyword">in</span>.<span class="title function_">nextInt</span>();</span><br><span class="line">			long l = <span class="number">0</span>, r = <span class="number">0</span>, f = <span class="number">0</span>, mid = <span class="number">0</span>, v;</span><br><span class="line">			<span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">				b[i] = <span class="keyword">in</span>.<span class="title function_">nextLong</span>() * <span class="number">1000</span>;</span><br><span class="line">				h[i] = <span class="keyword">in</span>.<span class="title function_">nextLong</span>() * <span class="number">1000</span>;</span><br><span class="line">				s[i] = <span class="keyword">in</span>.<span class="title function_">nextLong</span>() * <span class="keyword">in</span>.<span class="title function_">nextLong</span>();</span><br><span class="line">				f += s[i] * h[i];</span><br><span class="line">				<span class="keyword">if</span> (b[i] + h[i] &gt; r)  r = b[i] + h[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> ((v = <span class="keyword">in</span>.<span class="title function_">nextLong</span>() * <span class="number">1000</span>) &gt; f)</span><br><span class="line">				<span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;OVERFLOW&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">while</span> (r &gt;= l) &#123;</span><br><span class="line">					mid = (r + l) / <span class="number">2</span>;</span><br><span class="line">					<span class="keyword">if</span> (<span class="title function_">getv</span>(mid) &lt; v) l = mid + <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">else</span> r = mid - <span class="number">1</span>;		</span><br><span class="line">				&#125;</span><br><span class="line">				double ans = l / <span class="number">1000.0</span>;</span><br><span class="line">				<span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="title class_">String</span>.<span class="title function_">format</span>(<span class="string">&quot;%.2f&quot;</span>, ans));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">in</span>.<span class="title function_">close</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Fill the Cisterns!</p>
<p>Description<br>During the next century certain regions on earth will experience severe water shortages. The old town of Uqbar has already started to prepare itself for the worst. Recently they created a network of pipes connecting the cisterns that distribute water in each neighbourhood, making it easier to fill them at once from a single source of water. But in case of water shortage the cisterns above a certain level will be empty since the water will to the cisterns below.<br>  <img src="/../images/es-1434_1.jpg.png">  You have been asked to write a program to compute the level to which cisterns will be lled with a certain volume of water, given the dimensions and position of each cistern. To simplify we will neglect the volume of water in the pipes.<br>Task<br>Write a program which for each data set:<br>reads the description of cisterns and the volume of water,<br>computes the level to which the cisterns will be filled with the given amount of water,<br>writes the result.</p>
<p>Input</p>
<p>The first line of the input contains the number of data sets k, 1 &lt;&#x3D; k &lt;&#x3D; 30. The data sets follow.<br>The first line of each data set contains one integer n, the number of cisterns, 1 &lt;&#x3D; n &lt;&#x3D; 50 000. Each of the following n lines consists of 4 nonnegative integers, separated by single spaces: b, h, w, d - the base level of the cistern, its height, width and depth in meters, respectively. The integers satisfy 0 &lt;&#x3D; b &lt;&#x3D; 10^6 and 1 &lt;&#x3D; h &#x2F;* w &#x2F;* d &lt;&#x3D; 40 000. The last line of the data set contains an integer V - the volume of water in cubic meters to be injected into the network. Integer V satisfies 1 &lt;&#x3D; V &lt;&#x3D; 2 &#x2F;* 10^9.</p>
<p>Output</p>
<p>The output should consist of exactly d lines, one line for each data set.<br>Line i, 1 &lt;&#x3D; i &lt;&#x3D; d, should contain the level that the water will reach, in meters, rounded up to two fractional digits, or the word ‘OVERFLOW’, if the volume of water exceeds the total capacity of the cisterns.</p>
<p>Sample Input</p>
<p>3 2 0 1 1 1 2 1 1 1 1 4 11 7 5 1 15 6 2 2 5 8 5 1 19 4 8 1 132 4 11 7 5 1 15 6 2 2 5 8 5 1 19 4 8 1 78</p>
<p>Sample Output</p>
<p>1.00 OVERFLOW 17.00</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1840 Eqs(hash)</title>
    <url>/posts/oj/math/POJ%201840%20Eqs(hash)/</url>
    <content><![CDATA[<p>题意 输入a1,a2,a3,a4,a5 求有多少种不同的x1,x2,x3,x4,x5序列使得等式成立 a,x取值在-50到50之间</p>
<p>直接暴力的话肯定会超时的 100的五次方 10e了都 然后可以考虑将等式变一下形 把a1&#x2F;*x1^3+a2&#x2F;*x2^3移到右边 也就是-(a1&#x2F;*x1^3+a2^x2^3)&#x3D;a3&#x2F;*x3^3+a4&#x2F;*x4^3+a5&#x2F;*x5^3</p>
<p>考虑到a1&#x2F;*x1^3+a2^x2^3的最大值50&#x2F;*50^3+50&#x2F;*50^3&#x3D;12500000 这个数并不大 可以开这么大的数组把每个结果出现的次数存下来 又因为结果最小可能是负的12500000 负数不能做数组的下标 加上个12500000&#x2F;*2就行了 这样分别枚举左右两边 把左边出现过的结果都存在一个数组里面 再枚举右边 没出现一次结果 答案就加上前面这个结果出现的次数 枚举完就出现答案了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int maxs = <span class="number">50</span> * <span class="number">50</span> * <span class="number">50</span> * <span class="number">50</span> * <span class="number">4</span> + <span class="number">10</span>;</span><br><span class="line">unsigned short cnt[maxs];</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int a1, a2, a3, a4, a5, sum,ans=<span class="number">0</span>;</span><br><span class="line">    scanf (<span class="string">&quot;%d%d%d%d%d&quot;</span>, &amp;a1, &amp;a2, &amp;a3, &amp;a4, &amp;a5);</span><br><span class="line">    <span class="keyword">for</span> (int x1 = -<span class="number">50</span>; x1 &lt;= <span class="number">50</span>; ++x1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x1 == <span class="number">0</span>) ++x1;</span><br><span class="line">        <span class="keyword">for</span> (int x2 = -<span class="number">50</span>; x2 &lt;= <span class="number">50</span>; ++x2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x2 == <span class="number">0</span>) ++x2;</span><br><span class="line">            sum = (a1 * x1 * x1 * x1 + a2 * x2 * x2 * x2) * (-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) ++cnt[sum + maxs];</span><br><span class="line">            <span class="keyword">else</span> ++cnt[sum];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (int x3 = -<span class="number">50</span>; x3 &lt;= <span class="number">50</span>; ++x3)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x3 == <span class="number">0</span>) ++x3;</span><br><span class="line">        <span class="keyword">for</span> (int x4 = -<span class="number">50</span>; x4 &lt;= <span class="number">50</span>; ++x4)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x4 == <span class="number">0</span>) ++x4;</span><br><span class="line">            <span class="keyword">for</span> (int x5 = -<span class="number">50</span>; x5 &lt;= <span class="number">50</span>; ++x5)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (x5 == <span class="number">0</span>) ++x5;</span><br><span class="line">                sum = (a3 * x3 * x3 * x3 + a4 * x4 * x4 * x4 + a5 * x5 * x5 * x5) ;</span><br><span class="line">                <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) sum += maxs;</span><br><span class="line">                ans += cnt[sum];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf (<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Eqs</p>
<p>Description<br>Consider equations having the following form:<br>a1x13+ a2x23+ a3x33+ a4x43+ a5x53&#x3D;0<br>The coefficients are given integers from the interval [-50,50].<br>It is consider a solution a system (x1, x2, x3, x4, x5) that verifies the equation, xi∈[-50,50], xi !&#x3D; 0, any i∈{1,2,3,4,5}.<br>Determine how many solutions satisfy the given equation.</p>
<p>Input</p>
<p>The only line of input contains the 5 coefficients a1, a2, a3, a4, a5, separated by blanks.</p>
<p>Output</p>
<p>The output will contain on the first line the number of the solutions for the given equation.</p>
<p>Sample Input</p>
<p>37 29 41 43 47</p>
<p>Sample Output</p>
<p>654</p>
<p>还有用hashmap做的 空间优化了不少</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;hash_map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int first[<span class="number">50</span>*<span class="number">50</span>*<span class="number">50</span>+<span class="number">10</span>];</span><br><span class="line">int ecnt,w[<span class="number">10005</span>],v[<span class="number">10005</span>],nex[<span class="number">10005</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span>(<span class="params">int x</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int t=(x+<span class="number">50</span>*<span class="number">50</span>*<span class="number">50</span>*<span class="number">100</span>)/<span class="number">200</span>,flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(int e=first[t];(~e)&amp;&amp;flag;e=nex[e])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(v[e]==x)</span><br><span class="line">        &#123;</span><br><span class="line">            flag=<span class="number">0</span>,w[e]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        w[ecnt]=<span class="number">1</span>;</span><br><span class="line">        v[ecnt]=x;</span><br><span class="line">        nex[ecnt]=first[t];</span><br><span class="line">        first[t]=ecnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="title function_">getcnt</span>(<span class="params">int x</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">50</span>*<span class="number">50</span>*<span class="number">50</span>*<span class="number">50</span>*<span class="number">2</span>||x&lt;-<span class="number">50</span>*<span class="number">50</span>*<span class="number">50</span>*<span class="number">50</span>*<span class="number">2</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    int t=(x+<span class="number">50</span>*<span class="number">50</span>*<span class="number">50</span>*<span class="number">100</span>)/<span class="number">200</span>;</span><br><span class="line">    <span class="keyword">for</span>(int e=first[t];(~e);e=nex[e])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(v[e]==x)<span class="keyword">return</span> w[e];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int a1, a2, a3, a4, a5, sum,ans=<span class="number">0</span>;</span><br><span class="line">    scanf (<span class="string">&quot;%d%d%d%d%d&quot;</span>, &amp;a1, &amp;a2, &amp;a3, &amp;a4, &amp;a5);</span><br><span class="line">    <span class="title function_">memset</span>(first,-<span class="number">1</span>,sizeof first);</span><br><span class="line">    ecnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (int x1 = -<span class="number">50</span>; x1 &lt;= <span class="number">50</span>; ++x1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x1 == <span class="number">0</span>) ++x1;</span><br><span class="line">        <span class="keyword">for</span> (int x2 = -<span class="number">50</span>; x2 &lt;= <span class="number">50</span>; ++x2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x2 == <span class="number">0</span>) ++x2;</span><br><span class="line">            sum = (a1 * x1 * x1 * x1 + a2 * x2 * x2 * x2) * (-<span class="number">1</span>);</span><br><span class="line">            <span class="title function_">add</span>(sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (int x3 = -<span class="number">50</span>; x3 &lt;= <span class="number">50</span>; ++x3)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x3 == <span class="number">0</span>) ++x3;</span><br><span class="line">        <span class="keyword">for</span> (int x4 = -<span class="number">50</span>; x4 &lt;= <span class="number">50</span>; ++x4)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x4 == <span class="number">0</span>) ++x4;</span><br><span class="line">            <span class="keyword">for</span> (int x5 = -<span class="number">50</span>; x5 &lt;= <span class="number">50</span>; ++x5)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (x5 == <span class="number">0</span>) ++x5;</span><br><span class="line">                sum = (a3 * x3 * x3 * x3 + a4 * x4 * x4 * x4 + a5 * x5 * x5 * x5) ;</span><br><span class="line">                ans +=<span class="title function_">getcnt</span>(sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf (<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ</category>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3258 River Hopscotch（二分·最小距离最大)</title>
    <url>/posts/oj/math/POJ%203258%20River%20Hopscotch%EF%BC%88%E4%BA%8C%E5%88%86%C2%B7%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB%E6%9C%80%E5%A4%A7)/</url>
    <content><![CDATA[<p>题意 一条河两岸之间有n个石头 求取走m个石头后 使得两个石头间距离的最小值最大</p>
<p>感觉关键是理解题意 简单的二分 二分最小距离 看要取走多少个(cnt)石头 cnt&lt;&#x3D;m的话 说明最小距离还可以增大 这样就可以二分出答案了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">50005</span>;</span><br><span class="line">int p[N], l, n, m;</span><br><span class="line"></span><br><span class="line">bool <span class="title function_">ok</span>(<span class="params">int k</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int last = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i] - p[last] &lt; k) ++cnt;</span><br><span class="line">        <span class="keyword">else</span> last = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt &lt;= m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int le, ri, mid;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        p[++n] = l;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p[i]);</span><br><span class="line"></span><br><span class="line">        <span class="title function_">sort</span>(p, p + n);</span><br><span class="line">        le = <span class="number">0</span>, ri = l;</span><br><span class="line">        <span class="keyword">while</span>(le &lt;= ri)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (le + ri) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_">ok</span>(mid)) le = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> ri = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, le - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>River Hopscotch</p>
<p>Description<br>Every year the cows hold an event featuring a peculiar version of hopscotch that involves carefully jumping from rock to rock in a river. The excitement takes place on a long, straight river with a rock at the start and another rock at the end, <em>L</em> units away from the start (1 ≤ <em>L</em> ≤ 1,000,000,000). Along the river between the starting and ending rocks, <em>N</em> (0 ≤<em>N</em> ≤ 50,000) more rocks appear, each at an integral distance <em>Di</em> from the start (0 &lt; <em>Di</em> &lt; <em>L</em>).</p>
<p>To play the game, each cow in turn starts at the starting rock and tries to reach the finish at the ending rock, jumping only from rock to rock. Of course, less agile cows never make it to the final rock, ending up instead in the river.</p>
<p>Farmer John is proud of his cows and watches this event each year. But as time goes by, he tires of watching the timid cows of the other farmers limp across the short distances between rocks placed too closely together. He plans to remove several rocks in order to increase the shortest distance a cow will have to jump to reach the end. He knows he cannot remove the starting and ending rocks, but he calculates that he has enough resources to remove up to <em>M</em>rocks (0 ≤ <em>M</em> ≤ <em>N</em>).</p>
<p>FJ wants to know exactly how much he can increase the shortest distance <em>&#x2F;<em>before&#x2F;</em></em> he starts removing the rocks. Help Farmer John determine the greatest possible shortest distance a cow has to jump after removing the optimal set of <em>M</em> rocks.</p>
<p>Input</p>
<p>Line 1: Three space-separated integers: <em>L</em>, <em>N</em>, and <em>M</em><br>Lines 2.. <em>N</em>+1: Each line contains a single integer indicating how far some rock is away from the starting rock. No two rocks share the same position.</p>
<p>Output</p>
<p>Line 1: A single integer that is the maximum of the shortest distance a cow has to jump after removing <em>M</em> rocks</p>
<p>Sample Input</p>
<p>25 5 2 2 14 11 21 17</p>
<p>Sample Output</p>
<p>4</p>
<p>Hint</p>
<p>Before removing any rocks, the shortest jump was a jump of 2 from 0 (the start) to 2. After removing the rocks at 2 and 14, the shortest required jump is a jump of 4 (from 17 to 21 or from 21 to 25).</p>
<p>Source</p>
<p><a href="http://poj.org/searchproblem?field=source&key=USACO+2006+December+Silver">USACO 2006 December Silver</a></p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3292 Semi-prime H-numbers（数）</title>
    <url>/posts/oj/math/POJ%203292%20Semi-prime%20H-numbers%EF%BC%88%E6%95%B0%EF%BC%89/</url>
    <content><![CDATA[<p>题意 所有可以表示为4&#x2F;*k+1（k&gt;&#x3D;0）的数都称为“H数” 而在所有“H数”中只能被1和自身整除的H数称为“H素数“ 能表示成两个”H素数“积的数又称为”Semi-prime H数“</p>
<p>输入n 求1到n之间有多少个”Semi-prime H数“;</p>
<p>方法 先打个H素数表 再用H素数表中的数依次相乘 得到的数都标记 再用一个数组保存每个数以内的标记数 输入n后直接读数组就行了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N=<span class="number">1000001</span>;</span><br><span class="line">int vis[N],hp[N],ans[N],n;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int num=<span class="number">0</span>,m=<span class="title function_">sqrt</span>(N+<span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">5</span>;i&lt;=m;i+=<span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span>(int j=i*i;j&lt;=N;j+=i)</span><br><span class="line">            vis[j]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">5</span>;i&lt;N;i+=<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) hp[++num]=i;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">memset</span>(vis,<span class="number">0</span>,<span class="title function_">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;hp[i]*hp[i]&lt;=N;++i)</span><br><span class="line">        <span class="keyword">for</span>(int j=i;hp[i]*hp[j]&lt;=N;++j)</span><br><span class="line">            ++vis[hp[i]*hp[j]];</span><br><span class="line">    num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;N;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]&gt;=<span class="number">1</span>) ++num;</span><br><span class="line">            ans[i]=num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),n)</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,n,ans[n]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Semi-prime H-numbers</p>
<p>Description<br>This problem is based on an exercise of David Hilbert, who pedagogically suggested that one study the theory of <em>4n+1</em> numbers. Here, we do only a bit of that.</p>
<p>An <strong>H</strong>-number is a positive number which is one more than a multiple of four: 1, 5, 9, 13, 17, 21,… are the <strong>H</strong>-numbers. For this problem we pretend that these are the <em>only</em> numbers. The <strong>H</strong>-numbers are closed under multiplication.</p>
<p>As with regular integers, we partition the <strong>H</strong>-numbers into units, <strong>H</strong>-primes, and <strong>H</strong>-composites. 1 is the only unit. An <strong>H</strong>-number <em>h</em> is <strong>H</strong>-prime if it is not the unit, and is the product of two <strong>H</strong>-numbers in only one way: 1 × <em>h</em>. The rest of the numbers are <strong>H</strong>-composite.</p>
<p>For examples, the first few <strong>H</strong>-composites are: 5 × 5 &#x3D; 25, 5 × 9 &#x3D; 45, 5 × 13 &#x3D; 65, 9 × 9 &#x3D; 81, 5 × 17 &#x3D; 85.</p>
<p>Your task is to count the number of <strong>H</strong>-semi-primes. An <strong>H</strong>-semi-prime is an <strong>H</strong>-number which is the product of exactly two <strong>H</strong>-primes. The two <strong>H</strong>-primes may be equal or different. In the example above, all five numbers are <strong>H</strong>-semi-primes. 125 &#x3D; 5 × 5 × 5 is not an <strong>H</strong>-semi-prime, because it’s the product of three <strong>H</strong>-primes.</p>
<p>Input</p>
<p>Each line of input contains an <strong>H</strong>-number ≤ 1,000,001. The last line of input contains 0 and this line should not be processed.</p>
<p>Output</p>
<p>For each inputted <strong>H</strong>-number <em>h</em>, print a line stating <em>h</em> and the number of <strong>H</strong>-semi-primes between 1 and <em>h</em> inclusive, separated by one space in the format shown in the sample.</p>
<p>Sample Input</p>
<p>21 85 789 0</p>
<p>Sample Output</p>
<p>21 0 85 5 789 62</p>
<p>Semi-prime H-numbers</p>
<p>Description<br>This problem is based on an exercise of David Hilbert, who pedagogically suggested that one study the theory of <em>4n+1</em> numbers. Here, we do only a bit of that.</p>
<p>An <strong>H</strong>-number is a positive number which is one more than a multiple of four: 1, 5, 9, 13, 17, 21,… are the <strong>H</strong>-numbers. For this problem we pretend that these are the <em>only</em> numbers. The <strong>H</strong>-numbers are closed under multiplication.</p>
<p>As with regular integers, we partition the <strong>H</strong>-numbers into units, <strong>H</strong>-primes, and <strong>H</strong>-composites. 1 is the only unit. An <strong>H</strong>-number <em>h</em> is <strong>H</strong>-prime if it is not the unit, and is the product of two <strong>H</strong>-numbers in only one way: 1 × <em>h</em>. The rest of the numbers are <strong>H</strong>-composite.</p>
<p>For examples, the first few <strong>H</strong>-composites are: 5 × 5 &#x3D; 25, 5 × 9 &#x3D; 45, 5 × 13 &#x3D; 65, 9 × 9 &#x3D; 81, 5 × 17 &#x3D; 85.</p>
<p>Your task is to count the number of <strong>H</strong>-semi-primes. An <strong>H</strong>-semi-prime is an <strong>H</strong>-number which is the product of exactly two <strong>H</strong>-primes. The two <strong>H</strong>-primes may be equal or different. In the example above, all five numbers are <strong>H</strong>-semi-primes. 125 &#x3D; 5 × 5 × 5 is not an <strong>H</strong>-semi-prime, because it’s the product of three <strong>H</strong>-primes.</p>
<p>Input</p>
<p>Each line of input contains an <strong>H</strong>-number ≤ 1,000,001. The last line of input contains 0 and this line should not be processed.</p>
<p>Output</p>
<p>For each inputted <strong>H</strong>-number <em>h</em>, print a line stating <em>h</em> and the number of <strong>H</strong>-semi-primes between 1 and <em>h</em> inclusive, separated by one space in the format shown in the sample.</p>
<p>Sample Input</p>
<p>21 85 789 0</p>
<p>Sample Output</p>
<p>21 0 85 5 789 62</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3370 Halloween treats(抽屉原理)</title>
    <url>/posts/oj/math/POJ%203370%20Halloween%20treats(%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86)/</url>
    <content><![CDATA[<p>题意 有c个小孩 n个大人万圣节搞活动 当小孩进入第i个大人家里时 这个大人就会给小孩a[i]个糖果 求小孩去哪几个大人家可以保证得到的糖果总数是小孩数c的整数倍 多种方案满足输出任意一种</p>
<p>用s[i]表示前i个打人给糖果数的总和 令s[0]&#x3D;0 那么s[i]共有n+1种不同值 而s[i]%c最多有c种不同值 题目说了c&lt;&#x3D;n 所以s[i]%c肯定会有重复值了</p>
<p>这就是抽屉原理了 n个抽屉放大于n个苹果 至少有一个抽屉有大于等于2个苹果</p>
<p>就把s[i]%c的取值个数(c)看作是抽屉 然后s[i]的取值个数看作是苹果 就有上面的结论了</p>
<p>然后当s[a]%c&#x3D;&#x3D;s[b]%c的时候 可以知道(s[b]-s[a])%c是等于0的 也就是说得到了一个方案 选从a+1到第b个打人就可以平均分糖果了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">100010</span>;</span><br><span class="line">int s[N], vis[N];</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, c, i, j;</span><br><span class="line">    <span class="keyword">while</span> (~scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;c, &amp;n), c)</span><br><span class="line">    &#123;</span><br><span class="line">        memset (vis, <span class="number">0</span>, sizeof (vis));</span><br><span class="line">        vis[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf (<span class="string">&quot;%d&quot;</span>, &amp;s[i]);</span><br><span class="line">            s[i] = (s[i] + s[i - <span class="number">1</span>]) % c;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[s[i]]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                vis[s[i]] = i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = vis[s[i]]; j &lt;= i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (j != i) printf (<span class="string">&quot;%d &quot;</span>, j);</span><br><span class="line">            <span class="keyword">else</span> printf (<span class="string">&quot;%d\n&quot;</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Halloween treats</p>
<p>Description<br>Every year there is the same problem at Halloween: Each neighbour is only willing to give a certain total number of sweets on that day, no matter how many children call on him, so it may happen that a child will get nothing if it is too late. To avoid conflicts, the children have decided they will put all sweets together and then divide them evenly among themselves. From last year’s experience of Halloween they know how many sweets they get from each neighbour. Since they care more about justice than about the number of sweets they get, they want to select a subset of the neighbours to visit, so that in sharing every child receives the same number of sweets. They will not be satisfied if they have any sweets left which cannot be divided.</p>
<p>Your job is to help the children and present a solution.</p>
<p>Input</p>
<p>The input contains several test cases.<br>The first line of each test case contains two integers <em><strong>c</strong></em> and <em><strong>n</strong></em> (<em>1 ≤ c ≤ n ≤ 100000</em>), the number of children and the number of neighbours, respectively. The next line contains <em><strong>n</strong></em>space separated integers <em>*<em>a</em>1 , … , *a**n</em>** (<em>1 ≤ ai ≤ 100000</em>), where <em><strong>a</strong>i</em>** represents the number of sweets the children get if they visit neighbour <em><strong>i</strong></em>.</p>
<p>The last test case is followed by two zeros.</p>
<p>Output</p>
<p>For each test case output one line with the indices of the neighbours the children should select (here, index <em><strong>i</strong></em> corresponds to neighbour <em><strong>i</strong></em> who gives a total number of <strong><em>a</em>i</strong> sweets). If there is no solution where each child gets at least one sweet print “no sweets” instead. Note that if there are several solutions where each child gets at least one sweet, you may print any of them.</p>
<p>Sample Input</p>
<p>4 5 1 2 3 7 5 3 6 7 11 2 5 13 17 0 0</p>
<p>Sample Output</p>
<p>3 5 2 3 4</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3993 Not So Flat After All(质因数)</title>
    <url>/posts/oj/math/POJ%203993%20Not%20So%20Flat%20After%20All(%E8%B4%A8%E5%9B%A0%E6%95%B0)/</url>
    <content><![CDATA[<p>Not So Flat After All</p>
<p>Description<br>Any positive integer v can be written as p1a1&#x2F;<em>p2a2&#x2F;</em>…&#x2F;*pnan where pi is a prime number and ai ≥ 0. For example: 24 &#x3D; 23&#x2F;*31.<br>Pick any two prime numbers p1 and p2 where p1 &#x3D; p2. Imagine a two dimensional plane where the powers of p1 are plotted on the x-axis and the powers of p2 on the y-axis. Now any number that can be written as p1a1&#x2F;*p2a2 can be plotted on this plane at location (x, y) &#x3D; (a1, a2). The figure on the right shows few examples where p1 &#x3D; 3 and p2 &#x3D; 2.<br>  <img src="/../images/es-3993_1-.png">  This idea can be extended for any N-Dimensional space where each of the N axes is assigned a unique prime number. Each N-Dimensional space has a unique set of primes.<br>We call such set the Space Identification Set or S for short. |S| (the ordinal of S) is N.<br>Any number that can be expressed as a multiplication of pi ∈ S (each raised to a power (ai ≥ 0) can be plotted in this |S|-Dimensional space. The figure at the bottom illustrates this idea for N &#x3D; 3 and S &#x3D; {2, 3, 7}. Needless to say, any number that can be plotted on space A can also be plotted on space B as long as SA <img src="/../images/ula-tex=%5Csubset.png" alt="\subset"> SB.<br>We define the distance between any two points in a given N-Dimensional space to be the sum of units traveled to get from one point to the other while following the grid lines (i.e. movement is always parallel to one of the axes.) For example, in the figure below, the distance between 168 and 882 is 4.<br>Given two positive integers, write a program that determines the minimum ordinal of a space where both numbers can be plotted in. The program also determines the distance between these two integers in that space.<br>  <img src="/../images/es-3993_2-.png"></p>
<p>Input</p>
<p>Your program will be tested on one or more test cases. Each test case is specified on a line with two positive integers (0 &lt; A,B &lt; 1, 000, 000) where A &#x2F;* B &gt; 1.<br>The last line is made of two zeros.</p>
<p>Output</p>
<p>For each test case, print the following line:<br>k. X:D<br>Where k is the test case number (starting at one,) X is the minimum ordinal needed in a space that both A and B can be plotted in. D is the distance between these two points.</p>
<p>Sample Input</p>
<p>168 882 770 792 0 0</p>
<p>Sample Output</p>
<ol>
<li>3:4 2. 5:6</li>
</ol>
<p>题意 给你两个数a,b 求a,b所有的质因数个数 和每个质因数个数的差的绝对值的和 被描述得好复杂 理解了就是个水题；</p>
<p>素数问题就先打个素数表吧 然后能被整除的就是质因数了 然后统计a，b分别能被这个数整除多少次</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1000001</span>;</span><br><span class="line">int p[N], ans[N], vis[N], a, b;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">initPrime</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int num = <span class="number">0</span>, m = sqrt (N + <span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">2</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">if</span> (vis[i] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> (int j = i * i; j &lt;= N; j += i) vis[j] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">2</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">if</span> (vis[i] == <span class="number">0</span>) p[++num] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">initPrime</span>();</span><br><span class="line">    int cas=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b),a)</span><br><span class="line">    &#123;</span><br><span class="line">        int cnt = <span class="number">0</span>, ans = <span class="number">0</span>, ca, cb;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; a &gt; <span class="number">1</span> || b &gt; <span class="number">1</span>; ++i)</span><br><span class="line">            <span class="keyword">if</span> (a % p[i] == <span class="number">0</span> || b % p[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++cnt, ca = cb = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (a % p[i] == <span class="number">0</span>) a /= p[i], ++ca;</span><br><span class="line">                <span class="keyword">while</span> (b % p[i] == <span class="number">0</span>) b /= p[i], ++cb;</span><br><span class="line">                ans += (ca &gt; cb ? ca - cb : cb - ca);</span><br><span class="line">            &#125;</span><br><span class="line">        printf (<span class="string">&quot;%d. %d:%d\n&quot;</span>, ++cas,cnt, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ</category>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>URAL 1762 Search for a Hiding-Place(数学·模拟)</title>
    <url>/posts/oj/math/URAL%201762%20Search%20for%20a%20Hiding-Place(%E6%95%B0%E5%AD%A6%C2%B7%E6%A8%A1%E6%8B%9F)/</url>
    <content><![CDATA[<p>题意 你在一个n&#x2F;*m个白色正方形格子组成的矩形的某个顶点格子 你沿着45度角的方向走 到了边界就改变方向90度 每次经过一个格子都改变他原来的颜（白或灰） 求你走到另一个顶点格子时矩形中有多少格子是灰色的</p>
<p>这题可以用公式也可以直接模拟 模拟就是一直向右移n-1位 每次超过边界就可以把边界向右移m-1位 用cnt记录超过边界的次数 那么每次都会经过cnt个已经走过的格子 (每个格子最多经过2次) 答案也就减去2&#x2F;*cnt 直到刚好到达边界</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    ll n, m, cur, cnt, ans, k;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; m) <span class="title function_">swap</span>(n, m);</span><br><span class="line">        cur = ans = <span class="number">1</span>, cnt = <span class="number">0</span>, k = m;</span><br><span class="line">        <span class="keyword">while</span>(cur != k)</span><br><span class="line">        &#123;</span><br><span class="line">            cur += n - <span class="number">1</span>, ans += n - <span class="number">1</span> - <span class="number">2</span> * cnt;</span><br><span class="line">            <span class="keyword">if</span>(cur &gt; k) k += m - <span class="number">1</span>, ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Search-for-a-Hiding-Place"><a href="#Search-for-a-Hiding-Place" class="headerlink" title="Search for a Hiding-Place"></a>Search for a Hiding-Place</h2><p><img src="/../images/-image-get.aspx-76e9e33b-e7d0-476b-b059-544383bb9e8d.png" alt="Problem illustration"></p>
<p>Scooby-Doo is fond of adventures. This time he wanted to find a hiding-place in a vampire castle. After a long search, Scooby ended up in a huge rectangular hall with four entrances, one in each corner, through one of which he had entered. The floor was paved with white square tiles. Scooby thought that the hiding-place was under one of these tiles. He started searching for it by turning the tiles over, the grey side up. He began his search from a corner moving at an angle of 45° to the walls. Each time he came to a wall, he made a 90° turn. If he stepped on a grey tile, he turned it back the white side up. The search went on until Scooby reached an entrance at one of the corners. Then, not having found the hiding-place, the tired dog sighed and went out to have a snack.<br>Given the dimensions of the hall, calculate the total number of tiles that were turned the grey side up at the end of the search.</p>
<p>The only input line contains integers <em>n</em> and <em>m</em> separated with a space. They are the length and width of the hall measured in tiles (2 ≤ <em>n</em>, <em>m</em> ≤ 1 000 000).</p>
<p>In the only line output the number of grey tiles in the hall after Scooby-Doo’s search.</p>
<p>input output 7 5 11 2 3 3</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 11426 GCD - Extreme (II) (欧拉函数应用·O(N*logN))</title>
    <url>/posts/oj/math/UVa%2011426%20GCD%20-%20Extreme%20(II)%20(%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%C2%B7O(NlogN))/</url>
    <content><![CDATA[<p>题意 令**G(n) &#x3D; sum{gcd(i, j) | 0 &lt; i &lt; n, i &lt; j &lt;&#x3D; n}**给你一个n 输出G(n)</p>
<p>令<strong>F(n) &#x3D; sum{gcd(i, n) | 0 &lt; i &lt; n}</strong></p>
<p>那么有递推式<strong>G(n) &#x3D; G(n-1) + F(n) , G(0) &#x3D; 0</strong></p>
<p>也就是说只用求出F(n) 就能递推求出 G(n）了 而求F(n)就比较容易了</p>
<p>对于i 设<strong>x &lt; i , gcd(x,i) &#x3D; 1</strong>即x, n 互质</p>
<p>则**gcd(2&#x2F;*x, 2&#x2F;*i) &#x3D; 2, gcd(3&#x2F;*x, 3&#x2F;*i) &#x3D; 3, …, gcd(k&#x2F;<em>x, k&#x2F;<em>i) &#x3D; k</em></em></p>
<p>这样的x的个数就是i的欧拉函数值 那么我们求出i的欧拉函数后 所有的F(k&#x2F;*i) 都加上k 这样筛一下就能求出一定范围内所有的F函数值了 然后累加上去就是G的函数值了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">4000005</span>;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int phi[N];</span><br><span class="line">ll g[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">init</span>() <span class="comment">//O(N*logN) 筛欧拉函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">2</span>; i &lt; N; ++i) phi[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">2</span>; i &lt; N; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(phi[i] == i) <span class="comment">//i是素数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = i; j &lt; N; j += i)</span><br><span class="line">                phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//需要从j中删除一个素因子i  因为phi(p^k) = (p-1) * p^(k-1)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">1</span>; j * i &lt; N; j ++)</span><br><span class="line">            g[j * i] += j * phi[i];</span><br><span class="line">        <span class="comment">//phi[i]是小于i且与i互质的数的个数 j * i &lt; N 时 j * x 肯定也小于n</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; N; i ++) g[i] += g[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">init</span>();</span><br><span class="line">    int n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, g[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 1583 Digit Generator(数学)</title>
    <url>/posts/oj/math/UVa%201583%20Digit%20Generator(%E6%95%B0%E5%AD%A6)/</url>
    <content><![CDATA[<p>﻿﻿</p>
<p>题意 如果a加上a所有数位上的数等于b时 a称为b的generator 求给定数的最小generator</p>
<p>给的数n是小于100,000的 考虑到所有数位和最大的数99,999的数位和也才45 因此我们只需要从n-45到n枚举就行了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;  </span><br><span class="line">#include&lt;cstring&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line">int t, n, a, b, ans, l;  </span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    scanf (<span class="string">&quot;%d&quot;</span>, &amp;t);  </span><br><span class="line">    <span class="keyword">while</span> (t--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        scanf (<span class="string">&quot;%d&quot;</span>, &amp;n);  </span><br><span class="line">        ans = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span> (int i = n-<span class="number">50</span>; i &lt; n; ++i)  </span><br><span class="line">        &#123;  </span><br><span class="line">            a = b = i;  </span><br><span class="line">            <span class="keyword">while</span> (b)  </span><br><span class="line">            &#123;  </span><br><span class="line">                a += b % <span class="number">10</span>;  </span><br><span class="line">                b /= <span class="number">10</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (a + b == n)  </span><br><span class="line">            &#123;  </span><br><span class="line">                ans = i;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        printf (<span class="string">&quot;%d\n&quot;</span>, ans);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>For a positive integer <em>N</em> , the digit-sum of <em>N</em> is defined as the sum of <em>N</em> itself and its digits. When <em>M</em> is the digitsum of <em>N</em> , we call <em>N</em> a generator of <em>M</em> .</p>
<p>For example, the digit-sum of 245 is 256 (&#x3D; 245 + 2 + 4 + 5). Therefore, 245 is a generator of 256.</p>
<p>Not surprisingly, some numbers do not have any generators and some numbers have more than one generator. For example, the generators of 216 are 198 and 207.</p>
<p>You are to write a program to find the smallest generator of the given integer.</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>Your program is to read from standard input. The input consists of <em>T</em> test cases. The number of test cases <em>T</em> is given in the first line of the input. Each test case takes one line containing an integer <em>N</em> , 1<img src="/../images/dge.org-external-15-3355img1-.png" alt="$ \le$"><em>N</em><img src="/../images/dge.org-external-15-3355img1-.png" alt="$ \le$">100, 000 .</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>Your program is to write to standard output. Print exactly one line for each test case. The line is to contain a generator of <em>N</em> for each test case. If <em>N</em> has multiple generators, print the smallest. If <em>N</em> does not have any generators, print 0.</p>
<p>The following shows sample input and output for three test cases.</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>3 216 121 2005</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>198 0 1979</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 1587 Box</title>
    <url>/posts/oj/math/UVa%201587%20Box/</url>
    <content><![CDATA[<p>大水题一发 弄清长方体的几个面的关系就行了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">struct rec&#123; int l, w;&#125; r[N];</span><br><span class="line">bool <span class="title function_">cmp</span>(<span class="params">rec a, rec b</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="property">w</span> &lt; b.<span class="property">w</span> || (a.<span class="property">w</span> == b.<span class="property">w</span> &amp;&amp; a.<span class="property">l</span> &lt; b.<span class="property">l</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int a, b, ok;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;r[<span class="number">0</span>].<span class="property">w</span>, &amp;r[<span class="number">0</span>].<span class="property">l</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        ok = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(r[<span class="number">0</span>].<span class="property">w</span> &gt; r[<span class="number">0</span>].<span class="property">l</span>) <span class="title function_">swap</span>(r[<span class="number">0</span>].<span class="property">w</span>, r[<span class="number">0</span>].<span class="property">l</span>);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;r[i].<span class="property">w</span>, &amp;r[i].<span class="property">l</span>);</span><br><span class="line">            <span class="keyword">if</span>(r[i].<span class="property">w</span> &gt; r[i].<span class="property">l</span>) <span class="title function_">swap</span>(r[i].<span class="property">w</span>, r[i].<span class="property">l</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">sort</span>(r, r + N, cmp);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; N; i += <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span>(r[i].<span class="property">w</span> != r[i + <span class="number">1</span>].<span class="property">w</span> || r[i].<span class="property">l</span> != r[i + <span class="number">1</span>].<span class="property">l</span>) ok = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(r[<span class="number">0</span>].<span class="property">w</span> != r[<span class="number">2</span>].<span class="property">w</span> || r[<span class="number">0</span>].<span class="property">l</span> != r[<span class="number">4</span>].<span class="property">w</span> || r[<span class="number">2</span>].<span class="property">l</span> != r[<span class="number">4</span>].<span class="property">l</span>) ok = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">puts</span>(ok ? <span class="string">&quot;POSSIBLE&quot;</span> : <span class="string">&quot;IMPOSSIBLE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> Ivan works at a factory that produces heavy machinery. He has a simple job – he knocks up wooden boxes of different sizes to pack machinery for delivery to the customers. Each box is a rectangular parallelepiped. Ivan uses six rectangular wooden pallets to make a box. Each pallet is used for one side of the box.</p>
<p><img src="/../images/dge.org-external-15-p3214.jpg.png" alt="\epsfbox{p3214.eps}"> Joe delivers pallets for Ivan. Joe is not very smart and often makes mistakes – he brings Ivan pallets that do not fit together to make a box. But Joe does not trust Ivan. It always takes a lot of time to explain Joe that he has made a mistake. Fortunately, Joe adores everything related to computers and sincerely believes that computers never make mistakes. Ivan has decided to use this for his own advantage. Ivan asks you to write a program that given sizes of six rectangular pallets tells whether it is possible to make a box out of them.</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>Input file contains several test cases. Each of them consists of six lines. Each line describes one pallet and contains two integer numbers <em>w</em> and <em>h</em> (  1<img src="/../images/dge.org-external-15-3214img2-.png" alt="$ \le$"><em>w</em>, <em>h</em><img src="/../images/dge.org-external-15-3214img2-.png" alt="$ \le$">10 000 ) – width and height of the pallet in millimeters respectively.</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>For each test case, print one output line. Write a single word <code>POSSIBLE &#39; to the output file if it is possible to make a box using six given pallets for its sides. Write a single word</code> IMPOSSIBLE ‘ if it is not possible to do so.</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>1345 2584 2584 683 2584 1345 683 1345 683 1345 2584 683 1234 4567 1234 4567 4567 4321 4322 4567 4321 1234 4321 1234</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>POSSIBLE IMPOSSIBLE</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 1595 Symmetry(暴力)</title>
    <url>/posts/oj/math/UVa%201595%20Symmetry(%E6%9A%B4%E5%8A%9B)/</url>
    <content><![CDATA[<p>题意 给你不超过1000个点的坐标 判断这些点是否是关于一条竖线对称的</p>
<p>没想到暴力枚举可以过 如果存在对称轴的话那么对称轴的横坐标一定是最左边的点和最右边的点的中点 为了避免中点是小数 可以将横坐标都乘上2 然后在判断所有点是否有对称点就行了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1005</span>;</span><br><span class="line">int x[N], y[N], n, mx;</span><br><span class="line"></span><br><span class="line">bool <span class="title function_">have</span>(<span class="params">int i</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">        <span class="keyword">if</span>(y[i] == y[j] &amp;&amp; x[i] + x[j] == <span class="number">2</span> * mx) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas, lx, rx, a, i;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span>(cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        lx = rx = <span class="number">0</span>;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;y[i]);</span><br><span class="line">            x[i] = a * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(x[i] &lt; x[lx]) lx = i;</span><br><span class="line">            <span class="keyword">if</span>(x[i] &gt; x[rx]) rx = i;</span><br><span class="line">        &#125;</span><br><span class="line">        mx = (x[lx] + x[rx]) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(!<span class="title function_">have</span>(i)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= n) <span class="title function_">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="title function_">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The figure shown on the left is <em>left-right symmetric</em> as it is possible to fold the sheet of paper along a <em>vertical line</em>, drawn as a dashed line, and to cut the figure into two identical halves. The figure on the right is not left-right symmetric as it is impossible to find such a vertical line.</p>
<p><img src="/../images/dge.org-external-15-p3226.jpg.png" alt="\epsfbox{p3226.eps}"></p>
<p>Write a program that determines whether a figure, drawn with dots, is left-right symmetric or not. The dots are all distinct.</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>The input consists of <em>T</em> test cases. The number of test cases <em>T</em> is given in the first line of the input file. The first line of each test case contains an integer <em>N</em> , where <em>N</em> ( 1<img src="/../images/dge.org-external-15-3226img2.gif.png" alt="$ \le$"><em>N</em><img src="/../images/dge.org-external-15-3226img2.gif.png" alt="$ \le$">1, 000) is the number of dots in a figure. Each of the following <em>N</em> lines contains the <em>x</em>-coordinate and <em>y</em>-coordinate of a dot. Both <em>x</em>-coordinates and <em>y</em>-coordinates are integers between -10,000 and 10,000, both inclusive.</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>Print exactly one line for each test case. The line should contain <code>YES&#39; if the figure is left-right symmetric. and </code>NO’, otherwise.</p>
<p>The following shows sample input and output for three test cases.</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>3 5 -2 5 0 0 6 5 4 0 2 3 4 2 3 0 4 4 0 0 0 4 5 14 6 10 5 10 6 14</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>YES NO YES</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>ZOJ 3622 Magic Number(数)</title>
    <url>/posts/oj/math/ZOJ%203622%20Magic%20Number(%E6%95%B0)/</url>
    <content><![CDATA[<p>题意 如果一个正整数y满足 将任意正整数x放到y的左边得到的数z满足 z%y&#x3D;&#x3D;0 那么这个数就是个Magic Number 给你一个范围 求这个范围内Magic Number的个数</p>
<p>令 l表示y的位数 ly&#x3D;10^l 那么z&#x3D;x&#x2F;*ly + y 要z%y&#x3D;&#x3D;0 容易看出 只需 x&#x2F;*ly%y&#x3D;&#x3D;0</p>
<p>又因为x是任意的 所以一个Magic Number必须满足 ly%y&#x3D;&#x3D;0</p>
<p>y&lt;2^31 所以l最大为10 直接枚举l 找到所有符合的y就行了</p>
<p>当ly%y&#x3D;&#x3D;0时y&gt;&#x3D;ly&#x2F;10&amp;&amp;y&lt;ly即ly是比y多一位数的令t&#x3D;ly&#x2F;y 那么肯定有1&lt;t&lt;&#x3D;10对于每个ly 我们就只用枚举t了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">50</span>;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll p[N], n, m;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cnt = <span class="number">0</span>, ans;   <span class="comment">//ly为10^l</span></span><br><span class="line">    <span class="keyword">for</span>(ll ly = <span class="number">10</span>; ly &lt; <span class="number">1e11</span>; ly *= <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(ll t = <span class="number">10</span>; t &gt; <span class="number">1</span>; --t)  <span class="comment">//若(ly/y==t) 必有1&lt;t&lt;=10</span></span><br><span class="line">            <span class="keyword">if</span>(ly % t == <span class="number">0</span>) p[cnt++] = ly / t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="title function_">upper_bound</span>(p, p + cnt, m) - <span class="title function_">lower_bound</span>(p, p + cnt, n);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  Magic Number    Time Limit:2 Seconds Memory Limit:32768 KB</p>
<p>A positive number <em>y</em> is called magic number if for every positive integer <em>x</em> it satisfies that put <em>y</em> to the right of <em>x</em>, which will form a new integer <em>z</em>, <em>z</em> mod <em>y</em> &#x3D; 0.</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>The input has multiple cases, each case contains two positve integers <em>m</em>, <em>n</em>(1 &lt;&#x3D; <em>m</em> &lt;&#x3D; <em>n</em> &lt;&#x3D; 2^31-1), proceed to the end of file.</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>For each case, output the total number of magic numbers between <em>m</em> and <em>n</em>(<em>m</em>, <em>n</em> inclusively).</p>
<h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h4><p>1 1 1 10</p>
<h4 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h4><p>1 4</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>hiho一下·41 骨牌覆盖问题·一(矩阵快速幂·费波拉契)</title>
    <url>/posts/oj/math/hiho%E4%B8%80%E4%B8%8B%C2%B741%20%E9%AA%A8%E7%89%8C%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98%C2%B7%E4%B8%80(%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%C2%B7%E8%B4%B9%E6%B3%A2%E6%8B%89%E5%A5%91)/</url>
    <content><![CDATA[<p>题意 求费波拉契数列第N项 1≤N≤100,000,000</p>
<p>通过矩阵的幂 可以把一维递推的时间复杂度减小到O(logN) 主要就是快速幂的思想</p>
<p>对于m^n 若<strong>n&#x3D;2^a1+2^a2+…+2^ak</strong>那么**m^n &#x3D; m^(2^a1) &#x2F;****<em>m^(2^a2) &#x2F;</em> … &#x2F;*****m^(2^ak)**那么只用看n转换为二进制后哪些位为1就可以快速求出m^n了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line">typedef long long <span class="variable constant_">LL</span>;  </span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">2</span>;  </span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">LL</span> <span class="variable constant_">MOD</span> = <span class="number">19999997</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//将矩阵a*b的结果放入c  </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">matMul</span>(<span class="params">LL a[][N], LL b[][N], LL c[][N]</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="variable constant_">LL</span> ret[N][N] = &#123;<span class="number">0</span>&#125;;  </span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; N; ++i)  </span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; N; ++j)  </span><br><span class="line">            <span class="keyword">for</span>(int k = <span class="number">0</span>; k &lt; N; ++k)  </span><br><span class="line">                ret[i][j] = (ret[i][j] + a[i][k] * b[k][j]) % <span class="variable constant_">MOD</span>;  </span><br><span class="line">    <span class="title function_">memcpy</span>(c, ret, <span class="title function_">sizeof</span>(ret));  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//将a^n放入a  </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">matPow</span>(<span class="params">LL a[][N], int n</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="variable constant_">LL</span> ret[N][N] = &#123;<span class="number">0</span>&#125;;  </span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; N; ++i) </span><br><span class="line">        ret[i][i] = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">while</span>(n)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>) <span class="title function_">matMul</span>(ret, a, ret);  </span><br><span class="line">        <span class="title function_">matMul</span>(a, a, a);  </span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="title function_">memcpy</span>(a,ret,<span class="title function_">sizeof</span>(ret));</span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    int n;  </span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n))  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="variable constant_">LL</span> a[N][N] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;  </span><br><span class="line">        <span class="title function_">matPow</span>(a, n);  </span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, a[<span class="number">1</span>][<span class="number">1</span>] % <span class="variable constant_">MOD</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间限制: 10000ms</p>
<p>单点时限: 1000ms<br>内存限制: 256MB</p>
<h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>骨牌，一种古老的玩具。今天我们要研究的是骨牌的覆盖问题：<br>我们有一个2xN的长条形棋盘，然后用1x2的骨牌去覆盖整个棋盘。对于这个棋盘，一共有多少种不同的覆盖方法呢？<br>举个例子，对于长度为1到3的棋盘，我们有下面几种覆盖方式：</p>
<p><img src="/../images/der.com-problem_images-20150411-1428731713269-.png" title="week41_1.PNG"></p>
<p><a href="http://hihocoder.com/contest/hiho41/problem/1#">提示：骨牌覆盖</a></p>
<p><a href="http://hihocoder.com/contest/hiho41/problem/1#">提示：如何快速计算结果</a></p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>第1行：1个整数N。表示棋盘长度。1≤N≤100,000,000</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>第1行：1个整数，表示覆盖方案数 MOD 19999997<br>样例输入 62247088 样例输出 17748018</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforce 264 A Caisa and Sugar(简单)</title>
    <url>/posts/oj/other/Codeforce%20264%20A%20Caisa%20and%20Sugar(%E7%AE%80%E5%8D%95)/</url>
    <content><![CDATA[<p>Caisa去商店买Sugar 商店找零的最低单位为元 低于1元的部分每分找一个糖果 商店有n种Suger Caisa有s元钱 她只买一种Sugar 输入n s 再输入n行 每行两个数a b 表示第i种Sugar的单价为a元b分 求Sugar最多能被找多少糖果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int  n, s, cos;</span><br><span class="line">    <span class="keyword">while</span> (~scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;s))</span><br><span class="line">    &#123;</span><br><span class="line">        s *= <span class="number">100</span>;</span><br><span class="line">        int flag = <span class="number">0</span>, a, b, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n--)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            cos = a * <span class="number">100</span> + b;</span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">1</span>; cos * j &lt;= s; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                ans = max (ans, (s - cos) % <span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf (<span class="string">&quot;%d\n&quot;</span>, flag ? ans : -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Caisais going to have a party and he needs to buy the ingredients for a big chocolate cake. For that he is going to the biggest supermarket in town.</p>
<p>Unfortunately, he has just<em>s</em>dollars for sugar. But that’s not a reason to be sad, because there are<em>n</em>types of sugar in the supermarket, maybe he able to buy one. But that’s not all. The supermarket has very unusual exchange politics: instead of cents the sellers give sweets to a buyer as a change. Of course, the number of given sweets always doesn’t exceed99, because each seller maximizes the number of dollars in the change (100cents can be replaced with a dollar).</p>
<p>Caisa wants to buy only one type of sugar, also he wants to maximize the number of sweets in the change. What is the maximum number of sweets he can get? Note, that Caisa doesn’t want to minimize the cost of the sugar, he only wants to get maximum number of sweets as change.<br>Input</p>
<p>The first line contains two space-separated integers<em>n</em>, <em>s</em>(1 ≤ <em>n</em>, <em>s</em> ≤ 100).</p>
<p>The<em>i</em>-th of the next<em>n</em>lines contains two integers<em>x**i</em>,<em>y**i</em>(1 ≤ <em>x**i</em> ≤ 100; 0 ≤ <em>y**i</em> &lt; 100), where<em>x**i</em>represents the number of dollars and<em>y**i</em>the number of cents needed in order to buy the<em>i</em>-th type of sugar.</p>
<p>Output</p>
<p>Print a single integer representing the maximum number of sweetshe can buy, or-1if he can’t buy any type of sugar.<br>Sample test(s)</p>
<p>input 5 10 3 90 12 0 9 70 5 50 7 0</p>
<p>output 50<br>input 5 5 10 10 20 20 30 30 40 40 50 50</p>
<p>output -1</p>
<p>Note</p>
<p>In the first test sample Caisa can buy the fourth type of sugar, in such a case he will take50sweets as a change.</p>
<p>﻿﻿</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforce 264 B Caisa and Pylons(模拟)</title>
    <url>/posts/oj/other/Codeforce%20264%20B%20Caisa%20and%20Pylons(%E6%A8%A1%E6%8B%9F)/</url>
    <content><![CDATA[<p>﻿﻿</p>
<p>题意 Caisa走台阶 有n个台阶 第i个台阶的高度为h[i] 从第i个台阶包括地面到下一个台阶得到的能量为h[i]-h[i+1] 能量不足以跳到下一个台阶就要补充能量 求Caisa跳完所有台阶最少要补充多少能量</p>
<p>水题 直接模拟</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">100005</span>;</span><br><span class="line">int h[N];</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, e, ans;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        scanf (<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (int i = e = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (h[i] + e &lt; h[i + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            int t = (h[i + <span class="number">1</span>] - e - h[i]);</span><br><span class="line">            h[i] += t;</span><br><span class="line">            ans += t;</span><br><span class="line">        &#125;</span><br><span class="line">        e += (h[i] - h[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf (<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Caisa solved the problem with the sugar and now he is on the way back to home.</p>
<p>Caisa is playing a mobile game during his path. There are(<em>n</em> + 1)pylons numbered from0to<em>n</em>in this game. The pylon with number0has zero height, the pylon with number<em>i</em>(<em>i</em> &gt; 0)has height<em>h**i</em>. The goal of the game is to reach<em>n</em>-th pylon, and the only move the player can do is to jump from the current pylon (let’s denote its number as<em>k</em>) to the next one (its number will be<em>k</em> + 1). When the player have made such a move, its energy increases by<em>h**k</em> - <em>h**k</em> + 1(if this value is negative the player loses energy). The player must have non-negative amount of energy at any moment of the time.</p>
<p>Initially Caisa stand at0pylon and has0energy. The game provides a special opportunity: one can pay a single dollar and increase the height of anyone pylon by one. Caisa may use that opportunity several times, but he doesn’t want to spend too much money. What is the minimal amount of money he must paid to reach the goal of the game?<br>Input</p>
<p>The first line contains integer<em>n</em>(1 ≤ <em>n</em> ≤ 105). The next line contains<em>n</em>integers<em>h</em>1,<em>h</em>2, …,<em>h**n</em>(1  ≤  <em>h**i</em>  ≤  105)representing the heights of the pylons.</p>
<p>Output</p>
<p>Print a single number representing the minimum number of dollars paid by Caisa.<br>Sample test(s)</p>
<p>input 5 3 4 3 2 4</p>
<p>output 4<br>input 3 4 4 4</p>
<p>output 4</p>
<p>Note</p>
<p>In the first sample he can pay4dollars and increase the height of pylon with number0by4units. Then he can safely pass to the last pylon.</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 230C Shifts(模拟)</title>
    <url>/posts/oj/other/Codeforces%20230C%20Shifts(%E6%A8%A1%E6%8B%9F)/</url>
    <content><![CDATA[<p>题意 有n个m列的转盘 每个转盘的某一列为1或0 你每次可以将某个转盘转动一格 问至少转多少次使得某一列n个转盘上的数都是1</p>
<p>把每个转盘的所有列转为1所需要的最小时间都存起来 可以以某一个1为基点顺时针逆时针各转一圈就可以把每个点需要转的次数算出来 最后看哪一列的和最小就行了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">105</span>, M = <span class="number">10005</span>;</span><br><span class="line">int d[M], t[M], n, m;</span><br><span class="line">char g[N][M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">gett</span>(<span class="params">int r, int c</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int p = (c + <span class="number">1</span>) % m, cnt = t[c] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != c) <span class="comment">//顺时针转一圈</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(g[r][p] == <span class="string">&#x27;1&#x27;</span>) cnt = -<span class="number">1</span>;</span><br><span class="line">        t[p] = ++cnt;</span><br><span class="line">        p = (p + <span class="number">1</span>) % m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = (p + m - <span class="number">1</span>) % m, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != c) <span class="comment">//逆时针转一圈</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(g[r][p] == <span class="string">&#x27;1&#x27;</span>) cnt = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(t[p] &gt; cnt + <span class="number">1</span>) t[p] = cnt + <span class="number">1</span>;</span><br><span class="line">        d[p] += t[p], ++cnt;</span><br><span class="line">        p = (p + m - <span class="number">1</span>) % m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">memset</span>(d, <span class="number">0</span>, <span class="title function_">sizeof</span>(d));</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i) <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, g[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">                <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;1&#x27;</span>) <span class="title function_">gett</span>(i, j), j = m;</span><br><span class="line">            <span class="keyword">if</span>(j == m) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">sort</span>(d, d + m);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i &lt; n ? -<span class="number">1</span> : d[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C. Shifts<br>You are given a table consisting of <em>n</em> rows and <em>m</em> columns. Each cell of the table contains a number, 0 or 1. In one move we can choose some row of the table and cyclically shift its values either one cell to the left, or one cell to the right.</p>
<p>To cyclically shift a table row one cell to the right means to move the value of each cell, except for the last one, to the right neighboring cell, and to move the value of the last cell to the first cell. A cyclical shift of a row to the left is performed similarly, but in the other direction. For example, if we cyclically shift a row “00110” one cell to the right, we get a row “00011”, but if we shift a row “00110” one cell to the left, we get a row “01100”.</p>
<p>Determine the minimum number of moves needed to make some table column consist only of numbers 1.</p>
<p>Input</p>
<p>The first line contains two space-separated integers: <em>n</em> (1 ≤ <em>n</em> ≤ 100) — the number of rows in the table and <em>m</em> (1 ≤ <em>m</em> ≤ 104) — the number of columns in the table. Then <em>n</em> lines follow, each of them contains <em>m</em> characters “0” or “1”: the <em>j</em>-th character of the <em>i</em>-th line describes the contents of the cell in the <em>i</em>-th row and in the <em>j</em>-th column of the table.</p>
<p>It is guaranteed that the description of the table contains no other characters besides “0” and “1”.<br>Output</p>
<p>Print a single number: the minimum number of moves needed to get only numbers 1 in some column of the table. If this is impossible, print -1.</p>
<p>Sample test(s)</p>
<p>input 3 6 101010 000100 100000</p>
<p>output 3<br>input 2 3 111 000</p>
<p>output -1</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 534D Handshakes(贪心)</title>
    <url>/posts/oj/other/Codeforces%20534D%20Handshakes(%E8%B4%AA%E5%BF%83)/</url>
    <content><![CDATA[<p>题意 房子里有n个人走进来 编号1~n 每个人走进来时房子里所有空闲的人都会和他招手 空闲的某三个人可以选择一起去打比赛 当然打比赛就变得不空闲了 给你每个人进来时和他招手的人的数量 要求输出一种可能的进房间顺序 没有可能的就输出Impossible</p>
<p>这题放在d就比较简单了 直接贪心就可以 把招手数量为i对应的人都保存到栈s[i]里 第一个进房间的人肯定是s[0]里的 然后让i从0开始 s[i]非空时 让s[i]的栈顶的人进入房间 然后i++ 否则让s[i-1],s[i-2],s[i-3]都出栈一个 再让i&#x3D;i-3 也就是有3个人去打比赛了 一直这样循环下去直到所有人都进入房间或者i&lt;0(对应不可能的情况) 最后输出进入房间的序列就行了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">int q[N], n;</span><br><span class="line">stack&lt;int&gt; s[N];</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a), s[a].<span class="title function_">push</span>(i);</span><br><span class="line"></span><br><span class="line">    int p = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!s[i].<span class="title function_">empty</span>())  q[p++] = s[i++].<span class="title function_">top</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//出栈三个人去打比赛</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; <span class="number">3</span>) <span class="keyword">break</span>;</span><br><span class="line">            s[--i].<span class="title function_">pop</span>(), s[--i].<span class="title function_">pop</span>(), s[--i].<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">puts</span>(<span class="string">&quot;Possible&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, q[n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="title function_">puts</span>(<span class="string">&quot;Impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Last modified :   2015-04-13 01:57</span></span><br></pre></td></tr></table></figure>

<p>D. Handshakes<br>On February, 30th <em>n</em> students came in the Center for Training Olympiad Programmers (CTOP) of the Berland State University. They came one by one, one after another. Each of them went in, and before sitting down at his desk, greeted with those who were present in the room by shaking hands. Each of the students who came in stayed in CTOP until the end of the day and never left.</p>
<p>At any time any three students could join together and start participating in a team contest, which lasted until the end of the day. The team did not distract from the contest for a minute, so when another student came in and greeted those who were present, he did not shake hands with the members of the contest writing team. Each team consisted of exactly three students, and each student could not become a member of more than one team. Different teams could start writing contest at different times.</p>
<p>Given how many present people shook the hands of each student, get a possible order in which the students could have come to CTOP. If such an order does not exist, then print that this is impossible.</p>
<p>Please note that some students could work independently until the end of the day, without participating in a team contest.</p>
<p>Input</p>
<p>The first line contains integer <em>n</em> (1 ≤ <em>n</em> ≤ 2·105) — the number of students who came to CTOP. The next line contains <em>n</em> integers<em>a</em>1, <em>a</em>2, …, <em>a**n</em> (0 ≤ <em>a**i</em> &lt; <em>n</em>), where <em>a**i</em> is the number of students with who the <em>i</em>-th student shook hands.<br>Output</p>
<p>If the sought order of students exists, print in the first line “Possible” and in the second line print the permutation of the students’ numbers defining the order in which the students entered the center. Number <em>i</em> that stands to the left of number <em>j</em> in this permutation means that the <em>i</em>-th student came earlier than the <em>j</em>-th student. If there are multiple answers, print any of them.</p>
<p>If the sought order of students doesn’t exist, in a single line print “Impossible”.</p>
<p>Sample test(s)</p>
<p>input 5 2 1 3 0 1</p>
<p>output Possible 4 5 1 3 2<br>input 9 0 2 3 4 1 1 0 2 2</p>
<p>output Possible 7 5 2 1 6 8 3 4 9<br>input 4 0 2 1 1</p>
<p>output Impossible</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 2577 How to Type(模拟)</title>
    <url>/posts/oj/other/HDU%202577%20How%20to%20Type(%E6%A8%A1%E6%8B%9F)/</url>
    <content><![CDATA[<p>题目链接 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2577">http://acm.hdu.edu.cn/showproblem.php?pid=2577</a></p>
<p>题意 给你一个由大写字母和小写字母组成的字符串 模拟键盘输入的最少按键次数</p>
<p>直接模拟每个字符的输入 flag表示capslock的状态 1表示打开 0为关闭 开始是和输入完毕都是关闭的关闭的 用plu记录shift和capslock的按键次数</p>
<p>当接下来输入的字母有连续n个跟capslock状态不同时 分析可只 只有n&#x3D;1时适合用shift键</p>
<p>如flag&#x3D;1 n&#x3D;1 输入a时 shift+a&#x3D;2 而capslock+a+capslock&#x3D;3</p>
<p>n&gt;&#x3D;2 如输入ab是 shift+a+shift+b&#x3D;4 capslock+a+b+capslock&#x3D;4</p>
<p>所以每次输入的字母如capslock状态不同时 就看有几个连续状态不同的字母 然后再选择用什么键</p>
<p>注意有一个例外当最后只有一个字母小写 capslock打开时 也应该用capslock 因为最后要换位小写状态</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">105</span>;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    char s[N]; int cas, t;</span><br><span class="line">    scanf (<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span> (cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf (<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">        int l = strlen (s + <span class="number">1</span>), plu = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= l; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (flag) <span class="keyword">while</span> (islower (s[i])) ++t, ++i;</span><br><span class="line">            <span class="keyword">else</span>      <span class="keyword">while</span> (isupper (s[i])) ++t, ++i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t &gt; <span class="number">1</span>||(i == l + <span class="number">1</span> &amp;&amp; islower (s[l]) &amp;&amp; t == <span class="number">1</span>))</span><br><span class="line">                flag = !flag, ++plu, --i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">1</span>)</span><br><span class="line">                ++plu, --i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flag) ++plu;</span><br><span class="line">        printf (<span class="string">&quot;%d\n&quot;</span>, l + plu);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="How-to-Type"><a href="#How-to-Type" class="headerlink" title="How to Type"></a>How to Type</h1><p>Problem Description</p>
<p>Pirates have finished developing the typing software. He called Cathy to test his typing software. She is good at thinking. After testing for several days, she finds that if she types a string by some ways, she will type the key at least. But she has a bad habit that if the caps lock is on, she must turn off it, after she finishes typing. Now she wants to know the smallest times of typing the key to finish typing a string.<br>Input</p>
<p>The first line is an integer t (t&lt;&#x3D;100), which is the number of test case in the input file. For each test case, there is only one string which consists of lowercase letter and upper case letter. The length of the string is at most 100.<br>Output</p>
<p>For each test case, you must output the smallest times of typing the key to finish typing this string.<br>Sample Input</p>
<p>3 Pirates HDUacm HDUACM<br>Sample Output</p>
<p>8 8 8</p>
<p><em>Hint</em> The string “Pirates”, can type this way, Shift, p, i, r, a, t, e, s, the answer is 8. The string “HDUacm”, can type this way, Caps lock, h, d, u, Caps lock, a, c, m, the answer is 8 The string “HDUACM”, can type this way Caps lock h, d, u, a, c, m, Caps lock, the answer is 8</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 4883 TIANKENG’s restaurant(模拟)</title>
    <url>/posts/oj/other/HDU%204883%20TIANKENG%E2%80%99s%20restaurant(%E6%A8%A1%E6%8B%9F)/</url>
    <content><![CDATA[<p>题意 天坑开了个饭店 他知道所有客人的进来时间和出去的时间 求天坑至少准备多少张凳子</p>
<p>以分钟为单位 直接模拟就行了 peo[i]代表第i分钟的人 第i组人第si分钟进来 第so分钟出去 那么j从si到so peo[j]都加上这组的人数 最后看第几分钟人最多就是答案了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;  </span><br><span class="line">#include&lt;cstring&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1441</span>;  </span><br><span class="line">int hi, ho, mi, mo, si, so, t, n, ans, p, peo[N];  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    scanf (<span class="string">&quot;%d&quot;</span>, &amp;t);  </span><br><span class="line">    <span class="keyword">while</span> (t--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        scanf (<span class="string">&quot;%d&quot;</span>, &amp;n);  </span><br><span class="line">        memset (peo, <span class="number">0</span>, sizeof (peo));  </span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)  </span><br><span class="line">        &#123;  </span><br><span class="line">            scanf (<span class="string">&quot;%d %d:%d %d:%d&quot;</span>, &amp;p, &amp;hi, &amp;mi, &amp;ho, &amp;mo);  </span><br><span class="line">            si = hi * <span class="number">60</span> + mi;  </span><br><span class="line">            so = ho * <span class="number">60</span> + mo;  </span><br><span class="line">            <span class="keyword">for</span> (int j = si; j &lt; so; ++j)  </span><br><span class="line">                peo[j] += p;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span> (int i = ans = <span class="number">1</span>; i &lt; N; ++i)  </span><br><span class="line">            <span class="keyword">if</span> (peo[i] &gt; ans) ans = peo[i];  </span><br><span class="line">        printf (<span class="string">&quot;%d\n&quot;</span>, ans);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="TIANKENG’s-restaurant"><a href="#TIANKENG’s-restaurant" class="headerlink" title="TIANKENG’s restaurant"></a>TIANKENG’s restaurant</h1><p>Problem Description</p>
<p>TIANKENG manages a restaurant after graduating from ZCMU, and tens of thousands of customers come to have meal because of its delicious dishes. Today n groups of customers come to enjoy their meal, and there are Xi persons in the ith group in sum. Assuming that each customer can own only one chair. Now we know the arriving time STi and departure time EDi of each group. Could you help TIANKENG calculate the minimum chairs he needs to prepare so that every customer can take a seat when arriving the restaurant?<br>Input</p>
<p>The first line contains a positive integer T(T&lt;&#x3D;100), standing for T test cases in all. Each cases has a positive integer n(1&lt;&#x3D;n&lt;&#x3D;10000), which means n groups of customer. Then following n lines, each line there is a positive integer Xi(1&lt;&#x3D;Xi&lt;&#x3D;100), referring to the sum of the number of the ith group people, and the arriving time STi and departure time Edi(the time format is hh:mm, 0&lt;&#x3D;hh&lt;24, 0&lt;&#x3D;mm&lt;60), Given that the arriving time must be earlier than the departure time. Pay attention that when a group of people arrive at the restaurant as soon as a group of people leaves from the restaurant, then the arriving group can be arranged to take their seats if the seats are enough.<br>Output</p>
<p>For each test case, output the minimum number of chair that TIANKENG needs to prepare.<br>Sample Input</p>
<p>2 2 6 08:00 09:00 5 08:59 09:59 2 6 08:00 09:00 5 09:00 10:00<br>Sample Output</p>
<p>11 6</p>
<p>﻿﻿</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 4907 BestCoder3_1 Task schedule</title>
    <url>/posts/oj/other/HDU%204907%20BestCoder3_1%20Task%20schedule/</url>
    <content><![CDATA[<h1 id="Task-schedule"><a href="#Task-schedule" class="headerlink" title="Task schedule"></a>Task schedule</h1><p>Time Limit: 2000&#x2F;1000 MS (Java&#x2F;Others) Memory Limit: 32768&#x2F;32768 K (Java&#x2F;Others)<br>Total Submission(s): 0 Accepted Submission(s): 0<br>Problem Description</p>
<p>有一台机器，并且给你这台机器的工作表，工作表上有n个任务，机器在ti时间执行第i个任务，1秒即可完成1个任务。<br>有m个询问，每个询问有一个数字q，表示如果在q时间有一个工作表之外的任务请求，请计算何时这个任务才能被执行。<br>机器总是按照工作表执行，当机器空闲时立即执行工作表之外的任务请求。<br>Input</p>
<p>输入的第一行包含一个整数T， 表示一共有T组测试数据。<br>对于每组测试数据：<br>第一行是两个数字n, m，表示工作表里面有n个任务, 有m个询问；<br>第二行是n个不同的数字t1, t2, t3….tn，表示机器在ti时间执行第i个任务。<br>接下来m行，每一行有一个数字q，表示在q时间有一个工作表之外的任务请求。<br>特别提醒：m个询问之间是无关的。<br>[Technical Specification]</p>
<ol>
<li>T &lt;&#x3D; 50</li>
<li>1 &lt;&#x3D; n, m &lt;&#x3D; 10^5</li>
<li>1 &lt;&#x3D; ti &lt;&#x3D; 2&#x2F;*10^5, 1 &lt;&#x3D; i &lt;&#x3D; n</li>
<li>1 &lt;&#x3D; q &lt;&#x3D; 2&#x2F;*10^5<br>Output</li>
</ol>
<p>对于每一个询问，请计算并输出该任务何时才能被执行，每个询问输出一行。<br>Sample Input</p>
<p>1 5 5 1 2 3 5 6 1 2 3 4 5<br>Sample Output</p>
<p>4 4 4 4 7</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从前往后直接暴力会超时</span></span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line">int busy[N], ans[N], m, n, t, cas, q;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    scanf (<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span> (cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        memset (busy, <span class="number">0</span>, sizeof (busy));</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            scanf (<span class="string">&quot;%d&quot;</span>, &amp;t), busy[t] = <span class="number">1</span>;</span><br><span class="line">        ans[<span class="number">200001</span>] = <span class="number">200001</span>;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">200000</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">            <span class="keyword">if</span> (busy[i]) ans[i] = ans[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> ans[i] = i;</span><br><span class="line">        <span class="keyword">while</span> (m--)</span><br><span class="line">            scanf (<span class="string">&quot;%d&quot;</span>, &amp;q), printf (<span class="string">&quot;%d\n&quot;</span>, ans[q]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ</category>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3087 Shuffle&#39;m Up（模拟）</title>
    <url>/posts/oj/other/POJ%203087%20Shuffle&#39;m%20Up%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89/</url>
    <content><![CDATA[<p>题意 给两堆牌s1,s2交给你洗 每堆有c张 每次洗牌得到s12 其中s2的最下面一张在s12的最下面一张然后按顺序一张s1一张s2 洗好之后可以把s12下面的c张做s1 上面的c张做s2 求多少次洗牌之后可以得到输入给你的串s 不能得到输出-1</p>
<p>简单模拟 s1+s2!&#x3D;s就一直洗牌 如果回到初始状态都没得到s就不会得到s了 得到s就可以输出洗牌次数了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int cas, c, ans;</span><br><span class="line">string s, bs, s12, s1, s2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> shuf (string s1, string s2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bs == s) <span class="keyword">return</span>;</span><br><span class="line">    ++ans;</span><br><span class="line">    int i = -<span class="number">1</span>, j = -<span class="number">1</span>, k;</span><br><span class="line">    string ss1, ss2;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; c; ++k)</span><br><span class="line">        ss1 += (i == j ? s2[++i] : s1[++j]);</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; c; ++k)</span><br><span class="line">        ss2 += (i == j ? s2[++i] : s1[++j]);</span><br><span class="line">    s12 = ss1 + ss2;</span><br><span class="line">    <span class="keyword">if</span> (s12 == s || s12 == bs) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> shuf (ss1, ss2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; cas;</span><br><span class="line">    <span class="keyword">for</span> (int ca = <span class="number">1</span>; ca &lt;= cas; ++ca)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; c &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; s;</span><br><span class="line">        bs = s1 + s2;</span><br><span class="line">        shuf (s1, s2);</span><br><span class="line">        <span class="keyword">if</span> (s12 != s) ans = -<span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt; ca &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以用bfs来做 每次出队入队的也只有一个 和模拟差不多</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">105</span>;</span><br><span class="line">string q[N], ss, ts;</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">bfs</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    string cs, s;</span><br><span class="line">    int le = <span class="number">0</span>, ri = <span class="number">0</span>;</span><br><span class="line">    q[ri++] = ss;</span><br><span class="line">    <span class="keyword">while</span>(le &lt; ri)</span><br><span class="line">    &#123;</span><br><span class="line">        cs = q[le++];</span><br><span class="line">        <span class="keyword">if</span>(cs == ts) <span class="keyword">return</span> le - <span class="number">1</span>;</span><br><span class="line">        s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            s += cs[n + i], s += cs[i];</span><br><span class="line">        <span class="keyword">if</span>(s == ss) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        q[ri++] = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas;</span><br><span class="line">    char a[N], b[N], s[<span class="number">2</span> * N];</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">for</span>(int k = <span class="number">1</span>; k &lt;= cas; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d%s%s%s&quot;</span>, &amp;n, a, b, s);</span><br><span class="line">        ts = <span class="title function_">string</span>(s), ss = <span class="title function_">string</span>(a) + b;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, k, <span class="title function_">bfs</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>附上此题数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">11</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">AHAH</span></span><br><span class="line"><span class="comment">HAHA</span></span><br><span class="line"><span class="comment">HHAAAAHH</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">CDE</span></span><br><span class="line"><span class="comment">CDE</span></span><br><span class="line"><span class="comment">EEDDCC</span></span><br><span class="line"><span class="comment">9</span></span><br><span class="line"><span class="comment">ACCABCABC</span></span><br><span class="line"><span class="comment">DEFDEFDEF</span></span><br><span class="line"><span class="comment">ECECECAFAFAFDBDBDB</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">ABCDEFGHCD</span></span><br><span class="line"><span class="comment">AAAAAAAAAA</span></span><br><span class="line"><span class="comment">BDFHDAAAAAACEGCAAAAA</span></span><br><span class="line"><span class="comment">100</span></span><br><span class="line"><span class="comment">ABCDEFGHCDABCDEFGHCDABCDEFGHCDABCDEFGHCDABCDEFGHCDABCDEFGHCDABCDEFGHCDABCDEFGHCDABCDEFGHCDABCDEFGHCD</span></span><br><span class="line"><span class="comment">ABCDEFGHCDABCDEFGHCDABCDEFGHCDABCDEFGHCDABCDEFGHCDABCDEFGHCDABCDEFGHCDABCDEFGHCDABCDEFGHCDABCDEFGHCD</span></span><br><span class="line"><span class="comment">CEGCACEGCACEGCACEGCACEGCADFHDBDFHDBDFHDBDFHDBDFHDBEGCACEGCACEGCACEGCACEGCACFHDBDFHDBDFHDBDFHDBDFHDBDGCACEGCACEGCACEGCACEGCACEHDBDFHDBDFHDBDFHDBDFHDBDFCACEGCACEGCACEGCACEGCACEGDBDFHDBDFHDBDFHDBDFHDBDFH</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">AAAAA</span></span><br><span class="line"><span class="comment">BBBBB</span></span><br><span class="line"><span class="comment">AABBBAAABB</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">AAAAAA</span></span><br><span class="line"><span class="comment">BBBBBB</span></span><br><span class="line"><span class="comment">AAABBBAAABBB</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">AAAAAAA</span></span><br><span class="line"><span class="comment">BBBBBBB</span></span><br><span class="line"><span class="comment">ABBAABBAABBAAB</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">AAAAAAAA</span></span><br><span class="line"><span class="comment">BBBBBBBB</span></span><br><span class="line"><span class="comment">BBAABBAABBAABBAA</span></span><br><span class="line"><span class="comment">9</span></span><br><span class="line"><span class="comment">AAAAAAAAA</span></span><br><span class="line"><span class="comment">BBBBBBBBB</span></span><br><span class="line"><span class="comment">BBBBAAAAABBBBBAAAA</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">AAAAAAAAAA</span></span><br><span class="line"><span class="comment">BBBBBBBBBB</span></span><br><span class="line"><span class="comment">BBAABBAABBAABBAABBAA</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">2 -1</span></span><br><span class="line"><span class="comment">3 -1</span></span><br><span class="line"><span class="comment">4 5</span></span><br><span class="line"><span class="comment">5 30</span></span><br><span class="line"><span class="comment">6 9</span></span><br><span class="line"><span class="comment">7 11</span></span><br><span class="line"><span class="comment">8 2</span></span><br><span class="line"><span class="comment">9 2</span></span><br><span class="line"><span class="comment">10 8</span></span><br><span class="line"><span class="comment">11 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>Shuffle’m Up</p>
<p>Description<br>A common pastime for poker players at a poker table is to shuffle stacks of chips. Shuffling chips is performed by starting with two stacks of poker chips, <strong>S1</strong> and <strong>S2</strong>, each stack containing <em><strong>C</strong></em>chips. Each stack may contain chips of several different colors.</p>
<p>The actual shuffle operation is performed by interleaving a chip from <strong>S1</strong> with a chip from <strong>S2</strong> as shown below for <em><strong>C</strong></em> &#x3D; 5:<br><img src="/../images/es-3087_1-.png"></p>
<p>The single resultant stack, <strong>S12</strong>, contains 2 &#x2F;* <em><strong>C</strong></em> chips. The bottommost chip of <strong>S12</strong> is the bottommost chip from <strong>S2</strong>. On top of that chip, is the bottommost chip from <strong>S1</strong>. The interleaving process continues taking the 2nd chip from the bottom of <strong>S2</strong> and placing that on <strong>S12</strong>, followed by the 2nd chip from the bottom of <strong>S1</strong> and so on until the topmost chip from <strong>S1</strong> is placed on top of <strong>S12</strong>.</p>
<p>After the shuffle operation, <strong>S12</strong> is split into 2 new stacks by taking the bottommost <em><strong>C</strong></em> chips from <strong>S12</strong> to form a new <strong>S1</strong> and the topmost <em><strong>C</strong></em> chips from <strong>S12</strong> to form a new <strong>S2</strong>. The shuffle operation may then be repeated to form a new <strong>S12</strong>.</p>
<p>For this problem, you will write a program to determine if a particular resultant stack <strong>S12</strong> can be formed by shuffling two stacks some number of times.</p>
<p>Input</p>
<p>The first line of input contains a single integer <em><strong>N</strong></em>, (1 ≤ <em><strong>N</strong></em> ≤ 1000) which is the number of datasets that follow.</p>
<p>Each dataset consists of four lines of input. The first line of a dataset specifies an integer <em><strong>C</strong></em>, (1 ≤ <em><strong>C</strong></em> ≤ 100) which is the number of chips in each initial stack (<strong>S1</strong> and <strong>S2</strong>). The second line of each dataset specifies the colors of each of the <em><strong>C</strong></em> chips in stack <strong>S1</strong>, starting with the bottommost chip. The third line of each dataset specifies the colors of each of the <em><strong>C</strong></em> chips in stack <strong>S2</strong>starting with the bottommost chip. Colors are expressed as a single uppercase letter (<strong>A</strong> through <strong>H</strong>). There are no blanks or separators between the chip colors. The fourth line of each dataset contains 2 &#x2F;* <em><strong>C</strong></em> uppercase letters (<strong>A</strong> through <strong>H</strong>), representing the colors of the desired result of the shuffling of <strong>S1</strong> and <strong>S2</strong> zero or more times. The bottommost chip’s color is specified first.</p>
<p>Output</p>
<p>Output for each dataset consists of a single line that displays the dataset number (1 though <em><strong>N</strong></em>), a space, and an integer value which is the minimum number of shuffle operations required to get the desired resultant stack. If the desired result can not be reached using the input for the dataset, display the value negative 1 (<strong>−1</strong>) for the number of shuffle operations.</p>
<p>Sample Input</p>
<p>2 4 AHAH HAHA HHAAAAHH 3 CDE CDE EEDDCC</p>
<p>Sample Output</p>
<p>1 2 2 -1</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3623 Best Cow Line, Gold(模拟)</title>
    <url>/posts/oj/other/POJ%203623%20Best%20Cow%20Line,%20Gold(%E6%A8%A1%E6%8B%9F)/</url>
    <content><![CDATA[<p>题意 给你一个字符序列 你每次可以从它的头部或尾部拿出一个字符组成一个新的字符序列 输出这样做能达到的最小的字符序列 每行最多输出80个字符(开始被这个坑了好久)</p>
<p>直接模拟就行 哪边小就选哪边 相等就往内看</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">30010</span>;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    char s[N][<span class="number">2</span>];</span><br><span class="line">    int n;</span><br><span class="line">    <span class="keyword">while</span> (~scanf (<span class="string">&quot;%d&quot;</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            scanf (<span class="string">&quot;%s&quot;</span>, s[i]);</span><br><span class="line">        int le = <span class="number">1</span>, ri = n;</span><br><span class="line">        <span class="keyword">while</span> (le &lt;= ri)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (le == ri)</span><br><span class="line">            &#123;</span><br><span class="line">                ans += s[le][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            int tl = le, tr = ri;</span><br><span class="line">            <span class="keyword">while</span> (s[tl][<span class="number">0</span>] == s[tr][<span class="number">0</span>] &amp;&amp; le &lt;= ri) ++tl, --tr;</span><br><span class="line">            <span class="keyword">if</span> (s[tl][<span class="number">0</span>] &gt; s[tr][<span class="number">0</span>])</span><br><span class="line">                ans += s[ri][<span class="number">0</span>], --ri;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans += s[le][<span class="number">0</span>], ++le;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int l = ans.<span class="title function_">length</span>();</span><br><span class="line">        <span class="keyword">if</span> (l &gt; <span class="number">80</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= l; ++i)</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">1</span> &amp;&amp; i % <span class="number">80</span> == <span class="number">1</span>) printf (<span class="string">&quot;\n%c&quot;</span>, ans[i - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">else</span> printf (<span class="string">&quot;%c&quot;</span>, ans[i - <span class="number">1</span>]);</span><br><span class="line">            printf (<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Best Cow Line, Gold</p>
<p>Description<br>FJ is about to take his <em>N</em> (1 ≤ <em>N</em> ≤ 30,000) cows to the annual”Farmer of the Year” competition. In this contest every farmer arranges his cows in a line and herds them past the judges.</p>
<p>The contest organizers adopted a new registration scheme this year: simply register the initial letter of every cow in the order they will appear (i.e., If FJ takes Bessie, Sylvia, and Dora in that order he just registers BSD). After the registration phase ends, every group is judged in increasing lexicographic order according to the string of the initials of the cows’ names.</p>
<p>FJ is very busy this year and has to hurry back to his farm, so he wants to be judged as early as possible. He decides to rearrange his cows, who have already lined up, before registering them.</p>
<p>FJ marks a location for a new line of the competing cows. He then proceeds to marshal the cows from the old line to the new one by repeatedly sending either the first or last cow in the (remainder of the) original line to the end of the new line. When he’s finished, FJ takes his cows for registration in this new order.</p>
<p>Given the initial order of his cows, determine the least lexicographic string of initials he can make this way.</p>
<p>Input</p>
<p>&#x2F;* Line 1: A single integer: <em>N</em><br>&#x2F;* Lines 2..<em>N</em>+1: Line <em>i</em>+1 contains a single initial (‘A’..’Z’) of the cow in the <em>i</em>th position in the original line</p>
<p>Output</p>
<p>The least lexicographic string he can make. Every line (except perhaps the last one) contains the initials of 80 cows (‘A’..’Z’) in the new line.</p>
<p>Sample Input</p>
<p>6 A C D B C B</p>
<p>Sample Output</p>
<p>ABCBCD</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 11054 Wine trading in Gergovia（扫描）</title>
    <url>/posts/oj/other/UVa%2011054%20Wine%20trading%20in%20Gergovia%EF%BC%88%E6%89%AB%E6%8F%8F%EF%BC%89/</url>
    <content><![CDATA[<p>题意 有n个村庄 第i个村庄需要买a[i]的酒 a[i]为负时该村庄可卖掉-a[i]的酒 保证所有a[i]的和为0 一个单位的酒从一个村庄运输到相邻村庄的消耗为1 求运输完所有酒需要的最小消耗</p>
<p>总消耗最少时 每个需要买的村庄都会找离他最近的可以卖的村庄 容易发现 这种状况下 从第一个村和第二个村庄之间的运输量为abs(a[1]) 第二个村庄和第三个村庄之间的运输量为abs(a[1]+a[2]) 第k个村庄到第k+1个村庄的运输量为abs(a[1]+a[2]+…+a[k])</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, t;</span><br><span class="line">    long long ans, last;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = last = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//last记录需要从i-1运输到i的量</span></span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">            ans += <span class="title function_">abs</span>(last), last += t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Wine-trading-in-Gergovia"><a href="#Wine-trading-in-Gergovia" class="headerlink" title="Wine trading in Gergovia"></a>Wine trading in Gergovia</h1><p>As you may know from the comic “Asterix and the Chieftain’s Shield”, Gergovia consists of one street, and every inhabitant of the city is a wine salesman. You wonder how this economy works? Simple enough: everyone buys wine from other inhabitants of the city. Every day each inhabitant decides how much wine he wants to buy or sell. Interestingly, demand and supply is always the same, so that each inhabitant gets what he wants.</p>
<p>There is one problem, however: Transporting wine from one house to another results in work. Since all wines are equally good, the inhabitants of Gergovia don’t care which persons they are doing trade with, they are only interested in selling or buying a specific amount of wine. They are clever enough to figure out a way of trading so that the overall amount of work needed for transports is minimized.</p>
<p>In this problem you are asked to reconstruct the trading during one day in Gergovia. For simplicity we will assume that the houses are built along a straight line with equal distance between adjacent houses. Transporting one bottle of wine from one house to an adjacent house results in one unit of work.</p>
<h4 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification"></a>Input Specification</h4><p>The input consists of several test cases. Each test case starts with the number of inhabitants <em>n</em> (2 ≤ <em>n</em> ≤ 100000). The following line contains n integers ai (-1000 ≤ ai ≤ 1000). If ai ≥ 0, it means that the inhabitant living in the ith house wants to buy ai bottles of wine, otherwise if ai &lt; 0, he wants to sell -ai bottles of wine. You may assume that the numbers ai sum up to 0.<br>The last test case is followed by a line containing 0.</p>
<h4 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification"></a>Output Specification</h4><p>For each test case print the minimum amount of work units needed so that every inhabitant has his demand fulfilled. You may assume that this number fits into a signed 64-bit integer (in C&#x2F;C++ you can use the data type “long long”, in JAVA the data type “long”).</p>
<h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h4><p>5 5 -4 1 -3 1 6 -1000 -1000 -1000 1000 1000 1000 0</p>
<h4 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h4><p>9 9000</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 1152 4Values whose Sum is 0</title>
    <url>/posts/oj/other/UVa%201152%204Values%20whose%20Sum%20is%200/</url>
    <content><![CDATA[<p>题意 从4个n元集中各挑出一个数 使它们的和为零有多少种方法</p>
<p>直接n^4枚举肯定会超时的 可以把两个集合的元素和放在数组里 然后排序 枚举另外两个集合中两元素和 看数组中是否有其相反数就行了 复杂度为n^2&#x2F;*logn</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">#define <span class="title function_">l</span>(i) <span class="title function_">lower_bound</span>(s,s+m,i)</span><br><span class="line">#define <span class="title function_">u</span>(i) <span class="title function_">upper_bound</span>(s,s+m,i)</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">4005</span>;</span><br><span class="line">int a[N], b[N], c[N], d[N], s[N * N];</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas, m, k, n;</span><br><span class="line">    long long ans;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span>(cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = m = <span class="number">0</span>;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;a[i], &amp;b[i], &amp;c[i], &amp;d[i]);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                s[m++] = a[i] + b[j];</span><br><span class="line">        <span class="title function_">sort</span>(s, s + m);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                k = -c[i] - d[j], ans += (<span class="title function_">u</span>(k) - <span class="title function_">l</span>(k));</span><br><span class="line"></span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">        <span class="keyword">if</span>(cas) <span class="title function_">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The SUM problem can be formulated as follows: given four lists <em>A</em>, <em>B</em>, <em>C</em>, <em>D</em> of integer values, compute how many quadruplet (<em>a</em>, <em>b</em>, <em>c</em>, <em>d</em> ) <img src="/../images/dge.org-external-11-3506img1-.png" alt="$ \in$"> <em>A</em> x <em>B</em> x <em>C</em> x <em>D</em> are such that <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> &#x3D; 0 . In the following, we assume that all lists have the same size <em>n</em> .</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><strong>The input begins with a single positive integer on a line by itself indicating the number of the cases following, each of them as described below. This line is followed by a blank line, and there is also a blank line between two consecutive inputs.</strong></p>
<p>The first line of the input file contains the size of the lists <em>n</em> (this value can be as large as 4000). We then have <em>n</em> lines containing four integer values (with absolute value as large as 228 ) that belong respectively to <em>A</em>, <em>B</em>, <em>C</em> and <em>D</em> .</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p><strong>For each test case, the output must follow the description below. The outputs of two consecutive cases will be separated by a blank line.</strong></p>
<p>For each input file, your program has to write the number quadruplets whose sum is zero.</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>1 6 -45 22 42 -16 -41 -27 56 30 -36 53 -37 77 -36 30 -75 -46 26 -38 -10 62 -32 -54 -6 45</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>5</p>
<p>Sample Explanation: Indeed, the sum of the five following quadruplets is zero: (-45, -27, 42, 30), (26, 30, -10, -46), (-32, 22, 56, -46),(-32, 30, -75, 77), (-32, -54, 56, 30).</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 12110 Printer Queue(特殊队列)</title>
    <url>/posts/oj/other/UVa%2012110%20Printer%20Queue(%E7%89%B9%E6%AE%8A%E9%98%9F%E5%88%97)/</url>
    <content><![CDATA[<p>题意 模拟打印队列 队列中有优先级大于队首的元素 队首元素就排到队尾 否则队首元素出队 输出开始在p位置的元素是第几个出队的</p>
<p>直接模拟这个过程就行了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">205</span>;</span><br><span class="line">int q[N];</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas, n, p, cnt, front, rear, i;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span>(cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;p);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i) <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">        cnt = front = <span class="number">0</span>, rear = n;</span><br><span class="line">        <span class="keyword">while</span>(front &lt;= p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(i = front + <span class="number">1</span>; i &lt; rear; ++i)</span><br><span class="line">                <span class="keyword">if</span>(q[i] &gt; q[front]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; rear)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(front == p) p = rear;</span><br><span class="line">                q[rear++] = q[front];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> ++cnt;</span><br><span class="line">            ++front;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ</category>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 12412 A Typical Homework(学生信息管理系统)</title>
    <url>/posts/oj/other/UVa%2012412%20A%20Typical%20Homework(%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F)/</url>
    <content><![CDATA[<h2 id="A-Typical-Homework-a-k-a-Shi-Xiong-Bang-Bang-Mang"><a href="#A-Typical-Homework-a-k-a-Shi-Xiong-Bang-Bang-Mang" class="headerlink" title="A Typical Homework(a.k.a Shi Xiong Bang Bang Mang)"></a>A Typical Homework(a.k.a Shi Xiong Bang Bang Mang)</h2><p>Hi, I am an undergraduate student in institute of foreign languages. As you know, C programming is a required course in our university, even if his&#x2F;her major is far from computer science. I don’t like this course at all, as I am not good at computer and I don’t wanna even have a try of any programming!! But I have to do the homework in order to pass :( Sh… Could you help me with it? Please keep secret!! I know that you won’t say NO to a poor little girl, boy. :)</p>
<h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><p>Write a Student Performance Management System (SPMS).</p>
<h2 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a>Concepts</h2><p>In the SPMS, there will be at most 100 students, each has an SID, a CID, a name and four scores (Chinese, Mathematics, English and Programming).</p>
<h2 id="Main-Menu"><a href="#Main-Menu" class="headerlink" title="Main Menu"></a>Main Menu</h2><p>When you enter the SPMS, the main menu should be shown like this: Welcome to Student Performance Management System (SPMS). 1 - Add 2 - Remove 3 - Query 4 - Show ranking 5 - Show Statistics 0 - Exit</p>
<h2 id="Adding-a-Student"><a href="#Adding-a-Student" class="headerlink" title="Adding a Student"></a>Adding a Student</h2><p>If you choose 1 from the main menu, the following message should be printed on the screen: Please enter the SID, CID, name and four scores. Enter 0 to finish. Then your program should wait for user input. The input lines are always valid (no invalid SID, CID, or name, exactly four scores etc), but the SID may already exist. In that case, simply ignore this line and print the following: Duplicated SID. On the other hand, multiple students can have the same name. You should keep printing the message above until the user inputs a single zero. After that the main menu is printed again.</p>
<h2 id="Removing-a-Student"><a href="#Removing-a-Student" class="headerlink" title="Removing a Student"></a>Removing a Student</h2><p>If you choose 2 from the main menu, the following message should be printed on the screen: Please enter SID or name. Enter 0 to finish. Then your program should wait for user input, and remove all the students matching the SID or name in the database, and print the following message (it’s possible xx&#x3D;0): xx student(s) removed. You should keep printing the message above until the user inputs a single zero. After that the main menu is printed again.</p>
<h2 id="Querying-Students"><a href="#Querying-Students" class="headerlink" title="Querying Students"></a>Querying Students</h2><p>If you choose 3 from the main menu, the following message should be printed on the screen: Please enter SID or name. Enter 0 to finish. Then your program should wait for user input. If no student matches the SID or name, simply do nothing, otherwise print out all the matching students, in the same order they’re added to the database. The format is similar to the input format for “adding a student”, but 3 more columns are added: rank (1st column), total score and average score (last two columns). The student with highest total score (considering all classes) received rank-1, and if there are two rank-2 students, the next one would be rank-4. You should keep printing the message above until the user inputs a single zero. After that the main menu is printed again.</p>
<h2 id="Showing-the-Ranklist"><a href="#Showing-the-Ranklist" class="headerlink" title="Showing the Ranklist"></a>Showing the Ranklist</h2><p>If you choose 4 from the main menu, the following message should be printed on the screen: Showing the ranklist hurts students’ self-esteem. Don’t do that. Then the main menu is printed again.</p>
<h2 id="Showing-Statistics"><a href="#Showing-Statistics" class="headerlink" title="Showing Statistics"></a>Showing Statistics</h2><p>If you choose 5 from the main menu, show the statistics, in the following format: Please enter class ID, 0 for the whole statistics. When a class ID is entered, print the following statistics. Note that “passed” means to have a score of at least 60. Chinese Average Score: xx.xx Number of passed students: xx Number of failed students: xx Mathematics Average Score: xx.xx Number of passed students: xx Number of failed students: xx English Average Score: xx.xx Number of passed students: xx Number of failed students: xx Programming Average Score: xx.xx Number of passed students: xx Number of failed students: xx Overall: Number of students who passed all subjects: xx Number of students who passed 3 or more subjects: xx Number of students who passed 2 or more subjects: xx Number of students who passed 1 or more subjects: xx Number of students who failed all subjects: xx Then, the main menu is printed again.</p>
<h2 id="Exiting-SPMS"><a href="#Exiting-SPMS" class="headerlink" title="Exiting SPMS"></a>Exiting SPMS</h2><p>If you choose 0 from the main menu, the program should terminate. Note that course scores and total score should be formatted as integers, but average scores should be formatted as a real number with exactly two digits after the decimal point.</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>There will be a single test case, ending with a zero entered in the main menu screen. The entire input will be valid. The size of input does not exceed 10KB.</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>Print out everything as stated in the problem description. You should be able to play around this little program in your machine, with a keyboard and a screen. However, both the input and output may look silly when they’re not mixed, as in the keyboard-screen case.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>1 0011223344 1 John 79 98 91 100 0022334455 1 Tom 59 72 60 81 0011223344 2 Alice 100 100 100 100 2423475629 2 John 60 80 30 99 0 3 0022334455 John 0 5 1 2 0011223344 0 5 0 4 0</p>
<h2 id="Output-for-the-Sample-Input"><a href="#Output-for-the-Sample-Input" class="headerlink" title="Output for the Sample Input"></a>Output for the Sample Input</h2><p>Welcome to Student Performance Management System (SPMS). 1 - Add 2 - Remove 3 - Query 4 - Show ranking 5 - Show Statistics 0 - Exit Please enter the SID, CID, name and four scores. Enter 0 to finish. Please enter the SID, CID, name and four scores. Enter 0 to finish. Please enter the SID, CID, name and four scores. Enter 0 to finish. Duplicated SID. Please enter the SID, CID, name and four scores. Enter 0 to finish. Please enter the SID, CID, name and four scores. Enter 0 to finish. Welcome to Student Performance Management System (SPMS). 1 - Add 2 - Remove 3 - Query 4 - Show ranking 5 - Show Statistics 0 - Exit Please enter SID or name. Enter 0 to finish. 2 0022334455 1 Tom 59 72 60 81 272 68.00 Please enter SID or name. Enter 0 to finish. 1 0011223344 1 John 79 98 91 100 368 92.00 3 2423475629 2 John 60 80 30 99 269 67.25 Please enter SID or name. Enter 0 to finish. Welcome to Student Performance Management System (SPMS). 1 - Add 2 - Remove 3 - Query 4 - Show ranking 5 - Show Statistics 0 - Exit Please enter class ID, 0 for the whole statistics. Chinese Average Score: 69.00 Number of passed students: 1 Number of failed students: 1 Mathematics Average Score: 85.00 Number of passed students: 2 Number of failed students: 0 English Average Score: 75.50 Number of passed students: 2 Number of failed students: 0 Programming Average Score: 90.50 Number of passed students: 2 Number of failed students: 0 Overall: Number of students who passed all subjects: 1 Number of students who passed 3 or more subjects: 2 Number of students who passed 2 or more subjects: 2 Number of students who passed 1 or more subjects: 2 Number of students who failed all subjects: 0 Welcome to Student Performance Management System (SPMS). 1 - Add 2 - Remove 3 - Query 4 - Show ranking 5 - Show Statistics 0 - Exit Please enter SID or name. Enter 0 to finish. 1 student(s) removed. Please enter SID or name. Enter 0 to finish. Welcome to Student Performance Management System (SPMS). 1 - Add 2 - Remove 3 - Query 4 - Show ranking 5 - Show Statistics 0 - Exit Please enter class ID, 0 for the whole statistics. Chinese Average Score: 59.50 Number of passed students: 1 Number of failed students: 1 Mathematics Average Score: 76.00 Number of passed students: 2 Number of failed students: 0 English Average Score: 45.00 Number of passed students: 1 Number of failed students: 1 Programming Average Score: 90.00 Number of passed students: 2 Number of failed students: 0 Overall: Number of students who passed all subjects: 0 Number of students who passed 3 or more subjects: 2 Number of students who passed 2 or more subjects: 2 Number of students who passed 1 or more subjects: 2 Number of students who failed all subjects: 0 Welcome to Student Performance Management System (SPMS). 1 - Add 2 - Remove 3 - Query 4 - Show ranking 5 - Show Statistics 0 - Exit Showing the ranklist hurts students’ self-esteem. Don’t do that. Welcome to Student Performance Management System (SPMS). 1 - Add 2 - Remove 3 - Query 4 - Show ranking 5 - Show Statistics 0 - Exit  Rujia Liu’s Present 5: Developing Simplified Softwares<br>Special Thanks: Youzhi Bao, Zhuohua Chen</p>
<p>这种题目出现在oj上感觉挺奇怪的 这不是当年C语言期末考试的题目吗 实在不知道我的代码哪里有问题 样例是一摸一样的</p>
<p>可能哪里格式错了吧 既然是个系统就不在乎那些了TT</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define eps <span class="number">1e-5</span></span><br><span class="line">map&lt;string, int&gt; si;</span><br><span class="line">int n;</span><br><span class="line">struct <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    string sid, name;</span><br><span class="line">    int cid, chi, mat, eng, pro, sco;</span><br><span class="line">    <span class="title class_">Student</span> () &#123;&#125;</span><br><span class="line">    <span class="title class_">Student</span> (string s, int c, string na, int s1, int s2, int s3, int s4)</span><br><span class="line">        : sid (s), cid (c), name (na), chi (s1), mat (s2), eng (s3), pro (s4)</span><br><span class="line">    &#123;</span><br><span class="line">        sco = chi + mat + eng + pro;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; sid &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; cid &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; name;</span><br><span class="line">        printf (<span class="string">&quot; %d %d %d %d %d %.2lf\n&quot;</span>, chi, mat, eng, pro, sco, sco / <span class="number">4.0</span> + eps);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; stu[<span class="number">100000</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title class_">Add</span>()</span><br><span class="line">&#123;</span><br><span class="line">    string s, na;</span><br><span class="line">    int c, s1, s2, s3, s4;</span><br><span class="line">    printf (<span class="string">&quot;Please enter the SID, CID, name and four scores. Enter 0 to finish.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; s, s != <span class="string">&quot;0&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; c &gt;&gt; na &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; s3 &gt;&gt; s4;</span><br><span class="line">        <span class="keyword">if</span> (si[s]) printf (<span class="string">&quot;Duplicated SID.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            si[s] = (++n);</span><br><span class="line">            stu[n] = <span class="title class_">Student</span> (s, c, na, s1, s2, s3, s4);</span><br><span class="line">        &#125;</span><br><span class="line">        printf (<span class="string">&quot;Please enter the SID, CID, name and four scores. Enter 0 to finish.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title class_">Remove</span>()</span><br><span class="line">&#123;</span><br><span class="line">    string s;</span><br><span class="line">    int t;</span><br><span class="line">    printf (<span class="string">&quot;Please enter SID or name. Enter 0 to finish.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; s, s != <span class="string">&quot;0&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (si[stu[i].<span class="property">sid</span>])</span><br><span class="line">                <span class="keyword">if</span> (stu[i].<span class="property">name</span> == s || stu[i].<span class="property">sid</span> == s)</span><br><span class="line">                &#123;</span><br><span class="line">                    si[stu[i].<span class="property">sid</span>] = <span class="number">0</span>;</span><br><span class="line">                    ++t;</span><br><span class="line">                &#125;</span><br><span class="line">        printf (<span class="string">&quot;%d student(s) removed.\n&quot;</span>, t);</span><br><span class="line">        printf (<span class="string">&quot;Please enter SID or name. Enter 0 to finish.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title class_">Query</span>()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    string s;</span><br><span class="line">    printf (<span class="string">&quot;Please enter SID or name. Enter 0 to finish.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; s, s != <span class="string">&quot;0&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = t = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (si[stu[i].<span class="property">sid</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (stu[i].<span class="property">sid</span> == s || stu[i].<span class="property">name</span> == s)</span><br><span class="line">                &#123;</span><br><span class="line">                    printf (<span class="string">&quot;%d &quot;</span>, t++);</span><br><span class="line">                    stu[i].<span class="title function_">print</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>  ++t;</span><br><span class="line">            &#125;</span><br><span class="line">        printf (<span class="string">&quot;Please enter SID or name. Enter 0 to finish.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title class_">Show</span>_ranking()</span><br><span class="line">&#123;</span><br><span class="line">    printf (<span class="string">&quot;Showing the ranklist hurts students&#x27; self-esteem. Don&#x27;t do that.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title class_">Show</span>_Statistics()</span><br><span class="line">&#123;</span><br><span class="line">    printf (<span class="string">&quot;Please enter class ID, 0 for the whole statistics.\n&quot;</span>);</span><br><span class="line">    int schi = <span class="number">0</span>, seng = <span class="number">0</span>, smat = <span class="number">0</span>, spro = <span class="number">0</span>, pmat = <span class="number">0</span>, cla,</span><br><span class="line">        pchi = <span class="number">0</span>, peng = <span class="number">0</span>, ppro = <span class="number">0</span>, npa = <span class="number">0</span>, np1 = <span class="number">0</span>, np2 = <span class="number">0</span>, np3 = <span class="number">0</span>, nfa = <span class="number">0</span>, numb;</span><br><span class="line">    scanf (<span class="string">&quot;%d&quot;</span>, &amp;cla);</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> ( (stu[i].<span class="property">cid</span> == cla || cla == <span class="number">0</span>) &amp;&amp; si[stu[i].<span class="property">sid</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            int t = <span class="number">0</span>;</span><br><span class="line">            schi += stu[i].<span class="property">chi</span>;</span><br><span class="line">            <span class="keyword">if</span> (stu[i].<span class="property">chi</span> &gt;= <span class="number">60</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++pchi;</span><br><span class="line">                ++t;</span><br><span class="line">            &#125;</span><br><span class="line">            seng += stu[i].<span class="property">eng</span>;</span><br><span class="line">            <span class="keyword">if</span> (stu[i].<span class="property">eng</span> &gt;= <span class="number">60</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++peng;</span><br><span class="line">                ++t;</span><br><span class="line">            &#125;</span><br><span class="line">            spro += stu[i].<span class="property">pro</span>;</span><br><span class="line">            <span class="keyword">if</span> (stu[i].<span class="property">pro</span> &gt;= <span class="number">60</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++ppro;</span><br><span class="line">                ++t;</span><br><span class="line">            &#125;</span><br><span class="line">            smat += stu[i].<span class="property">mat</span>;</span><br><span class="line">            <span class="keyword">if</span> (stu[i].<span class="property">mat</span> &gt;= <span class="number">60</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++pmat;</span><br><span class="line">                ++t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="number">0</span>) ++nfa;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="number">1</span>) ++np1;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="number">2</span>) ++np2;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="number">3</span>) ++np3;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="number">4</span>) ++npa;</span><br><span class="line">        &#125;</span><br><span class="line">    numb = nfa + np1 + np2 + np3 + npa;</span><br><span class="line">    printf (<span class="string">&quot;Chinese\n&quot;</span>);</span><br><span class="line">    printf (<span class="string">&quot;Average Score: %.2lf\n&quot;</span>, schi / (numb * <span class="number">1.0</span>) + eps);</span><br><span class="line">    printf (<span class="string">&quot;Number of passed students: %d\n&quot;</span>, pchi);</span><br><span class="line">    printf (<span class="string">&quot;Number of failed students: %d\n\n&quot;</span>, numb - pchi);</span><br><span class="line">    </span><br><span class="line">    printf (<span class="string">&quot;Mathematics\n&quot;</span>);</span><br><span class="line">    printf (<span class="string">&quot;Average Score: %.2lf\n&quot;</span>, smat / (numb * <span class="number">1.0</span>) + eps);</span><br><span class="line">    printf (<span class="string">&quot;Number of passed students: %d\n&quot;</span>, pmat);</span><br><span class="line">    printf (<span class="string">&quot;Number of failed students: %d\n\n&quot;</span>, numb - pmat);</span><br><span class="line">    </span><br><span class="line">    printf (<span class="string">&quot;English\n&quot;</span>);</span><br><span class="line">    printf (<span class="string">&quot;Average Score: %.2lf\n&quot;</span>, seng / (numb * <span class="number">1.0</span>) + eps);</span><br><span class="line">    printf (<span class="string">&quot;Number of passed students: %d\n&quot;</span>, peng);</span><br><span class="line">    printf (<span class="string">&quot;Number of failed students: %d\n\n&quot;</span>, numb - peng);</span><br><span class="line">    </span><br><span class="line">    printf (<span class="string">&quot;Programming\n&quot;</span>);</span><br><span class="line">    printf (<span class="string">&quot;Average Score: %.2lf\n&quot;</span>, spro / (numb * <span class="number">1.0</span>) + eps);</span><br><span class="line">    printf (<span class="string">&quot;Number of passed students: %d\n&quot;</span>, ppro);</span><br><span class="line">    printf (<span class="string">&quot;Number of failed students: %d\n\n&quot;</span>, numb - ppro);</span><br><span class="line">    </span><br><span class="line">    printf (<span class="string">&quot;Overall:\n&quot;</span>);</span><br><span class="line">    printf (<span class="string">&quot;Number of students who passed all subjects: %d\n&quot;</span>, npa);</span><br><span class="line">    printf (<span class="string">&quot;Number of students who passed 3 or more subjects: %d\n&quot;</span>, npa + np3);</span><br><span class="line">    printf (<span class="string">&quot;Number of students who passed 2 or more subjects: %d\n&quot;</span>, npa + np3 + np2);</span><br><span class="line">    printf (<span class="string">&quot;Number of students who passed 1 or more subjects: %d\n&quot;</span>, npa + np3 + np2 + np1);</span><br><span class="line">    printf (<span class="string">&quot;Number of students who failed all subjects: %d\n\n&quot;</span>, nfa);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cho;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printf (<span class="string">&quot;Welcome to Student Performance Management System (SPMS).\n\n&quot;</span>);</span><br><span class="line">        printf (<span class="string">&quot;1 - Add\n&quot;</span>);</span><br><span class="line">        printf (<span class="string">&quot;2 - Remove\n&quot;</span>);</span><br><span class="line">        printf (<span class="string">&quot;3 - Query\n&quot;</span>);</span><br><span class="line">        printf (<span class="string">&quot;4 - Show ranking\n&quot;</span>);</span><br><span class="line">        printf (<span class="string">&quot;5 - Show Statistics\n&quot;</span>);</span><br><span class="line">        printf (<span class="string">&quot;0 - Exit\n\n&quot;</span>);</span><br><span class="line">        scanf (<span class="string">&quot;%d&quot;</span>, &amp;cho);</span><br><span class="line">        <span class="keyword">if</span> (cho == <span class="number">1</span>) <span class="title class_">Add</span>();</span><br><span class="line">        <span class="keyword">if</span> (cho == <span class="number">2</span>) <span class="title class_">Remove</span>();</span><br><span class="line">        <span class="keyword">if</span> (cho == <span class="number">3</span>) <span class="title class_">Query</span>();</span><br><span class="line">        <span class="keyword">if</span> (cho == <span class="number">4</span>) <span class="title class_">Show</span>_ranking();</span><br><span class="line">        <span class="keyword">if</span> (cho == <span class="number">5</span>) <span class="title class_">Show</span>_Statistics();</span><br><span class="line">        <span class="keyword">if</span> (cho == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刘汝佳的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UVa12412 A Typical Homework (a.k.a Shi Xiong Bang Bang Mang)</span></span><br><span class="line"><span class="comment">// Rujia Liu</span></span><br><span class="line">#include&lt;stdio.<span class="property">h</span>&gt;</span><br><span class="line">#include&lt;string.<span class="property">h</span>&gt;</span><br><span class="line">#define maxn <span class="number">1000</span></span><br><span class="line">#define maxl <span class="number">100</span></span><br><span class="line">#define <span class="variable constant_">EPS</span> <span class="number">1e-5</span></span><br><span class="line"></span><br><span class="line">int n = <span class="number">0</span>;</span><br><span class="line">char sid[maxn][maxl];</span><br><span class="line">int cid[maxn];</span><br><span class="line">char name[maxn][maxl];</span><br><span class="line">int score[maxn][<span class="number">5</span>];</span><br><span class="line">int removed[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> char* course_name[] = &#123;<span class="string">&quot;Chinese&quot;</span>, <span class="string">&quot;Mathematics&quot;</span>, <span class="string">&quot;English&quot;</span>, <span class="string">&quot;Programming&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">int valid (int k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; k; i++) <span class="keyword">if</span> (!removed[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (strcmp (sid[i], sid[k]) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        printf (<span class="string">&quot;Please enter the SID, CID, name and four scores. Enter 0 to finish.\n&quot;</span>);</span><br><span class="line">        scanf (<span class="string">&quot;%s&quot;</span>, sid[n]);</span><br><span class="line">        <span class="keyword">if</span> (strcmp (sid[n], <span class="string">&quot;0&quot;</span>) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        scanf (<span class="string">&quot;%d%s%d%d%d%d&quot;</span>, &amp;cid[n], name[n], &amp;score[n][<span class="number">0</span>], &amp;score[n][<span class="number">1</span>], &amp;score[n][<span class="number">2</span>], &amp;score[n][<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">if</span> (valid (n))</span><br><span class="line">        &#123;</span><br><span class="line">            score[n][<span class="number">4</span>] = score[n][<span class="number">0</span>] + score[n][<span class="number">1</span>] + score[n][<span class="number">2</span>] + score[n][<span class="number">3</span>];</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> printf (<span class="string">&quot;Duplicated SID.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int rank (int k)</span><br><span class="line">&#123;</span><br><span class="line">    int r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!removed[i] &amp;&amp; score[i][<span class="number">4</span>] &gt; score[k][<span class="number">4</span>]) r++;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="variable constant_">DQ</span> (int isq)</span><br><span class="line">&#123;</span><br><span class="line">    char s[maxl];</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        printf (<span class="string">&quot;Please enter SID or name. Enter 0 to finish.\n&quot;</span>);</span><br><span class="line">        scanf (<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        <span class="keyword">if</span> (strcmp (s, <span class="string">&quot;0&quot;</span>) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        int r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> (!removed[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (strcmp (sid[i], s) == <span class="number">0</span> || strcmp (name[i], s) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isq) printf (<span class="string">&quot;%d %s %d %s %d %d %d %d %d %.2f\n&quot;</span>, rank (i), sid[i], cid[i], name[i], score[i][<span class="number">0</span>], score[i][<span class="number">1</span>], score[i][<span class="number">2</span>], score[i][<span class="number">3</span>], score[i][<span class="number">4</span>], score[i][<span class="number">4</span>] / <span class="number">4.0</span> + <span class="variable constant_">EPS</span>);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        removed[i] = <span class="number">1</span>;</span><br><span class="line">                        r++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isq) printf (<span class="string">&quot;%d student(s) removed.\n&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double get_course_stat (int c, int s, int* passed, int* failed)</span><br><span class="line">&#123;</span><br><span class="line">    int tot = <span class="number">0</span>;</span><br><span class="line">    *passed = *failed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!removed[i] &amp;&amp; (c == <span class="number">0</span> || cid[i] == c))</span><br><span class="line">        &#123;</span><br><span class="line">            tot += score[i][s];</span><br><span class="line">            <span class="keyword">if</span> (score[i][s] &gt;= <span class="number">60</span>) (*passed)++;</span><br><span class="line">            <span class="keyword">else</span> (*failed)++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> (double) tot / (double) (*passed + *failed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> get_overall_stat (int c, int* cnt)</span><br><span class="line">&#123;</span><br><span class="line">    cnt[<span class="number">0</span>] = cnt[<span class="number">1</span>] = cnt[<span class="number">2</span>] = cnt[<span class="number">3</span>] = cnt[<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!removed[i] &amp;&amp; (c == <span class="number">0</span> || cid[i] == c))</span><br><span class="line">        &#123;</span><br><span class="line">            int k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) <span class="keyword">if</span> (score[i][j] &gt;= <span class="number">60</span>) k++;</span><br><span class="line">            cnt[k]++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">stat</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int c;</span><br><span class="line">    printf (<span class="string">&quot;Please enter class ID, 0 for the whole statistics.\n&quot;</span>);</span><br><span class="line">    scanf (<span class="string">&quot;%d&quot;</span>, &amp;c);</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int passed, failed;</span><br><span class="line">        double avg = get_course_stat (c, i, &amp;passed, &amp;failed);</span><br><span class="line">        printf (<span class="string">&quot;%s\n&quot;</span>, course_name[i]);</span><br><span class="line">        printf (<span class="string">&quot;Average Score: %.2f\n&quot;</span>, avg + <span class="variable constant_">EPS</span>);</span><br><span class="line">        printf (<span class="string">&quot;Number of passed students: %d\n&quot;</span>, passed);</span><br><span class="line">        printf (<span class="string">&quot;Number of failed students: %d\n&quot;</span>, failed);</span><br><span class="line">        printf (<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    int cnt[<span class="number">5</span>];</span><br><span class="line">    get_overall_stat (c, cnt);</span><br><span class="line">    printf (<span class="string">&quot;Overall:\n&quot;</span>);</span><br><span class="line">    printf (<span class="string">&quot;Number of students who passed all subjects: %d\n&quot;</span>, cnt[<span class="number">4</span>]);</span><br><span class="line">    printf (<span class="string">&quot;Number of students who passed 3 or more subjects: %d\n&quot;</span>, cnt[<span class="number">4</span>] + cnt[<span class="number">3</span>]);</span><br><span class="line">    printf (<span class="string">&quot;Number of students who passed 2 or more subjects: %d\n&quot;</span>, cnt[<span class="number">4</span>] + cnt[<span class="number">3</span>] + cnt[<span class="number">2</span>]);</span><br><span class="line">    printf (<span class="string">&quot;Number of students who passed 1 or more subjects: %d\n&quot;</span>, cnt[<span class="number">4</span>] + cnt[<span class="number">3</span>] + cnt[<span class="number">2</span>] + cnt[<span class="number">1</span>]);</span><br><span class="line">    printf (<span class="string">&quot;Number of students who failed all subjects: %d\n&quot;</span>, cnt[<span class="number">0</span>]);</span><br><span class="line">    printf (<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        int choice;</span><br><span class="line">        printf (<span class="string">&quot;Welcome to Student Performance Management System (SPMS).\n&quot;</span>);</span><br><span class="line">        printf (<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        printf (<span class="string">&quot;1 - Add\n&quot;</span>);</span><br><span class="line">        printf (<span class="string">&quot;2 - Remove\n&quot;</span>);</span><br><span class="line">        printf (<span class="string">&quot;3 - Query\n&quot;</span>);</span><br><span class="line">        printf (<span class="string">&quot;4 - Show ranking\n&quot;</span>);</span><br><span class="line">        printf (<span class="string">&quot;5 - Show Statistics\n&quot;</span>);</span><br><span class="line">        printf (<span class="string">&quot;0 - Exit\n&quot;</span>);</span><br><span class="line">        printf (<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        scanf (<span class="string">&quot;%d&quot;</span>, &amp;choice);</span><br><span class="line">        <span class="keyword">if</span> (choice == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (choice == <span class="number">1</span>) <span class="title function_">add</span>();</span><br><span class="line">        <span class="keyword">if</span> (choice == <span class="number">2</span>) <span class="variable constant_">DQ</span> (<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (choice == <span class="number">3</span>) <span class="variable constant_">DQ</span> (<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (choice == <span class="number">4</span>) printf (<span class="string">&quot;Showing the ranklist hurts students&#x27; self-esteem. Don&#x27;t do that.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (choice == <span class="number">5</span>) <span class="title function_">stat</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ</category>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 1589 Xiangqi(模拟 HDU4121)</title>
    <url>/posts/oj/other/UVa%201589%20Xiangqi(%E6%A8%A1%E6%8B%9F%20HDU4121)/</url>
    <content><![CDATA[<p>题意 给你一个黑方被将军的象棋残局 判断红方是否已经把黑方将死</p>
<p>模拟题 注意细节就行了 看黑方的将是否四个方向都不能走</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">char brd[N][N];</span><br><span class="line">int dx[] = &#123; -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">int hx[] = &#123; -<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;  <span class="comment">//马将军</span></span><br><span class="line">int hy[] = &#123; -<span class="number">1</span>, -<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">2</span>, -<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">int tx[] = &#123; -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;  <span class="comment">//马蹩脚</span></span><br><span class="line">int ty[] = &#123; -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">int cr[<span class="number">2</span>], cc[<span class="number">2</span>];  <span class="comment">//记录炮的坐标</span></span><br><span class="line"></span><br><span class="line">int <span class="title function_">check</span>(<span class="params">int r, int c</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, k, tr, tc, cnt;</span><br><span class="line">    <span class="keyword">if</span>(r &lt; <span class="number">1</span> || r &gt; <span class="number">3</span> || c &lt; <span class="number">4</span> || c &gt; <span class="number">6</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = c - <span class="number">1</span>; j &gt; <span class="number">0</span>; --j)   <span class="comment">//行被车</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(brd[r][j])</span><br><span class="line">            <span class="keyword">if</span>(brd[r][j] == <span class="string">&#x27;R&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = c + <span class="number">1</span>; j &lt;= <span class="number">9</span>; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(brd[r][j])</span><br><span class="line">            <span class="keyword">if</span>(brd[r][j] == <span class="string">&#x27;R&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = r - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)  <span class="comment">//列被车</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(brd[i][c])</span><br><span class="line">            <span class="keyword">if</span>(brd[i][c] == <span class="string">&#x27;R&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = r + <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) <span class="comment">//列被车或将</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(brd[i][c])</span><br><span class="line">            <span class="keyword">if</span>(brd[i][c] == <span class="string">&#x27;R&#x27;</span> || brd[i][c] == <span class="string">&#x27;G&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int k = <span class="number">0</span>; k &lt; <span class="number">2</span>; ++k)    <span class="comment">//被炮将军</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cr[k] == r)   <span class="comment">//行有炮</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j = c - <span class="number">1</span>, cnt = <span class="number">0</span>; j &gt; cc[k]; --j) <span class="keyword">if</span>(brd[r][j]) ++cnt;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(j = c + <span class="number">1</span>, cnt = <span class="number">0</span>; j &lt; cc[k]; ++j) <span class="keyword">if</span>(brd[r][j]) ++cnt;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cc[k] == c)   <span class="comment">//列有炮</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(i = r - <span class="number">1</span>, cnt = <span class="number">0</span>; i &gt; cr[k]; --i) <span class="keyword">if</span>(brd[i][c]) ++cnt;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(i = r + <span class="number">1</span>, cnt = <span class="number">0</span>; i &lt; cr[k]; ++i) <span class="keyword">if</span>(brd[i][c]) ++cnt;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int k = <span class="number">0</span>; k &lt; <span class="number">8</span>; ++k)   <span class="comment">//被马将军</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr = r + hx[k], tc = c + hy[k];</span><br><span class="line">        <span class="keyword">if</span>(tr &lt; <span class="number">1</span> || tr &gt; <span class="number">10</span> || tc &lt; <span class="number">1</span> || tc &gt; <span class="number">9</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(brd[tr][tc] == <span class="string">&#x27;H&#x27;</span> &amp;&amp; (!brd[r + tx[k]][c + ty[k]]))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    char s[<span class="number">5</span>];</span><br><span class="line">    int n, r, c, x, y;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;r, &amp;c), n || r || c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">memset</span>(brd, <span class="number">0</span>, <span class="title function_">sizeof</span>(brd));</span><br><span class="line">        cr[<span class="number">0</span>] = cc[<span class="number">0</span>] = cr[<span class="number">1</span>] = cc[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, s, &amp;x, &amp;y);</span><br><span class="line">            <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(cr[<span class="number">0</span>]) cr[<span class="number">1</span>] = x, cc[<span class="number">1</span>] = y;</span><br><span class="line">                <span class="keyword">else</span> cr[<span class="number">0</span>] = x, cc[<span class="number">0</span>] = y;</span><br><span class="line">            &#125;</span><br><span class="line">            brd[x][y] = s[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">            cnt += <span class="title function_">check</span>(r + dx[i], c + dy[i]);</span><br><span class="line">        <span class="keyword">if</span>(cnt &lt; <span class="number">4</span>) <span class="title function_">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="title function_">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Xiangqi"><a href="#Xiangqi" class="headerlink" title="Xiangqi"></a>Xiangqi</h1><p>Problem Description</p>
<p>Xiangqi is one of the most popular two-player board games in China. The game represents a battle between two armies with the goal of capturing the enemy’s “general” piece. In this problem, you are given a situation of later stage in the game. Besides, the red side has already “delivered a check”. <strong>Your work is to check whether the situation is “checkmate”.</strong><br>Now we introduce some basic rules of Xiangqi. Xiangqi is played on a 10×9 board and the pieces are placed on the intersections (points). The top left point is (1,1) and the bottom right point is (10,9). There are two groups of pieces marked by black or red Chinese characters, belonging to the two players separately. During the game, each player in turn moves one piece from the point it occupies to another point. No two pieces can occupy the same point at the same time. A piece can be moved onto a point occupied by an enemy piece, in which case the enemy piece is “captured” and removed from the board. When the general is in danger of being captured by the enemy player on the enemy player’s next move, the enemy player is said to have <strong>“delivered a check”</strong>. If the general’s player can make no move to prevent the general’s capture by next enemy move, the situation is called <strong>“checkmate”</strong>.<br>  <img src="/../images/cn-data-images-4121-5.jpg.png">  We only use 4 kinds of pieces introducing as follows:<br><img src="/../images/cn-data-images-4121-1.jpg.png">General: the generals can move and capture <strong>one point</strong> either vertically or horizontally and cannot leave the “<strong>palace</strong>” unless the situation called “<strong>flying general</strong>” (see the figure above). “Flying general” means that one general can “fly” across the board to capture the enemy general if they stand on the same line without intervening pieces.<br><img src="/../images/cn-data-images-4121-2.jpg.png">Chariot: the chariots can move and capture vertically and horizontally by any distance, but may not jump over intervening pieces<br><img src="/../images/cn-data-images-4121-3.jpg.png">Cannon: the cannons move like the chariots, horizontally and vertically, but capture by jumping <strong>exactly one piece</strong> (whether it is friendly or enemy) over to its target.<br><img src="/../images/cn-data-images-4121-4.jpg.png">Horse: the horses have 8 kinds of jumps to move and capture shown in the left figure. However, if there is any pieces lying on a point away from the horse horizontally or vertically it cannot move or capture in that direction (see the figure below), which is called “<strong>hobbling the horse’s leg</strong>”.<br>  <img src="/../images/cn-data-images-4121-6.jpg.png">  Now you are given a situation only containing a black general, a red general and several red chariots, cannons and horses, and the red side has delivered a check. Now it turns to black side’s move. Your job is to determine that whether this situation is “checkmate”.<br>Input</p>
<p>The input contains no more than 40 test cases. For each test case, the first line contains three integers representing the number of red pieces N (2&lt;&#x3D;N&lt;&#x3D;7) and the position of the black general. The following n lines contain details of N red pieces. For each line, there are a char and two integers representing the type and position of the piece (type char ‘G’ for general, ‘R’ for chariot, ‘H’ for horse and ‘C’ for cannon). We guarantee that the situation is legal and the red side has delivered the check.<br>There is a blank line between two test cases. The input ends by 0 0 0.<br>Output</p>
<p>For each test case, if the situation is checkmate, output a single word ‘YES’, otherwise output the word ‘NO’.<br>Sample Input</p>
<p>2 1 4 G 10 5 R 6 4 3 1 5 H 4 5 G 10 5 C 7 5 0 0 0<br>Sample Output</p>
<p>YES NO</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 202 Repeating Decimals(模拟)</title>
    <url>/posts/oj/other/UVa%20202%20Repeating%20Decimals(%E6%A8%A1%E6%8B%9F)/</url>
    <content><![CDATA[<p>大水题 模拟在草稿纸上算除法的过程→_→</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">3005</span>;</span><br><span class="line">int a[N], v[N];</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, m, cnt;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="title function_">memset</span>(v, <span class="number">0</span>, <span class="title function_">sizeof</span>(v));</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d/%d = %d.&quot;</span>, n, m, n / m);</span><br><span class="line">        n = n % m;</span><br><span class="line">        <span class="keyword">while</span>(!v[n])</span><br><span class="line">        &#123;</span><br><span class="line">            a[++cnt] = (n * <span class="number">10</span>) / m;</span><br><span class="line">            v[n] = cnt;</span><br><span class="line">            n = n * <span class="number">10</span> % m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= cnt &amp;&amp; i &lt; <span class="number">51</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == v[n]) <span class="title function_">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;%d&quot;</span>, a[i]);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">50</span>) <span class="title function_">printf</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;)\n   %d = number of digits in repeating cycle\n\n&quot;</span>, cnt - v[n] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p>The decimal expansion of the fraction 1&#x2F;33 is <img src="/../images/dge.org-external-2-202img1.gif.png" alt="tex2html_wrap_inline43"> , where the <img src="/../images/dge.org-external-2-202img2.gif.png" alt="tex2html_wrap_inline45"> is used to indicate that the cycle 03 repeats indefinitely with no intervening digits. In fact, the decimal expansion of every rational number (fraction) has a repeating cycle as opposed to decimal expansions of irrational numbers, which have no such repeating cycles.</p>
<p>Examples of decimal expansions of rational numbers and their repeating cycles are shown below. Here, we use parentheses to enclose the repeating cycle rather than place a bar over the cycle.</p>
<p><img src="/../images/dge.org-external-2-202img3.gif.png" alt="tabular23"></p>
<p>Write a program that reads numerators and denominators of fractions and determines their repeating cycles.</p>
<p>For the purposes of this problem, define a repeating cycle of a fraction to be the first minimal length string of digits to the right of the decimal that repeats indefinitely with no intervening digits. Thus for example, the repeating cycle of the fraction 1&#x2F;250 is 0, which begins at position 4 (as opposed to 0 which begins at positions 1 or 2 and as opposed to 00 which begins at positions 1 or 4).</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>Each line of the input file consists of an integer numerator, which is nonnegative, followed by an integer denominator, which is positive. None of the input integers exceeds 3000. End-of-file indicates the end of input.</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each line of input, print the fraction, its decimal expansion through the first occurrence of the cycle to the right of the decimal or 50 decimal places (whichever comes first), and the length of the entire repeating cycle.</p>
<p>In writing the decimal expansion, enclose the repeating cycle in parentheses when possible. If the entire repeating cycle does not occur within the first 50 places, place a left parenthesis where the cycle begins - it will begin within the first 50 places - and place &#96;&#96;…)” after the 50th digit.</p>
<p>Print a blank line after every test case.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>76 25 5 43 1 397</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>76&#x2F;25 &#x3D; 3.04(0) 1 &#x3D; number of digits in repeating cycle 5&#x2F;43 &#x3D; 0.(116279069767441860465) 21 &#x3D; number of digits in repeating cycle 1&#x2F;397 &#x3D; 0.(00251889168765743073047858942065491183879093198992…) 99 &#x3D; number of digits in repeating cycle</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 340 Master-Mind Hints(猜数字游戏的提示)</title>
    <url>/posts/oj/other/UVa%20340%20Master-Mind%20Hints(%E7%8C%9C%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F%E7%9A%84%E6%8F%90%E7%A4%BA)/</url>
    <content><![CDATA[<p>题意 猜数字游戏 统计猜的数字有多少个数字位置正确 有多少个数字在答案中出现但是位置不正确 每个字符只能匹配一次</p>
<p>直接匹配每位数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;  </span><br><span class="line">#include&lt;algorithm&gt;  </span><br><span class="line">#include&lt;map&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1005</span>;  </span><br><span class="line">int  a[N], b[N], c, d;  </span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    int n, cas = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (scanf (<span class="string">&quot;%d&quot;</span>, &amp;n), n)  </span><br><span class="line">    &#123;  </span><br><span class="line">        map&lt;int, int&gt; aa;  </span><br><span class="line">        printf (<span class="string">&quot;Game %d:\n&quot;</span>, ++cas);  </span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; ++i)  </span><br><span class="line">        &#123;  </span><br><span class="line">            scanf (<span class="string">&quot;%d&quot;</span>, &amp;a[i]);  </span><br><span class="line">            ++aa[a[i]];  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            map&lt;int, int&gt; bb;  </span><br><span class="line">            <span class="keyword">for</span> (int i = c = d = <span class="number">0</span>; i &lt; n; ++i)  </span><br><span class="line">            &#123;  </span><br><span class="line">                scanf (<span class="string">&quot;%d&quot;</span>, &amp;b[i]);  </span><br><span class="line">                ++bb[b[i]];  </span><br><span class="line">                <span class="keyword">if</span> (a[i] == b[i]) c++;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (!b[<span class="number">0</span>]) <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++i)  </span><br><span class="line">                d += min (aa[i], bb[i]);  </span><br><span class="line">            printf (<span class="string">&quot;    (%d,%d)\n&quot;</span>, c, d - c);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p>MasterMind is a game for two players. One of them, <em>Designer</em>, selects a secret code. The other,<em>Breaker</em>, tries to break it. A code is no more than a row of colored dots. At the beginning of a game, the players agree upon the length <em>N</em> that a code must have and upon the colors that may occur in a code.</p>
<p>In order to break the code, Breaker makes a number of guesses, each guess itself being a code. After each guess Designer gives a hint, stating to what extent the guess matches his secret code.</p>
<p>In this problem you will be given a secret code <img src="/../images/dge.org-external-3-340img1.gif.png" alt="tex2html_wrap_inline35"> and a guess <img src="/../images/dge.org-external-3-340img2.gif.png" alt="tex2html_wrap_inline37"> , and are to determine the hint. A hint consists of a pair of numbers determined as follows.</p>
<p>A <em>match</em> is a pair (<em>i</em>,<em>j</em>), <img src="/../images/dge.org-external-3-340img3.gif.png" alt="tex2html_wrap_inline41"> and <img src="/../images/dge.org-external-3-340img4.gif.png" alt="tex2html_wrap_inline43"> , such that <img src="/../images/dge.org-external-3-340img5.gif.png" alt="tex2html_wrap_inline45"> . Match (<em>i</em>,<em>j</em>) is called <em>strong</em>when <em>i</em> &#x3D; <em>j</em>, and is called <em>weak</em> otherwise. Two matches (<em>i</em>,<em>j</em>) and (<em>p</em>,<em>q</em>) are called <em>independent</em> when<em>i</em> &#x3D; <em>p</em> if and only if <em>j</em> &#x3D; <em>q</em>. A set of matches is called <em>independent</em> when all of its members are pairwise independent.</p>
<p>Designer chooses an independent set <em>M</em> of matches for which the total number of matches and the number of strong matches are both maximal. The hint then consists of the number of strong followed by the number of weak matches in <em>M</em>. Note that these numbers are uniquely determined by the secret code and the guess. If the hint turns out to be (<em>n</em>,0), then the guess is identical to the secret code.</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>The input will consist of data for a number of games. The input for each game begins with an integer specifying <em>N</em> (the length of the code). Following these will be the secret code, represented as <em>N</em> integers, which we will limit to the range 1 to 9. There will then follow an arbitrary number of guesses, each also represented as <em>N</em> integers, each in the range 1 to 9. Following the last guess in each game will be <em>N</em> zeroes; these zeroes are not to be considered as a guess.</p>
<p>Following the data for the first game will appear data for the second game (if any) beginning with a new value for <em>N</em>. The last game in the input will be followed by a single zero (when a value for<em>N</em> would normally be specified). The maximum value for <em>N</em> will be 1000.</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>The output for each game should list the hints that would be generated for each guess, in order, one hint per line. Each hint should be represented as a pair of integers enclosed in parentheses and separated by a comma. The entire list of hints for each game should be prefixed by a heading indicating the game number; games are numbered sequentially starting with 1. Look at the samples below for the <em>exact</em> format.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>4 1 3 5 5 1 1 2 3 4 3 3 5 6 5 5 1 6 1 3 5 1 3 5 5 0 0 0 0 10 1 2 2 2 4 5 6 6 6 9 1 2 3 4 5 6 7 8 9 1 1 1 2 2 3 3 4 4 5 5 1 2 1 3 1 5 1 6 1 9 1 2 2 5 5 5 6 6 6 7 0 0 0 0 0 0 0 0 0 0 0</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>Game 1: (1,1) (2,0) (1,2) (1,2) (4,0) Game 2: (2,4) (3,2) (5,0) (7,0)</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 714 Copying Books(贪心 二分)</title>
    <url>/posts/oj/other/UVa%20714%20Copying%20Books(%E8%B4%AA%E5%BF%83%20%E4%BA%8C%E5%88%86)/</url>
    <content><![CDATA[<p>题意 把m数分成k组 使每组数的和的最大值最小 如果有多种分法 靠前的组的和尽量小</p>
<p>关键是找出那个最小的最大值 可以通过二分来找出 开始左端点为m个数中最大的数 右端点为m个数的和 若中点能将m个数分为小于等于k组 比它大的肯定都是可以的 中点变为右端点 否则中点变成左端点</p>
<p>然后就可以贪心逆向模拟了 从后往前每组选择尽量多的数直到剩下的数等于组数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">505</span>;</span><br><span class="line">int a[N], d[N], m, k, maxi;</span><br><span class="line">ll s[N], le, ri, mid, mins, t;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">divs</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int last = <span class="number">0</span>, cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] - s[last] &gt; mid)</span><br><span class="line">            last = i - <span class="number">1</span>, ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span>(cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;m, &amp;k);</span><br><span class="line">        <span class="keyword">for</span>(int i = maxi = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">            s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; a[maxi]) maxi = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        le = a[maxi], ri = s[m];</span><br><span class="line">        <span class="keyword">while</span>(le &lt;= ri)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (le + ri) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_">divs</span>() &lt;= k) mins = mid, ri = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> le = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="title function_">memset</span>(d, <span class="number">0</span>, <span class="title function_">sizeof</span>(d));</span><br><span class="line">        <span class="keyword">for</span>(int i = m; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t + a[i] &gt; mins)</span><br><span class="line">                d[i] = k--, t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(k &gt;= i) <span class="keyword">while</span>(i &gt; <span class="number">0</span>) d[--i] = <span class="number">1</span>;</span><br><span class="line">            t = t + a[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;%d%c&quot;</span>, a[i], i &lt; m ? <span class="string">&#x27; &#x27;</span> : <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(d[i]) <span class="title function_">printf</span>(<span class="string">&quot;/ &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p>Before the invention of book-printing, it was very hard to make a copy of a book. All the contents had to be re-written by hand by so called <em>scribers</em>. The scriber had been given a book and after several months he finished its copy. One of the most famous scribers lived in the 15th century and his name was Xaverius Endricus Remius Ontius Xendrianus (<em>Xerox</em>). Anyway, the work was very annoying and boring. And the only way to speed it up was to hire more scribers.</p>
<p>Once upon a time, there was a theater ensemble that wanted to play famous Antique Tragedies. The scripts of these plays were divided into many books and actors needed more copies of them, of course. So they hired many scribers to make copies of these books. Imagine you have <em>m</em> books (numbered <img src="/../images/dge.org-external-7-714img1.gif.png" alt="$1, 2, \dots, m$">) that may have different number of pages ( <img src="/../images/dge.org-external-7-714img2.gif.png" alt="$p_1, p_2, \dots, p_m$">) and you want to make one copy of each of them. Your task is to divide these books among <em>k</em> scribes, <img src="/../images/dge.org-external-7-714img3.gif.png" alt="$k \le m$">. Each book can be assigned to a single scriber only, and every scriber must get a continuous sequence of books. That means, there exists an increasing succession of numbers <img src="/../images/dge.org-external-7-714img4.gif.png" alt="$0 = b_0 &lt;b_1 &lt; b_2, \dots &lt; b_{k-1} \le b_k = m$">such that <em>i</em>-th scriber gets a sequence of books with numbers between <em>b**i</em>-1+1 and <em>b**i</em>. The time needed to make a copy of all the books is determined by the scriber who was assigned the most work. Therefore, our goal is to minimize the maximum number of pages assigned to a single scriber. Your task is to find the optimal assignment.</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>The input consists of <em>N</em> cases. The first line of the input contains only positive integer <em>N</em>. Then follow the cases. Each case consists of exactly two lines. At the first line, there are two integers<em>m</em> and <em>k</em>, <img src="/../images/dge.org-external-7-714img5.gif.png" alt="$1 \le k \le m \le 500$">. At the second line, there are integers <img src="/../images/dge.org-external-7-714img6.gif.png" alt="$p_1, p_2, \dots p_m$"> separated by spaces. All these values are positive and less than 10000000.</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>For each case, print exactly one line. The line must contain the input succession <img src="/../images/dge.org-external-7-714img6.gif.png" alt="$p_1, p_2, \dots p_m$">divided into exactly <em>k</em> parts such that the maximum sum of a single part should be as small as possible. Use the slash character (&#96;&#x2F;‘) to separate the parts. There must be exactly one space character between any two successive numbers and between the number and the slash.</p>
<p>If there is more than one solution, print the one that minimizes the work assigned to the first scriber, then to the second scriber etc. But each scriber must be assigned at least one book.</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>2 9 3 100 200 300 400 500 600 700 800 900 5 4 100 100 100 100 100</p>
<h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><p>100 200 300 400 500 &#x2F; 600 700 &#x2F; 800 900 100 &#x2F; 100 &#x2F; 100 &#x2F; 100 100</p>
<h1 id="-5"><a href="#-5" class="headerlink" title=""></a></h1><hr>
<p>Before the invention of book-printing, it was very hard to make a copy of a book. All the contents had to be re-written by hand by so called <em>scribers</em>. The scriber had been given a book and after several months he finished its copy. One of the most famous scribers lived in the 15th century and his name was Xaverius Endricus Remius Ontius Xendrianus (<em>Xerox</em>). Anyway, the work was very annoying and boring. And the only way to speed it up was to hire more scribers.</p>
<p>Once upon a time, there was a theater ensemble that wanted to play famous Antique Tragedies. The scripts of these plays were divided into many books and actors needed more copies of them, of course. So they hired many scribers to make copies of these books. Imagine you have <em>m</em> books (numbered <img src="/../images/dge.org-external-7-714img1.gif.png" alt="$1, 2, \dots, m$">) that may have different number of pages ( <img src="/../images/dge.org-external-7-714img2.gif.png" alt="$p_1, p_2, \dots, p_m$">) and you want to make one copy of each of them. Your task is to divide these books among <em>k</em> scribes, <img src="/../images/dge.org-external-7-714img3.gif.png" alt="$k \le m$">. Each book can be assigned to a single scriber only, and every scriber must get a continuous sequence of books. That means, there exists an increasing succession of numbers <img src="/../images/dge.org-external-7-714img4.gif.png" alt="&#39;$0 = b_0 &lt;">such that <em>i</em>-th scriber gets a sequence of books with numbers between <em>b**i</em>-1+1 and <em>b**i</em>. The time needed to make a copy of all the books is determined by the scriber who was assigned the most work. Therefore, our goal is to minimize the maximum number of pages assigned to a single scriber. Your task is to find the optimal assignment.</p>
<h2 id="-6"><a href="#-6" class="headerlink" title=""></a></h2><p>The input consists of <em>N</em> cases. The first line of the input contains only positive integer <em>N</em>. Then follow the cases. Each case consists of exactly two lines. At the first line, there are two integers<em>m</em> and <em>k</em>, <img src="/../images/dge.org-external-7-714img5.gif.png" alt="$1 \le k \le m \le 500$">. At the second line, there are integers <img src="/../images/dge.org-external-7-714img6.gif.png" alt="$p_1, p_2, \dots p_m$"> separated by spaces. All these values are positive and less than 10000000.</p>
<h2 id="-7"><a href="#-7" class="headerlink" title=""></a></h2><p>For each case, print exactly one line. The line must contain the input succession <img src="/../images/dge.org-external-7-714img6.gif.png" alt="$p_1, p_2, \dots p_m$">divided into exactly <em>k</em> parts such that the maximum sum of a single part should be as small as possible. Use the slash character (&#96;&#x2F;‘) to separate the parts. There must be exactly one space character between any two successive numbers and between the number and the slash.</p>
<p>If there is more than one solution, print the one that minimizes the work assigned to the first scriber, then to the second scriber etc. But each scriber must be assigned at least one book.</p>
<h2 id="-8"><a href="#-8" class="headerlink" title=""></a></h2><p>2 9 3 100 200 300 400 500 600 700 800 900 5 4 100 100 100 100 100</p>
<h2 id="-9"><a href="#-9" class="headerlink" title=""></a></h2><p>100 200 300 400 500 &#x2F; 600 700 &#x2F; 800 900 100 &#x2F; 100 &#x2F; 100 &#x2F; 100 100</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>ZOJ 3427 Array Slicing （scanf使用）</title>
    <url>/posts/oj/other/ZOJ%203427%20Array%20Slicing%20%EF%BC%88scanf%E4%BD%BF%E7%94%A8%EF%BC%89/</url>
    <content><![CDATA[<p>题意 Watashi发明了一种蛋疼(eggache) 语言 你要为这个语言实现一个 array slicing 函数 这个函数的功能是 有一个数组初始为空 每次给你一个区间[ l, r) 和一些数 你要输出数组中下标在[l, r) 之间的数 然后删除这些数 然后把给你的那些数插入到数组的下标为 l 的位置</p>
<p>签到模拟题 一直没看懂题意 看了Watashi的scanf高端用法 弱到连scanf都不会用了 强行到<a href="http://www.cplusplus.com/reference/cstdio/scanf/?kw=scanf">cpp</a>预习了一下 先记录一下那些并不了解的scanf用法吧</p>
<p>int scanf ( const char &#x2F;* format, … );</p>
<p>format 由这些内容组成</p>
<ul>
<li><strong>空白字符:</strong> scanf在读入时会忽略下一个非空白字符之前的所有空白字符 <a href="http://www.cplusplus.com/reference/cctype/isspace/">空白字符</a>包含 ‘ ‘’\t’, ‘\n’, ‘\v’, ‘\f’, ‘\r<br>&#x2F;* 表示这个格式说明符所对应的内容读而不存 也不用为其指定参数 (注意区别 printf &#x2F;* 需要一个整型参数 表示至少输出多少位 不足用空格代替)</li>
</ul>
<p>width 表示最多读取多少位字符<br>length 有的话一定是这几个之一 hh , h , l , ll , j , z , t , L 对应同种数据的不同位数类型如 int(d) 和 long long(lld)   重点是 specifier <em>specifier</em> 描述 Characters extracted i Integer Any number of digits, optionally preceded by a sign (+ or -).<br><a href="http://www.cplusplus.com/isdigit">Decimal digits</a> assumed by default (0-9), but a 0 prefix introduces octal digits (0-7), and 0x <a href="http://www.cplusplus.com/isxdigit">hexadecimal digits</a> (0-f).<br><em>Signed</em> argument. d <em>or</em> u<br> Decimal integer Any number of <a href="http://www.cplusplus.com/isdigit">decimal digits</a> (0-9), optionally preceded by a sign (+ or -).<br>d is for a <em>signed</em> argument, and u for an <em>unsigned</em>. o Octal integer Any number of octal digits (0-7), optionally preceded by a sign (+ or -).<br><em>Unsigned</em> argument. x Hexadecimal integer Any number of <a href="http://www.cplusplus.com/isxdigit">hexadecimal digits</a> (0-9, a-f, A-F), optionally preceded by 0x or 0X, and all optionally preceded by a sign (+ or -).<br><em>Unsigned</em> argument. f, e, g Floating point number A series of <a href="http://www.cplusplus.com/isdigit">decimal</a> digits, optionally containing a decimal point, optionally preceeded by a sign (+ or -) and optionally followed by the e or E character and a decimal integer (or some of the other sequences supported by <a href="http://www.cplusplus.com/strtod">strtod</a>).<br>Implementations complying with C99 also support hexadecimal floating-point format when preceded by</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">0x</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">0X</span><br></pre></td></tr></table></figure>
<p>. a c Character The next character. If a <em>width</em> other than 1 is specified, the function reads exactly <em>width</em>characters and stores them in the successive locations of the array passed as argument. No null character is appended at the end. s String of characters Any number of non-whitespace characters, stopping at the first <a href="http://www.cplusplus.com/isspace">whitespace</a> character found. A terminating null character is automatically added at the end of the stored sequence. p Pointer address A sequence of characters representing a pointer. The particular format used depends on the system and library implementation, but it is the same as the one used to format %p in <a href="http://www.cplusplus.com/fprintf">fprintf</a>. [<em>characters</em>] Scanset Any number of the characters specified between the brackets.<br>A dash (-) that is not the first character may produce non-portable behavior in some library implementations. [^<em>characters</em>] Negated scanset Any number of characters none of them specified as <em>characters</em> between the brackets. n Count No input is consumed.<br>The number of characters read so far from <a href="http://www.cplusplus.com/stdin">stdin</a> is stored in the pointed location. % % A % followed by another % matches a single %.<br>除了 n 之外 specifier至少匹配一个输入的字符 否则读入会在当前字符终止 n需要一个指向int的参数 保存在这之前读取了多少位字符  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    char s[<span class="number">500</span>];</span><br><span class="line">    int n;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%s%n&quot;</span>, s, &amp;n);</span><br><span class="line">    <span class="title function_">printf</span>(<span class="string">&quot;%s  %d\n&quot;</span>, s, n);</span><br><span class="line">    <span class="comment">//输入hello</span></span><br><span class="line">    <span class="comment">//输出hello 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> printf中也可以使用%n表示这条语句这之前输出了多少位字符  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    <span class="title function_">printf</span>(<span class="string">&quot;hello%n&quot;</span>, &amp;n);</span><br><span class="line">    <span class="title function_">printf</span>(<span class="string">&quot; %d\n&quot;</span>, n);</span><br><span class="line">    <span class="comment">//输出hello 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>specifier可以是[…]、[^…]这两种<a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式</a></p>
<p>[…]表示读取括号中包含的字符 遇到其他字符就结束这个specifier</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    char s[<span class="number">500</span>];</span><br><span class="line">    int n;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot; %[0-9]%n&quot;</span>, s, &amp;n);<span class="comment">//%[0-9]只读取数字  遇到非数字结束</span></span><br><span class="line">    <span class="title function_">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>, s, n);</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot; %[ab]%n&quot;</span>, s, &amp;n);</span><br><span class="line">    <span class="title function_">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>, s, n);</span><br><span class="line">    <span class="comment">//输入&quot;   12345abc&quot;  前面有三个空格</span></span><br><span class="line">    <span class="comment">//输出12345 8  ab 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[^…]表示读取除括号中字符之外的所有字符 遇到括号中的字符就结束这个specifier</p>
<p>当然这些东西sscanf也适用</p>
<p>感觉预习了scanf之后这个题的输入就很好处理了 直接用list的<a href="http://www.cplusplus.com/reference/list/list/splice/">splice</a>函数就行了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char s[<span class="number">5000</span>], *ps;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    list&lt;int&gt; a, b;</span><br><span class="line">    int l, r, n, v;</span><br><span class="line">    list&lt;int&gt;::iterator it;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot; [ %d : %d ]%[^\n]&quot;</span>, &amp;l, &amp;r, s))</span><br><span class="line">    &#123;</span><br><span class="line">        b.<span class="title function_">clear</span>();</span><br><span class="line">        ps = s;</span><br><span class="line">        <span class="keyword">while</span>(<span class="title function_">sscanf</span>(ps, <span class="string">&quot;%*[^-0-9]%d%n&quot;</span>, &amp;v, &amp;n) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//过滤掉非&#x27;-&#x27;和数字再读入一个数</span></span><br><span class="line">            <span class="comment">//n记录scanf读了多少个字符</span></span><br><span class="line">            ps = ps + n;  <span class="comment">//读了n个字符所以要前进n位</span></span><br><span class="line">            b.<span class="title function_">push_back</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">advance</span>(it = a.<span class="title function_">begin</span>(), l);</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;%d%s&quot;</span>, *it, l &lt; r - <span class="number">1</span> ? <span class="string">&quot;, &quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">            it = a.<span class="title function_">erase</span>(it);</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        a.<span class="title function_">splice</span>(it, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Array Slicing    Time Limit:2 Seconds Memory Limit:65536 KB</p>
<p>Array slicing is an operation that extracts certain elements from an array and packages them as another array. Now you’re asked to implements the array slicing operations for a new programming language – <em>eggache&#x2F;</em>* (pronounced “eggache star”). The grammar of array slicing in <em>eggache&#x2F;</em>* is:<br>[ <em>begin</em> : <em>end</em> ] &#x3D; <em>x1</em>, <em>x2</em>, …, <em>xk</em>, …<br>where begin ≤ end are indices indicating the range of slice. Redundant whitespaces should be ignored. For each operation, the original slice should be printed first, then these elements will be replaced with the new elements provided. See sample for more details.</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>There is only one case for this problem, which contains about 50 lines of array slicing operations. It’s guaranteed that all operations are valid and the absolute values of all integers never exceed 100. <strong>The array is empty ([]) before the first operation.</strong></p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>The output produced by array slicing operations in the <em>eggache&#x2F;</em>* programming language.</p>
<h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h4><p>[ 0 : 0] &#x3D; 1 2 3 4 5 6 7 8 9 [ 1 : 1] &#x3D; -1 [ 1 : 1] &#x3D; [ 0 : 8] &#x3D; 9 8 7 6 5 4 3 2 1 [ 2 : 8] &#x3D; -2, -3, -5, -7 [ 0 : 9] &#x3D; 000 [ 0 : 1] &#x3D; 1, 2, 8 [ 2 : 2] &#x3D; 4 [ 0 : 4] &#x3D;</p>
<h4 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h4><p>1, -1, 2, 3, 4, 5, 6, 7 7, 6, 5, 4, 3, 2 9, 8, -2, -3, -5, -7, 1, 8, 9 0 1, 2, 4, 8</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>ZOJ 3804 YY&#39;s Minions(模拟)</title>
    <url>/posts/oj/other/ZOJ%203804%20YY&#39;s%20Minions(%E6%A8%A1%E6%8B%9F)/</url>
    <content><![CDATA[<p>题意 你有n&#x2F;*m个小兵排成一个矩阵 每个在矩阵里的小兵有两种状态 0睡着 或 1清醒 每秒都会发生如下事件 睡着的小兵在他周围恰好有3个醒着的小兵时会醒过来 醒着的 小兵在周围醒着的的小兵数大于3或小于2时会睡着 还有k个小兵会在一定的时间离开 X 求f秒之后所有小兵的状态</p>
<p>直接模拟就行咯~~</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N=<span class="number">55</span>,F=<span class="number">1005</span>;</span><br><span class="line">#define r (x+i)</span><br><span class="line">#define c (y+j)</span><br><span class="line">char s[N][N],cn[N][N];</span><br><span class="line">int n,m;</span><br><span class="line">int <span class="title function_">cnt</span>(<span class="params">int x,int y</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int ccc=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=-<span class="number">1</span>; i&lt;=<span class="number">1</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span>(int j=-<span class="number">1</span>; j&lt;=<span class="number">1</span>; ++j)</span><br><span class="line">            <span class="keyword">if</span>(r&gt;<span class="number">0</span>&amp;&amp;r&lt;=n&amp;&amp;c&gt;<span class="number">0</span>&amp;&amp;c&lt;=m&amp;&amp;(i||j))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[r][c]==<span class="string">&#x27;1&#x27;</span>) ++ccc;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> ccc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">turn</span>(<span class="params">int x,int y</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cc=cn[x][y];</span><br><span class="line">    <span class="keyword">if</span>(s[x][y]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;cc==<span class="number">3</span>)</span><br><span class="line">        s[x][y]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s[x][y]==<span class="string">&#x27;1&#x27;</span>&amp;&amp;((cc&lt;<span class="number">2</span>)||(cc&gt;<span class="number">3</span>)))</span><br><span class="line">        s[x][y]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas,f,k,t,x,y,row,col;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;cas);</span><br><span class="line">    <span class="keyword">while</span>(cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;f,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]+<span class="number">1</span>);</span><br><span class="line">        stack&lt;int&gt; lx[F],ly[F];</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>; i&lt;=k; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;t,&amp;x,&amp;y);</span><br><span class="line">            lx[t].<span class="title function_">push</span>(x);</span><br><span class="line">            ly[t].<span class="title function_">push</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(t=<span class="number">1</span>; t&lt;=f; ++t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(int i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">                <span class="keyword">for</span>(int j=<span class="number">1</span>; j&lt;=m; ++j)</span><br><span class="line">                    cn[i][j]=<span class="title function_">cnt</span>(i,j);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(int i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">                <span class="keyword">for</span>(int j=<span class="number">1</span>; j&lt;=m; ++j)</span><br><span class="line">                    <span class="title function_">turn</span>(i,j);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(!(lx[t].<span class="title function_">empty</span>()))</span><br><span class="line">            &#123;</span><br><span class="line">                row=lx[t].<span class="title function_">top</span>();</span><br><span class="line">                col=ly[t].<span class="title function_">top</span>();</span><br><span class="line">                s[row][col]=<span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                lx[t].<span class="title function_">pop</span>();</span><br><span class="line">                ly[t].<span class="title function_">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;%s\n&quot;</span>,s[i]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  YY’s Minions    Time Limit:2 Seconds  Memory Limit:65536 KB</p>
<p>Despite YY’s so much homework, she would like to take some time to play with her minions first.</p>
<p>YY lines her minions up to anN&#x2F;*Mmatrix. Every minionhas two statuses: awake or asleep. We use 0(the digit) to represent that it is asleep, and 1 for awake. Also, we define the minions who are around a minion<strong>closest</strong>in one of the<strong>eight</strong>directions its neighbors. And every minute every minion will change its status by the following specific rules:<br>If this minion is awake, and the number of its neighbors who are awake is less than 2, this minion will feel lonely and turn to asleep.If this minion is awake, and the number of its neighbors who are awake is more than 3, this minion will turn to asleep for it will feel too crowded.If this minion is awake, and the number of its neighbors who are awake is exactly 2 or 3, this minion will keep being awake and feel very happy.If this minion is asleep, and the number of its neighbors who are awake is exactly 3, this minion will wake up because of the noise.</p>
<p>Note that all changes take place at the same time at the beginning of a specific minute.</p>
<p>Also, some minions will get bored and leave this silly game. We use ‘X’s to describe them. We suppose that a minion would leave afterTminutes. It will leave at the end of the Tthminute. Its status is considered during the change at the beginning of the Tthminute, and should be ignored after that. Of course, one minion will not leave twice!</p>
<p>YY is a girl full of curiosity and wants to know every minion’s status afterFminutes. But you know she is weak and lazy! Please help this cute girl to solve this problem :)</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>There are multiple test cases.</p>
<p>The first line contains the number of test casesQ. 1&lt;&#x3D;Q&lt;&#x3D;100.<br>For each case, there are several lines:<br>The first line contains four integersN,M,F,K.Kmeans the number of leaving messages. 1&lt;&#x3D;N,M&lt;&#x3D;50, 1&lt;&#x3D;F&lt;&#x3D;1000, 1&lt;&#x3D;K&lt;&#x3D;N&#x2F;*M.<br>NextNlines are the matrix which shows the initial status of each minion. Each line containsMchars. We guarantee that ‘X’ wouldn’t appear in initial status matrix.<br>And nextKlines are the leaving messages. Each line contains three integersTi,Xi,Yi, They mean the minion who is located in (Xi,Yi) will leave the game at the end of theTithminutes. 1&lt;&#x3D;Ti&lt;&#x3D;F, 1&lt;&#x3D;Xi&lt;&#x3D;N, 1&lt;&#x3D;Yi&lt;&#x3D;M.</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>For each case, outputNlines as a matrix which shows the status of each minion afterFminutes.</p>
<h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h4><p>2 3 3 2 1 101 110 001 1 2 2 5 5 6 3 10111 01000 00000 01100 10000 2 3 3 2 4 1 5 1 5</p>
<h4 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h4><p>010 1X0 010 0000X 11000 00X00 X0000 00000</p>
<h4 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h4><p>For case 1: T&#x3D;0, the game starts 101 110 001 ————— at the beginning of T&#x3D;1, a change took place 100 101 010 ————— at the end of T&#x3D;1 (the minion in (2,2) left) 100 1X1 010 ————— at the beginning of T&#x3D;2, a change took place 010 1X0 010 ————— at the end of T&#x3D;2 (nothing changed for no minion left at T&#x3D;2) 010 1X0 010</p>
<p>﻿﻿</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces 327D Block Tower（DFS）</title>
    <url>/posts/oj/search/CodeForces%20327D%20Block%20Tower%EF%BC%88DFS%EF%BC%89/</url>
    <content><![CDATA[<p>题意 给你一个城市的地图 你可以在地图上的 . 上建房子&#x2F;#上不能建房子 红房子可以装200个人 蓝房子可以装100个人 只有相邻位置有蓝房子时才能建红房子 你也可以拆掉已经建成的房子 拆掉后该点又变成 .</p>
<p>这题想到了就很容易了 因为没有限制要步数最少 可以先把左右的地方都建成蓝房子 然后就变成求连通块的题了 每个蓝房子连通块内依次拆掉建红房子 最终就只剩下一个蓝房子了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">505</span>;</span><br><span class="line">char g[N][N];</span><br><span class="line">stack&lt;pair&lt;int, int&gt; &gt; s;</span><br><span class="line">int x[] = &#123; -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">int y[] = &#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">int n, m, a, b, cnt, is_first;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">dfs</span>(<span class="params">int i, int j</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int r, c;</span><br><span class="line">    <span class="keyword">if</span>(is_first) is_first = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> s.<span class="title function_">push</span>(<span class="title function_">make_pair</span>(i, j));</span><br><span class="line">    g[i][j] = <span class="string">&#x27;R&#x27;</span>, cnt += <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span>(int k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        r = i + x[k], c = j + y[k];</span><br><span class="line">        <span class="keyword">if</span>(g[r][c] == <span class="string">&#x27;.&#x27;</span>) <span class="title function_">dfs</span>(r, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, g[i] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">                <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;.&#x27;</span>)  is_first = <span class="number">1</span>, cnt -= <span class="number">2</span>, <span class="title function_">dfs</span>(i, j);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">                <span class="keyword">if</span>(g[i][j] != <span class="string">&#x27;#&#x27;</span>) <span class="title function_">printf</span>(<span class="string">&quot;B %d %d\n&quot;</span>, i, j);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="title function_">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            a = s.<span class="title function_">top</span>().<span class="property">first</span>, b = s.<span class="title function_">top</span>().<span class="property">second</span>;</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;D %d %d\nR %d %d\n&quot;</span>, a, b, a, b);</span><br><span class="line">            s.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Block Tower</p>
<p>After too much playing on paper, Iahub has switched to computer games. The game he plays is called “Block Towers”. It is played in a rectangular grid with <em>n</em> rows and <em>m</em> columns (it contains <em>n</em> × <em>m</em> cells). The goal of the game is to build your own city. Some cells in the grid are big holes, where Iahub can’t build any building. The rest of cells are empty. In some empty cell Iahub can build exactly one tower of two following types:</p>
<p>Iahub is also allowed to destroy a building from any cell. He can do this operation as much as he wants. After destroying a building, the other buildings are not influenced, and the destroyed cell becomes empty (so Iahub can build a tower in this cell if needed, see the second example for such a case).</p>
<p>Iahub can convince as many population as he wants to come into his city. So he needs to configure his city to allow maximum population possible. Therefore he should find a sequence of operations that builds the city in an optimal way, so that total population limit is as large as possible.</p>
<p>He says he’s the best at this game, but he doesn’t have the optimal solution. Write a program that calculates the optimal one, to show him that he’s not as good as he thinks.<br>Input</p>
<p>The first line of the input contains two integers <em>n</em> and <em>m</em> (1 ≤ <em>n</em>, <em>m</em> ≤ 500). Each of the next <em>n</em> lines contains <em>m</em> characters, describing the grid. The <em>j</em>-th character in the <em>i</em>-th line is ‘.’ if you’re allowed to build at the cell with coordinates (<em>i</em>, <em>j</em>) a tower (empty cell) or ‘&#x2F;#’ if there is a big hole there.</p>
<p>Output</p>
<p>Print an integer <em>k</em> in the first line (0 ≤ <em>k</em> ≤ 106) — the number of operations Iahub should perform to obtain optimal result.</p>
<p>Each of the following <em>k</em> lines must contain a single operation in the following format:</p>
<p>If there are multiple solutions you can output any of them. Note, that you shouldn’t minimize the number of operations.<br>Sample test(s)</p>
<p>input 2 3 ..&#x2F;# .&#x2F;#.</p>
<p>output 4 B 1 1 R 1 2 R 2 1 B 2 3<br>input 1 3 …</p>
<p>output 5 B 1 1 B 1 2 R 1 3 D 1 2 R 1 2</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Search</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>FZU 2150 Fire Game(DFS+BFS)</title>
    <url>/posts/oj/search/FZU%202150%20Fire%20Game(DFS+BFS)/</url>
    <content><![CDATA[<p>题意 在n&#x2F;*m个格子组成的草地上 你可以选择两个是草(‘&#x2F;#’)的格子点燃 每个点燃的格子在下一秒其四个相邻的是草的格子也会被点燃 问点燃所有的草至少需要多少秒</p>
<p>DFS和BFS的综合 如果’&#x2F;#‘连通块的数量大于2个是肯定不能点燃所有的 先dfs判断连通块个数 再bfs找出选哪两个格子可以最快把草烧完</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">12</span>;</span><br><span class="line">int x[] = &#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">int y[] = &#123; -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">char g[N][N] , v[N][N];</span><br><span class="line">int  n, m, nu, cnt, ret;</span><br><span class="line">pair&lt;int, int&gt; q[N * N], p[N * N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span>(<span class="params">int r, int c</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(g[r][c] != <span class="string">&#x27;#&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    p[nu++] = <span class="title function_">make_pair</span>(r, c), g[r][c] = cnt;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span>(r + x[i] &gt;= <span class="number">0</span> &amp;&amp; c + y[i] &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="title function_">dfs</span>(r + x[i], c + y[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">bfs</span>(<span class="params">int r, int c, int cr, int cc</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int le = <span class="number">0</span>, ri = <span class="number">0</span>;</span><br><span class="line">    q[ri++] = <span class="title function_">make_pair</span>(r, c);</span><br><span class="line">    q[ri++] = <span class="title function_">make_pair</span>(cr, cc);</span><br><span class="line">    <span class="title function_">memset</span>(v, <span class="number">0</span>, <span class="title function_">sizeof</span>(v)), v[r][c] = v[cr][cc] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(le &lt; ri)</span><br><span class="line">    &#123;</span><br><span class="line">        cr = q[le].<span class="property">first</span>, cc = q[le++].<span class="property">second</span>, ret = v[cr][cc];</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            r = cr + x[i], c = cc + y[i];</span><br><span class="line">            <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; r &lt; n &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; m &amp;&amp; g[r][c] != <span class="string">&#x27;.&#x27;</span> &amp;&amp; !v[r][c])</span><br><span class="line">                q[ri++] = <span class="title function_">make_pair</span>(r, c), v[r][c] = v[cr][cc] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas, ans, r1, c1, r2, c2;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">for</span>(int k = <span class="number">1</span>; k &lt;= cas; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, g[i]);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;Case %d: &quot;</span>, k);</span><br><span class="line"></span><br><span class="line">        nu = cnt = ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">                <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;#&#x27;</span>) ++cnt, <span class="title function_">dfs</span>(i, j);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cnt &lt; <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = n * m;</span><br><span class="line">            <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; nu; ++i)</span><br><span class="line">                <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; nu; ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    r1 = p[i].<span class="property">first</span>, c1 = p[i].<span class="property">second</span>;</span><br><span class="line">                    r2 = p[j].<span class="property">first</span>, c2 = p[j].<span class="property">second</span>;</span><br><span class="line">                    <span class="keyword">if</span>(cnt == <span class="number">2</span> &amp;&amp; g[r1][c1] == g[r2][c2]) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="title function_">bfs</span>(r1, c1, r2, c2);</span><br><span class="line">                    <span class="keyword">if</span>(ret &lt; ans) ans = ret;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Problem 2150 Fire Game</strong></p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title=" Problem Description"></a><img src="/../images/cn-image-prodesc.gif.png"> Problem Description</h2><p>Fat brother and Maze are playing a kind of special (hentai) game on an N&#x2F;*M board (N rows, M columns). At the beginning, each grid of this board is consisting of grass or just empty and then they start to fire all the grass. Firstly they choose two grids which are consisting of grass and set fire. As we all know, the fire can spread among the grass. If the grid (x, y) is firing at time t, the grid which is adjacent to this grid will fire at time t+1 which refers to the grid (x+1, y), (x-1, y), (x, y+1), (x, y-1). This process ends when no new grid get fire. If then all the grid which are consisting of grass is get fired, Fat brother and Maze will stand in the middle of the grid and playing a MORE special (hentai) game. (Maybe it’s the OOXX game which decrypted in the last problem, who knows.)</p>
<p>You can assume that the grass in the board would never burn out and the empty grid would never get fire.</p>
<p>Note that the two grids they choose can be the same.</p>
<h2 id="Input"><a href="#Input" class="headerlink" title=" Input"></a><img src="/../images/cn-image-prodesc.gif.png"> Input</h2><p>The first line of the date is an integer T, which is the number of the text cases.</p>
<p>Then T cases follow, each case contains two integers N and M indicate the size of the board. Then goes N line, each line with M character shows the board. “&#x2F;#” Indicates the grass. You can assume that there is at least one grid which is consisting of grass in the board.</p>
<p>1 &lt;&#x3D; T &lt;&#x3D;100, 1 &lt;&#x3D; n &lt;&#x3D;10, 1 &lt;&#x3D; m &lt;&#x3D;10</p>
<h2 id="Output"><a href="#Output" class="headerlink" title=" Output"></a><img src="/../images/cn-image-prodesc.gif.png"> Output</h2><p>For each case, output the case number first, if they can play the MORE special (hentai) game (fire all the grass), output the minimal time they need to wait after they set fire, otherwise just output -1. See the sample input and output for more details.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title=" Sample Input"></a><img src="/../images/cn-image-prodesc.gif.png"> Sample Input</h2><p>4</p>
<p>3 3<br>.&#x2F;#.</p>
<p>&#x2F;#&#x2F;#&#x2F;#<br>.&#x2F;#.</p>
<p>3 3<br>.&#x2F;#.</p>
<p>&#x2F;#.&#x2F;#<br>.&#x2F;#.</p>
<p>3 3<br>…</p>
<p>&#x2F;#.&#x2F;#<br>…</p>
<p>3 3<br>&#x2F;#&#x2F;#&#x2F;#</p>
<p>..&#x2F;#<br>&#x2F;#.&#x2F;#</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title=" Sample Output"></a><img src="/../images/cn-image-prodesc.gif.png"> Sample Output</h2><p>Case 1: 1</p>
<p>Case 2: -1<br>Case 3: 0</p>
<p>Case 4: 2</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Search</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1043 Eight (BFS·八数码·康托展开)</title>
    <url>/posts/oj/search/HDU%201043%20Eight%20(BFS%C2%B7%E5%85%AB%E6%95%B0%E7%A0%81%C2%B7%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80)/</url>
    <content><![CDATA[<p>题意 输出八数码问题从给定状态到12345678x的路径</p>
<p>用康托展开将排列对应为整数 即这个排列在所有排列中的字典序 然后就是基础的BFS了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">5e5</span>, M = <span class="number">9</span>;</span><br><span class="line">int x[<span class="number">4</span>] = &#123; -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">int y[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">int fac[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>, <span class="number">720</span>, <span class="number">5040</span>, <span class="number">40320</span>&#125;;</span><br><span class="line">int puz[N][M], nex[N], dir[N], vis[N], q[N];</span><br><span class="line"></span><br><span class="line">int <span class="title function_">getCantor</span>(int a[])  <span class="comment">//康托展开  将排列转化为整数</span></span><br><span class="line">&#123;</span><br><span class="line">    int ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; M; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int j = i + <span class="number">1</span>; j &lt; M; ++j)</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[i]) ret += fac[M - i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">bfs</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int t[M] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    int id = <span class="title function_">getCantor</span>(t);</span><br><span class="line">    dir[id] = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">memcpy</span>(puz[id], t, <span class="title function_">sizeof</span>(t));</span><br><span class="line">    <span class="title function_">memset</span>(vis, <span class="number">0</span>, <span class="title function_">sizeof</span>(vis));</span><br><span class="line"></span><br><span class="line">    int r, c, k, nr, nc, nk, nid;</span><br><span class="line">    int front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">    q[rear++] = id;</span><br><span class="line">    vis[id] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(front &lt; rear)</span><br><span class="line">    &#123;</span><br><span class="line">        int id = q[front++];</span><br><span class="line">        <span class="title function_">memcpy</span>(t, puz[id], <span class="title function_">sizeof</span>(t));</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; t[k]; ++k);  <span class="comment">//找0的位置</span></span><br><span class="line">        r = k / <span class="number">3</span>, c = k % <span class="number">3</span>;  <span class="comment">//一维转二维</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nr = r + x[i], nc = c + y[i], nk = nr * <span class="number">3</span> + nc;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nr &lt; <span class="number">0</span> || nr &gt; <span class="number">2</span> || nc &lt; <span class="number">0</span> || nc &gt; <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="title function_">swap</span>(t[k], t[nk]);</span><br><span class="line">            nid = <span class="title function_">getCantor</span>(t);</span><br><span class="line">            <span class="title function_">memcpy</span>(puz[nid], t, <span class="title function_">sizeof</span>(t));</span><br><span class="line">            <span class="title function_">swap</span>(t[k], t[nk]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(vis[nid]) <span class="keyword">continue</span>;</span><br><span class="line">            vis[nid] = <span class="number">1</span>;</span><br><span class="line">            q[rear++] = nid;</span><br><span class="line">            nex[nid] = id;</span><br><span class="line">            dir[nid] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    char t[<span class="number">5</span>], sdir[] = <span class="string">&quot;durl&quot;</span>;</span><br><span class="line">    int s[M], id;</span><br><span class="line">    <span class="title function_">bfs</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, t))</span><br><span class="line">    &#123;</span><br><span class="line">        s[<span class="number">0</span>] = t[<span class="number">0</span>] == <span class="string">&#x27;x&#x27;</span> ? <span class="number">0</span> : t[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; M; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, t);</span><br><span class="line">            s[i] = t[<span class="number">0</span>] == <span class="string">&#x27;x&#x27;</span> ? <span class="number">0</span> : t[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        id = <span class="title function_">getCantor</span>(s);</span><br><span class="line">        <span class="keyword">if</span>(!vis[id]) <span class="title function_">puts</span>(<span class="string">&quot;unsolvable&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(dir[id] &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="title function_">printf</span>(<span class="string">&quot;%c&quot;</span>, sdir[dir[id]]);</span><br><span class="line">                id = nex[id];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Last modified :   2015-07-05 11:15</span></span><br></pre></td></tr></table></figure>

<h1 id="Eight"><a href="#Eight" class="headerlink" title="Eight"></a>Eight</h1><p>Problem Description</p>
<p>The 15-puzzle has been around for over 100 years; even if you don’t know it by that name, you’ve seen it. It is constructed with 15 sliding tiles, each with a number from 1 to 15 on it, and all packed into a 4 by 4 frame with one tile missing. Let’s call the missing tile ‘x’; the object of the puzzle is to arrange the tiles so that they are ordered as: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 x<br>where the only legal operation is to exchange ‘x’ with one of the tiles with which it shares an edge. As an example, the following sequence of moves solves a slightly scrambled puzzle:<br>1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 5 6 7 8 5 6 7 8 5 6 7 8 5 6 7 8 9 x 10 12 9 10 x 12 9 10 11 12 9 10 11 12 13 14 11 15 13 14 11 15 13 14 x 15 13 14 15 x r-&gt; d-&gt; r-&gt;<br>The letters in the previous row indicate which neighbor of the ‘x’ tile is swapped with the ‘x’ tile at each step; legal values are ‘r’,’l’,’u’ and ‘d’, for right, left, up, and down, respectively.<br>Not all puzzles can be solved; in 1870, a man named Sam Loyd was famous for distributing an unsolvable version of the puzzle, and<br>frustrating many people. In fact, all you have to do to make a regular puzzle into an unsolvable one is to swap two tiles (not counting the missing ‘x’ tile, of course).<br>In this problem, you will write a program for solving the less well-known 8-puzzle, composed of tiles on a three by three<br>arrangement.<br>Input</p>
<p>You will receive, several descriptions of configuration of the 8 puzzle. One description is just a list of the tiles in their initial positions, with the rows listed from top to bottom, and the tiles listed from left to right within a row, where the tiles are represented by numbers 1 to 8, plus ‘x’. For example, this puzzle<br>1 2 3<br>x 4 6<br>7 5 8<br>is described by this list:<br>1 2 3 x 4 6 7 5 8<br>Output</p>
<p>You will print to standard output either the word &#96;&#96;unsolvable’’, if the puzzle has no solution, or a string consisting entirely of the letters ‘r’, ‘l’, ‘u’ and ‘d’ that describes a series of moves that produce a solution. The string should include no spaces and start at the beginning of the line. Do not print a blank line between cases.<br>Sample Input</p>
<p>2 3 4 1 5 x 7 6 8<br>Sample Output</p>
<p>ullddrurdllurdruldr</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Search</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1495 非常可乐(BFS 倒水问题)</title>
    <url>/posts/oj/search/HDU%201495%20%E9%9D%9E%E5%B8%B8%E5%8F%AF%E4%B9%90(BFS%20%E5%80%92%E6%B0%B4%E9%97%AE%E9%A2%98)/</url>
    <content><![CDATA[<p>题意 将体积为s的可乐 利用容积分别为n和m的两个杯子平均分为两份 至少需要倒多少次可乐</p>
<p>可以把容器s,n,m中装的可乐量看成一种状态</p>
<p>容器都是没有刻度的 所以每次倒可乐要么把自己倒完 要么把对方倒满</p>
<p>每种状态可以通过一次倒水到达哪些状态 于是可以通过bfs判断到达每种状态需要倒多少次</p>
<p>3个容器中有一个装的可乐为s&#x2F;2的状态就是答案了 s是奇数时明显不可能平分的 可以直接忽略</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">105</span>;</span><br><span class="line">int v[N][N][N], n, m, s, le, ri;</span><br><span class="line"></span><br><span class="line">struct state &#123;</span><br><span class="line">    int a, b, c, d;</span><br><span class="line">    <span class="title function_">state</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">    <span class="title function_">state</span>(int e, int f, int g, int h)</span><br><span class="line">        : <span class="title function_">a</span>(e), <span class="title function_">b</span>(f), <span class="title function_">c</span>(g), <span class="title function_">d</span>(<span class="params">h</span>) &#123;&#125;</span><br><span class="line">&#125; q[N * N * N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pour</span>(<span class="params">int a, int b, int c, int d</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!v[a][b][c])</span><br><span class="line">    &#123;</span><br><span class="line">        v[a][b][c] = <span class="number">1</span>;</span><br><span class="line">        q[ri++] = <span class="title function_">state</span>(a, b, c, d + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">bfs</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int a, b, c, d;</span><br><span class="line">    le = ri = <span class="number">0</span>;</span><br><span class="line">    q[ri++] = <span class="title function_">state</span>(s, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="title function_">memset</span>(v, <span class="number">0</span>, <span class="title function_">sizeof</span>(v));</span><br><span class="line">    v[s][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(le &lt; ri)</span><br><span class="line">    &#123;</span><br><span class="line">        a = q[le].<span class="property">a</span>, b = q[le].<span class="property">b</span>, c = q[le].<span class="property">c</span>, d = q[le++].<span class="property">d</span>;</span><br><span class="line">        <span class="keyword">if</span>(a == s / <span class="number">2</span> || b == s / <span class="number">2</span> || c == s / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> d + (a &amp;&amp; b &amp;&amp; c != <span class="number">0</span>);</span><br><span class="line">        <span class="title function_">pour</span>(a - n + b, n, c, d);		    <span class="comment">//s-&gt;n:</span></span><br><span class="line">        <span class="title function_">pour</span>(a - m + c, b, m, d);		    <span class="comment">//s-&gt;m;</span></span><br><span class="line">        <span class="title function_">pour</span>(a + b, <span class="number">0</span>, c, d);			    <span class="comment">//n-&gt;s;</span></span><br><span class="line">        <span class="title function_">pour</span>(a + c, b, <span class="number">0</span>, d);                       <span class="comment">//m-&gt;s;</span></span><br><span class="line">        <span class="keyword">if</span>(b &gt; m - c) <span class="title function_">pour</span>(a, b - m + c, m, d);     <span class="comment">//n-&gt;m</span></span><br><span class="line">        <span class="keyword">else</span> <span class="title function_">pour</span>(a, <span class="number">0</span>, b + c, d);</span><br><span class="line">        <span class="keyword">if</span>(c &gt; n - b) <span class="title function_">pour</span>(a, n, c - n + b, d);     <span class="comment">//m-&gt;n</span></span><br><span class="line">        <span class="keyword">else</span> <span class="title function_">pour</span>(a, b + c, <span class="number">0</span>, d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int ans;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;s, &amp;n, &amp;m), n)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (s % <span class="number">2</span> == <span class="number">0</span>) ans = <span class="title function_">bfs</span>();</span><br><span class="line">        <span class="keyword">if</span>(!ans) <span class="title function_">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="非常可乐"><a href="#非常可乐" class="headerlink" title="非常可乐"></a>非常可乐</h1><p>Problem Description</p>
<p>大家一定觉的运动以后喝可乐是一件很惬意的事情，但是seeyou却不这么认为。因为每次当seeyou买了可乐以后，阿牛就要求和seeyou一起分享这一瓶可乐，而且一定要喝的和seeyou一样多。但seeyou的手中只有两个杯子，它们的容量分别是N 毫升和M 毫升 可乐的体积为S （S&lt;101）毫升　(正好装满一瓶) ，它们三个之间可以相互倒可乐 (都是没有刻度的，且 S&#x3D;&#x3D;N+M，101＞S＞0，N＞0，M＞0) 。聪明的ACMER你们说他们能平分吗？如果能请输出倒可乐的最少的次数，如果不能输出”NO”。<br>Input</p>
<p>三个整数 : S 可乐的体积 , N 和 M是两个杯子的容量，以”0 0 0”结束。<br>Output</p>
<p>如果能平分的话请输出最少要倒的次数，否则输出”NO”。<br>Sample Input</p>
<p>7 4 3 4 1 3 0 0 0<br>Sample Output</p>
<p>NO 3</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Search</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 2553 N皇后问题 (回溯法 递归·非递归)</title>
    <url>/posts/oj/search/HDU%202553%20N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%20(%E5%9B%9E%E6%BA%AF%E6%B3%95%20%E9%80%92%E5%BD%92%C2%B7%E9%9D%9E%E9%80%92%E5%BD%92)/</url>
    <content><![CDATA[<p>题意 中文n&#x2F;*n的棋盘放n个皇后(攻击同行&#x2F;列&#x2F;主副对角线) 使任何两个都不互相攻击 有多少种方法</p>
<p>枚举每一行 用vis[3][i]记录列 主对角线 副对角线是否被占 同列和对角线都没被占就继续枚举下一行 当枚举到n+1行的时候就是一个合法答案了</p>
<p>注: n&#x2F;*n的方阵中主对角线可以用(i-j+n)标号 副对角线可以用(i+j)标号</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ans[]=&#123;0,1,0,0,2,10,4,40,92,352,724&#125;;</span></span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">50</span>;</span><br><span class="line">int n, cnt, vis[<span class="number">3</span>][N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">getans</span>(<span class="params">int cur</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur == n)  ++cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; cur &lt; n &amp;&amp; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[<span class="number">0</span>][i] || vis[<span class="number">1</span>][cur + i] || vis[<span class="number">2</span>][cur - i + n]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[<span class="number">0</span>][i] = vis[<span class="number">1</span>][cur + i] = vis[<span class="number">2</span>][cur - i + n] = <span class="number">1</span>;</span><br><span class="line">        <span class="title function_">getans</span>(cur + <span class="number">1</span>);</span><br><span class="line">        vis[<span class="number">0</span>][i] = vis[<span class="number">1</span>][cur + i] = vis[<span class="number">2</span>][cur - i + n] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt = <span class="number">0</span>,n=i;</span><br><span class="line">        <span class="title function_">getans</span>(<span class="number">0</span>);</span><br><span class="line">        ans[i]=cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归的回溯</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int M = <span class="number">20</span>,  N = <span class="number">8</span>;</span><br><span class="line">int col[M], vis[<span class="number">3</span>][M], last[M], cnt;</span><br><span class="line"></span><br><span class="line">bool <span class="title function_">check</span>(int r) <span class="comment">//判断前r行是否有冲突</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; r; ++i) <span class="comment">//主i + col[i] == r + col[r], 副i - col[i] == r - col[r]</span></span><br><span class="line">        <span class="keyword">if</span>(i + col[i] == r + col[r] || i - col[i] == r - col[r] || col[i] == col[r])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">gao</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int r = <span class="number">1</span>;</span><br><span class="line">    col[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(r)</span><br><span class="line">    &#123;</span><br><span class="line">        col[r] = col[r] + <span class="number">1</span>; <span class="comment">//第r行的皇后换新位置</span></span><br><span class="line">        <span class="keyword">if</span>(col[r] &gt; N) &#123;--r; <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="title function_">check</span>(r)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(r == N)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">                <span class="title function_">printf</span>(<span class="string">&quot;%d &quot;</span>, col[i]);</span><br><span class="line">            <span class="title function_">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> col[++r] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="title function_">gao</span>();</span><br><span class="line">    <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有可以打印答案的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1000</span>;</span><br><span class="line">int n, cnt, c[N], col[N][N], vis[<span class="number">3</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">getans</span>(<span class="params">int cur</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur == n)</span><br><span class="line">    &#123;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            col[cnt][i] = c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(!vis[<span class="number">0</span>][i] &amp;&amp; !vis[<span class="number">1</span>][cur + i] &amp;&amp; !vis[<span class="number">2</span>][cur - i + n])</span><br><span class="line">            &#123;</span><br><span class="line">                c[cur] = i;</span><br><span class="line">                vis[<span class="number">0</span>][i] = vis[<span class="number">1</span>][cur + i] = vis[<span class="number">2</span>][cur - i + n] = <span class="number">1</span>;</span><br><span class="line">                <span class="title function_">getans</span>(cur + <span class="number">1</span>);</span><br><span class="line">                vis[<span class="number">0</span>][i] = vis[<span class="number">1</span>][cur + i] = vis[<span class="number">2</span>][cur - i + n] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">memset</span>(vis, <span class="number">0</span>, <span class="title function_">sizeof</span>(vis));</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="title function_">getans</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d皇后问题共有%d组解:\n\n&quot;</span>, n, cnt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(int k = <span class="number">1</span>; k &lt;= cnt; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                    <span class="title function_">printf</span>(<span class="string">&quot;%d &quot;</span>, j == col[k][i]);</span><br><span class="line">                <span class="title function_">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h1><p>Problem Description</p>
<p>在N&#x2F;*N的方格棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。<br>你的任务是，对于给定的N，求出有多少种合法的放置方法。<br>Input</p>
<p>共有若干行，每行一个正整数N≤10，表示棋盘和皇后的数量；如果N&#x3D;0，表示结束。<br>Output</p>
<p>共有若干行，每行一个正整数，表示对应输入行的皇后的不同放置数量。<br>Sample Input</p>
<p>1 8 5 0<br>Sample Output</p>
<p>1 92 10</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Search</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 2612 Find a way(双BFS)</title>
    <url>/posts/oj/search/HDU%202612%20Find%20a%20way(%E5%8F%8CBFS)/</url>
    <content><![CDATA[<p>题意 在n&#x2F;*m的地图中 ‘Y’和’M’两个人到某一家KFC(在地图上用”@’表示) 所需的最小时间和是多少 他们每走一步都要11分钟</p>
<p>可以分别以y和m为起点进行一遍bfs 把到每个KFC的时间都存起来 最后看哪家KFC的时间和最小就行了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">205</span>;</span><br><span class="line">int x[] = &#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">int y[] = &#123; -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">pair&lt;int, int&gt; q[N * N];</span><br><span class="line">int dy[N][N], dm[N][N], ans, n, m;</span><br><span class="line">char g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">bfs</span>(<span class="params">int r, int c, char k</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int (&amp;d)[N][N] = (k == <span class="string">&#x27;Y&#x27;</span> ? dy : dm); <span class="comment">//d为指向dy或dm的引用</span></span><br><span class="line">    int v[N][N] = &#123;<span class="number">0</span>&#125;, le = <span class="number">0</span>, ri = <span class="number">0</span>, cr, cc;</span><br><span class="line">    q[ri++] = <span class="title function_">make_pair</span>(r, c), v[r][c] = <span class="number">1</span>, d[r][c] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(le &lt; ri)</span><br><span class="line">    &#123;</span><br><span class="line">        r = q[le].<span class="property">first</span>, c = q[le++].<span class="property">second</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cr = r + x[i], cc = c + y[i];</span><br><span class="line">            <span class="keyword">if</span>(cr &gt;= <span class="number">0</span> &amp;&amp; cr &lt; n &amp;&amp; cc &gt;= <span class="number">0</span> &amp;&amp; cc &lt; m</span><br><span class="line">                    &amp;&amp; v[cr][cc] == <span class="number">0</span> &amp;&amp; g[cr][cc] != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                q[ri++] = <span class="title function_">make_pair</span>(cr, cc), d[cr][cc] = d[r][c] + <span class="number">1</span>, v[cr][cc] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n , &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        ans = N * N;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, g[i]);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">                <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;Y&#x27;</span> || g[i][j] == <span class="string">&#x27;M&#x27;</span>)  <span class="title function_">bfs</span>(i, j, g[i][j]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">                <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;@&#x27;</span>) ans = <span class="title function_">min</span>(ans, dy[i][j] + dm[i][j]);</span><br><span class="line"></span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans * <span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Find-a-way"><a href="#Find-a-way" class="headerlink" title="Find a way"></a>Find a way</h1><p>Problem Description</p>
<p>Pass a year learning in Hangzhou, yifenfei arrival hometown Ningbo at finally. Leave Ningbo one year, yifenfei have many people to meet. Especially a good friend Merceki.<br>Yifenfei’s home is at the countryside, but Merceki’s home is in the center of city. So yifenfei made arrangements with Merceki to meet at a KFC. There are many KFC in Ningbo, they want to choose one that let the total time to it be most smallest.<br>Now give you a Ningbo map, Both yifenfei and Merceki can move up, down ,left, right to the adjacent road by cost 11 minutes.<br>Input</p>
<p>The input contains multiple test cases.<br>Each test case include, first two integers n, m. (2&lt;&#x3D;n,m&lt;&#x3D;200).<br>Next n lines, each line included m character.<br>‘Y’ express yifenfei initial position.<br>‘M’ express Merceki initial position.<br>‘&#x2F;#’ forbid road;<br>‘.’ Road.<br>‘@’ KCF<br>Output</p>
<p>For each test case output the minimum total time that both yifenfei and Merceki to arrival one of KFC.You may sure there is always have a KFC that can let them meet.<br>Sample Input</p>
<p>4 4 Y.&#x2F;#@ …. .&#x2F;#.. @..M 4 4 Y.&#x2F;#@ …. .&#x2F;#.. @&#x2F;#.M 5 5 Y..@. .&#x2F;#… .&#x2F;#… @..M. &#x2F;#…&#x2F;#<br>Sample Output</p>
<p>66 88 66</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Search</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1077 Eight(BFS Hash)</title>
    <url>/posts/oj/search/POJ%201077%20Eight(BFS%20Hash)/</url>
    <content><![CDATA[<p>题意 八数码问题</p>
<p>还是八数码问题 只是要输出路径了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int M = <span class="number">1000003</span>;</span><br><span class="line">int e[<span class="number">9</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">0</span>&#125;;</span><br><span class="line">int x[<span class="number">4</span>] = &#123; -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, y[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">int dir[M], pre[M], h[M], s[M][<span class="number">9</span>];</span><br><span class="line">char pri[<span class="number">5</span>] = <span class="string">&quot;udlr&quot;</span>;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">aton</span>(<span class="params">int a[]</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line">        t = t * <span class="number">10</span> + a[i];</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">search_hash</span>(<span class="params">int a[]</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int t = <span class="title function_">aton</span>(a), p = t % M;</span><br><span class="line">    <span class="keyword">while</span>(h[p])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(h[p] == t) <span class="keyword">return</span> p;</span><br><span class="line">        ++p;</span><br><span class="line">        <span class="keyword">if</span>(p &gt;= M) p = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span>(<span class="params">int p</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre[p])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">print</span>(pre[p]);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%c&quot;</span>, pri[dir[p]]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">bfs</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">memset</span>(h, <span class="number">0</span>, <span class="title function_">sizeof</span>(h));</span><br><span class="line">    h[<span class="title function_">aton</span>(s[<span class="number">1</span>]) % M] = <span class="title function_">aton</span>(s[<span class="number">1</span>]);</span><br><span class="line">    int fro = <span class="number">1</span>, rear = <span class="number">2</span>, r, c, k = <span class="number">0</span>, nr, nc, nk, p;</span><br><span class="line">    int t[<span class="number">9</span>], tmp, cur;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fro &lt; rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">memcpy</span>(t, s[fro], <span class="title function_">sizeof</span>(t));</span><br><span class="line">        cur = <span class="title function_">search_hash</span>(t);</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_">memcmp</span>(t, e, <span class="title function_">sizeof</span>(t)) == <span class="number">0</span>) <span class="keyword">return</span> cur;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; t[k];) ++k;</span><br><span class="line">        r = k / <span class="number">3</span>, c = k % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">memcpy</span>(t, s[fro], <span class="title function_">sizeof</span>(t));</span><br><span class="line">            nr = r + x[i], nc = c + y[i], nk = nr * <span class="number">3</span> + nc;</span><br><span class="line">            <span class="keyword">if</span>(nr &lt; <span class="number">0</span> || nr &gt; <span class="number">2</span> || nc &lt; <span class="number">0</span> || nc &gt; <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">            tmp = t[nk];</span><br><span class="line">            t[nk] = <span class="number">0</span>;</span><br><span class="line">            t[k] = tmp;</span><br><span class="line">            p = <span class="title function_">search_hash</span>(t);</span><br><span class="line">            <span class="keyword">if</span>(h[p] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                h[p] = <span class="title function_">aton</span>(t);</span><br><span class="line">                dir[p] = i;</span><br><span class="line">                pre[p] = cur;</span><br><span class="line">                <span class="title function_">memcpy</span>(s[rear], t, <span class="title function_">sizeof</span>(t));</span><br><span class="line">                ++rear;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++fro;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    char c;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[<span class="number">1</span>][<span class="number">0</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">memset</span>(dir, <span class="number">0</span>, <span class="title function_">sizeof</span>(dir));</span><br><span class="line">        <span class="title function_">memset</span>(pre, <span class="number">0</span>, <span class="title function_">sizeof</span>(pre));</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;c);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;x&#x27;</span>) s[<span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> s[<span class="number">1</span>][i] = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = <span class="title function_">bfs</span>();</span><br><span class="line">        <span class="keyword">if</span>(ans) <span class="title function_">print</span>(ans);</span><br><span class="line">        <span class="keyword">else</span>  <span class="title function_">printf</span>(<span class="string">&quot;unsolvable&quot;</span>);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 3 4 1 5 0 7 6 8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>Eight</p>
<p>Description<br>The 15-puzzle has been around for over 100 years; even if you don’t know it by that name, you’ve seen it. It is constructed with 15 sliding tiles, each with a number from 1 to 15 on it, and all packed into a 4 by 4 frame with one tile missing. Let’s call the missing tile ‘x’; the object of the puzzle is to arrange the tiles so that they are ordered as:<br>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 x<br>where the only legal operation is to exchange ‘x’ with one of the tiles with which it shares an edge. As an example, the following sequence of moves solves a slightly scrambled puzzle:<br>1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 5 6 7 8 5 6 7 8 5 6 7 8 5 6 7 8 9 x 10 12 9 10 x 12 9 10 11 12 9 10 11 12 13 14 11 15 13 14 11 15 13 14 x 15 13 14 15 x r-&gt; d-&gt; r-&gt;<br>The letters in the previous row indicate which neighbor of the ‘x’ tile is swapped with the ‘x’ tile at each step; legal values are ‘r’,’l’,’u’ and ‘d’, for right, left, up, and down, respectively.<br>Not all puzzles can be solved; in 1870, a man named Sam Loyd was famous for distributing an unsolvable version of the puzzle, and<br>frustrating many people. In fact, all you have to do to make a regular puzzle into an unsolvable one is to swap two tiles (not counting the missing ‘x’ tile, of course).<br>In this problem, you will write a program for solving the less well-known 8-puzzle, composed of tiles on a three by three<br>arrangement.</p>
<p>Input</p>
<p>You will receive a description of a configuration of the 8 puzzle. The description is just a list of the tiles in their initial positions, with the rows listed from top to bottom, and the tiles listed from left to right within a row, where the tiles are represented by numbers 1 to 8, plus ‘x’. For example, this puzzle<br>1 2 3 x 4 6 7 5 8<br>is described by this list:<br>1 2 3 x 4 6 7 5 8</p>
<p>Output</p>
<p>You will print to standard output either the word &#96;&#96;unsolvable’’, if the puzzle has no solution, or a string consisting entirely of the letters ‘r’, ‘l’, ‘u’ and ‘d’ that describes a series of moves that produce a solution. The string should include no spaces and start at the beginning of the line.</p>
<p>Sample Input</p>
<p>2 3 4 1 5 x 7 6 8</p>
<p>Sample Output</p>
<p>ullddrurdllurdruldr</p>
<p>Source</p>
<p><a href="http://poj.org/searchproblem?field=source&key=South+Central+USA+1998">South Central USA 1998</a></p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Search</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1167 (DFS·剪枝·公交时刻表)</title>
    <url>/posts/oj/search/POJ%201167%20(DFS%C2%B7%E5%89%AA%E6%9E%9D%C2%B7%E5%85%AC%E4%BA%A4%E6%97%B6%E5%88%BB%E8%A1%A8)/</url>
    <content><![CDATA[<p>题意 你记录了[0, 59]这个时间段内到达你所在站牌的所有公交的到这个站牌的时间 对于每路公交</p>
<ol>
<li><p>同一路公交的到站时间间隔是相同的</p>
</li>
<li><p>每路公交在这个时间段至少到达两次</p>
</li>
<li><p>最多有17路公交</p>
</li>
<li><p>两个不同路的公交的第一次到站时间和到站时间间隔都可能是相同滴</p>
</li>
<li><p>你在这个时间段内的记录是完整的</p>
</li>
</ol>
<p>求最少用多少路公交可以让你的记录合法</p>
<p>由于每路公交至少到站两次 那么第一次到站时间是肯定小于30的 而且到站时间间隔肯定要大于第一次到站的时间 那么可以根据你的记录生成所有可能合法的公交线路 最后dfs找出最少的公交线路 使这些线路刚好完全覆盖你的记录 注意dfs过程中的剪枝</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1505</span>;</span><br><span class="line">int cnt[N], n, m, ans;</span><br><span class="line"></span><br><span class="line">struct route <span class="comment">//定义公交线路结构体</span></span><br><span class="line">&#123;</span><br><span class="line">    int start, interval, times;</span><br><span class="line">    <span class="title function_">route</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">    <span class="title function_">route</span>(int s, int i, int t): <span class="title function_">start</span>(s), <span class="title function_">interval</span>(i), <span class="title function_">times</span>(<span class="params">t</span>) &#123;&#125;</span><br><span class="line">    bool operator&lt; (<span class="keyword">const</span> route &amp;r) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> times &gt; r.<span class="property">times</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; r[N];</span><br><span class="line"></span><br><span class="line">bool <span class="title function_">ok</span>(<span class="params">int time, int inter</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(time &lt; <span class="number">60</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!cnt[time]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        time += inter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从第k条线路开始匹配 当前已经匹配num个记录  用了sum个公交线路</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span>(<span class="params">int k, int num, int sum</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(num == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &lt; ans) ans = sum;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int i = k; i &lt; m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum + (n - num) / r[i].<span class="property">times</span> &gt;= ans) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//剪枝 r是按趟数从大到小排序的  所以最少还需要(n - num) / r[i].times个线路</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="title function_">ok</span>(r[i].<span class="property">start</span>, r[i].<span class="property">interval</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(int j = r[i].<span class="property">start</span>; j &lt; <span class="number">60</span>; j += r[i].<span class="property">interval</span>) --cnt[j];</span><br><span class="line">        <span class="title function_">dfs</span>(i, num + r[i].<span class="property">times</span>, sum + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//i之前的线路之前已经搜索过了</span></span><br><span class="line">        <span class="keyword">for</span>(int j = r[i].<span class="property">start</span>; j &lt; <span class="number">60</span>; j += r[i].<span class="property">interval</span>) ++cnt[j]; <span class="comment">//回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">memset</span>(cnt, <span class="number">0</span>, <span class="title function_">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t), ++cnt[t]; <span class="comment">//记录每个时刻出现多少公交</span></span><br><span class="line"></span><br><span class="line">        m = <span class="number">0</span>;<span class="comment">//生成以时刻i为首班  两班间隔时间为j的所有满足的公交线路</span></span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">30</span>; ++i)</span><br><span class="line">            <span class="keyword">for</span>(int j = i + <span class="number">1</span>; j &lt; <span class="number">60</span> - i; ++j)</span><br><span class="line">                <span class="keyword">if</span>(<span class="title function_">ok</span>(i, j)) r[m++] = <span class="title function_">route</span>(i, j, <span class="number">1</span> + (<span class="number">59</span> - i) / j);</span><br><span class="line"></span><br><span class="line">        <span class="title function_">sort</span>(r, r + m);</span><br><span class="line">        ans = <span class="number">17</span>;</span><br><span class="line">        <span class="title function_">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The Buses</p>
<p>Description<br>A man arrives at a bus stop at 12:00. He remains there during 12:00-12:59. The bus stop is used by a number of bus routes. The man notes the times of arriving buses. The times when buses arrive are given.</p>
<p>Find the schedule with the fewest number of bus routes that must stop at the bus stop to satisfy the input data. For each bus route, output the starting time and the interval.</p>
<p>Input</p>
<p>Your program is to read from standard input. The input contains a number n (n &lt;&#x3D; 300) telling how many arriving buses have been noted, followed by the arrival times in ascending order.</p>
<p>Output</p>
<p>Your program is to write to standard output. The output contains one integer, which is the fewest number of bus routes.</p>
<p>Sample Input</p>
<p>17 0 3 5 13 13 15 21 26 27 29 37 39 39 45 51 52 53</p>
<p>Sample Output</p>
<p>3</p>
<p>Source</p>
<p><a href="http://poj.org/searchproblem?field=source&key=IOI+1994">IOI 1994</a></p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Search</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1321 棋盘问题(DFS)</title>
    <url>/posts/oj/search/POJ%201321%20%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98(DFS)/</url>
    <content><![CDATA[<p>题意 中文</p>
<p>简单的搜索题 标记列是否已经有子进行深搜即可 k可能小于n 所以每行都有放子或不放子两种选择</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">10</span>;</span><br><span class="line">int n, k, ans, v[N];</span><br><span class="line">char g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span>(<span class="params">int r, int cnt</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt;= k) ++ans;</span><br><span class="line">    <span class="keyword">if</span>(r &gt;= n || cnt &gt;= k) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(int c = <span class="number">0</span>; c &lt; n; ++c)   <span class="comment">//第r行c列放一个子</span></span><br><span class="line">        <span class="keyword">if</span>((!v[c]) &amp;&amp; g[r][c] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">            v[c] = <span class="number">1</span>, <span class="title function_">dfs</span>(r + <span class="number">1</span>, cnt + <span class="number">1</span>), v[c] = <span class="number">0</span>;</span><br><span class="line">    <span class="title function_">dfs</span>(r + <span class="number">1</span>, cnt);   <span class="comment">//第r行不放子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k), n + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, g[i]);</span><br><span class="line">        <span class="title function_">dfs</span>(ans = <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>棋盘问题</p>
<p>Description<br>在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。</p>
<p>Input</p>
<p>输入含有多组测试数据。<br>每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n&#x2F;*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;&#x3D; 8 , k &lt;&#x3D; n<br>当为-1 -1时表示输入结束。<br>随后的n行描述了棋盘的形状：每行有n个字符，其中 &#x2F;# 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。</p>
<p>Output</p>
<p>对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。</p>
<p>Sample Input</p>
<p>2 1 &#x2F;#. .&#x2F;# 4 4 …&#x2F;# ..&#x2F;#. .&#x2F;#.. &#x2F;#… -1 -1</p>
<p>Sample Output</p>
<p>2 1</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Search</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1426 Find The Multiple(BFS 同余模定理)</title>
    <url>/posts/oj/search/POJ%201426%20Find%20The%20Multiple(BFS%20%E5%90%8C%E4%BD%99%E6%A8%A1%E5%AE%9A%E7%90%86)/</url>
    <content><![CDATA[<p>题意 给你一个数n 输出一个仅由0，1组成的数m使得m是n的倍数</p>
<p>找到一个m 是m%n&#x3D;&#x3D;0 就行了 初始让m&#x3D;1 然后bfs扩展m的位数 只有两种情况m &#x3D; m &#x2F;* 10 或 m &#x3D; m&#x2F;*10 + 1;</p>
<p>同余模定理**(a+b) % c &#x3D; (a%c + b%c) % c, (a&#x2F;<em>b)%c &#x3D; (a%c &#x2F;</em> b%c) % c;**</p>
<p>运用同余模定理 可以只记录余数 这样就可以避免处理大数了 因为余数不会超过n 而n是小于两百的</p>
<p>对于已经得到过的余数 是可以跳过的 可以考虑下为什么</p>
<p>于是只用保存每一位选的是0还是1 只要保证最后余数为0就行了</p>
<p>*<em>1. 选0 m &#x3D; m&#x2F;<em>10 % n;</em></em></p>
<p>*<em>2. 选1 m &#x3D; (m&#x2F;<em>10 + 1) % n;</em></em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">205</span>;</span><br><span class="line">int q[N], p[N], d[N], n;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">bfs</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int le = <span class="number">0</span>, ri = <span class="number">0</span>, r = <span class="number">1</span>, cr;</span><br><span class="line">    int v[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    v[q[ri++] = r % n] = d[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    p[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(le &lt; ri)</span><br><span class="line">    &#123;</span><br><span class="line">        cr = q[le];</span><br><span class="line">        <span class="keyword">if</span>(cr == <span class="number">0</span>)  <span class="keyword">return</span> le;</span><br><span class="line">        <span class="keyword">if</span>(!v[r = cr * <span class="number">10</span> % n])</span><br><span class="line">            v[r] = <span class="number">1</span>, p[ri] = le, d[ri] = <span class="number">0</span>, q[ri++] = r;</span><br><span class="line">        <span class="keyword">if</span>(!v[r = (cr * <span class="number">10</span> + <span class="number">1</span>) % n])</span><br><span class="line">            v[r] = <span class="number">1</span>, p[ri] = le, d[ri] = <span class="number">1</span>, q[ri++] = r;</span><br><span class="line">        ++le;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span>(<span class="params">int k</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[k] &gt;= <span class="number">0</span>) <span class="title function_">print</span>(p[k]);</span><br><span class="line">    <span class="title function_">printf</span>(<span class="string">&quot;%d&quot;</span>, d[k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">print</span>(<span class="title function_">bfs</span>());</span><br><span class="line">        <span class="title function_">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Find The Multiple</p>
<p>Description<br>Given a positive integer n, write a program to find out a nonzero multiple m of n whose decimal representation contains only the digits 0 and 1. You may assume that n is not greater than 200 and there is a corresponding m containing no more than 100 decimal digits.</p>
<p>Input</p>
<p>The input file may contain multiple test cases. Each line contains a value of n (1 &lt;&#x3D; n &lt;&#x3D; 200). A line containing a zero terminates the input.</p>
<p>Output</p>
<p>For each value of n in the input print a line containing the corresponding value of m. The decimal representation of m must not contain more than 100 digits. If there are multiple solutions for a given value of n, any one of them is acceptable.</p>
<p>Sample Input</p>
<p>2 6 19 0</p>
<p>Sample Output</p>
<p>10 100100100100100100 111111111111111111</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Search</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1856 Sea Battle(DFS)</title>
    <url>/posts/oj/search/POJ%201856%20Sea%20Battle(DFS)/</url>
    <content><![CDATA[<p>题意 图中每个矩形’&#x2F;#’连通块代表一艘船 若一艘船与另一艘有边相邻或有角相邻 那么认为这两艘船相撞 若图中有船相撞 输出bad 否则输出图中有多少艘船</p>
<p>可以把图的周围全包上一圈’.’ 遍历图中每个点 可知当图中存在一下四种结构中的一个时 必有船相撞 输出并退出循环 否则则dfs这个点 若图中不存在这些结构 就可以输出连通块数量即轮船数了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;span style=<span class="string">&quot;font-family:Microsoft YaHei;&quot;</span>&gt;#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N=<span class="number">1005</span>;</span><br><span class="line">char mat[N][N];bool vis[N][N];</span><br><span class="line">int x[<span class="number">4</span>]= &#123;-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,y[<span class="number">4</span>]= &#123;<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">bool <span class="title function_">isBad</span>(<span class="params">int i,int j</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(mat[i][j]==<span class="string">&#x27;.&#x27;</span>&amp;&amp;mat[i-<span class="number">1</span>][j]==<span class="string">&#x27;#&#x27;</span>&amp;&amp;mat[i][j-<span class="number">1</span>]==<span class="string">&#x27;#&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mat[i][j]==<span class="string">&#x27;.&#x27;</span>&amp;&amp;mat[i-<span class="number">1</span>][j]==<span class="string">&#x27;#&#x27;</span>&amp;&amp;mat[i][j+<span class="number">1</span>]==<span class="string">&#x27;#&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mat[i][j]==<span class="string">&#x27;.&#x27;</span>&amp;&amp;mat[i+<span class="number">1</span>][j]==<span class="string">&#x27;#&#x27;</span>&amp;&amp;mat[i][j-<span class="number">1</span>]==<span class="string">&#x27;#&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mat[i][j]==<span class="string">&#x27;.&#x27;</span>&amp;&amp;mat[i+<span class="number">1</span>][j]==<span class="string">&#x27;#&#x27;</span>&amp;&amp;mat[i][j+<span class="number">1</span>]==<span class="string">&#x27;#&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">dfs</span>(<span class="params">int i,int j</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[i][j]||mat[i][j]==<span class="string">&#x27;.&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    vis[i][j]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(int k=<span class="number">0</span>; k&lt;<span class="number">4</span>; ++k)</span><br><span class="line">        <span class="keyword">if</span>(mat[i+x[k]][j+y[k]]==<span class="string">&#x27;#&#x27;</span>) <span class="title function_">dfs</span>(i+x[k],j+y[k]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,n,m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m),n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>,mat[i]+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;=n+<span class="number">1</span>; ++i)  mat[i][<span class="number">0</span>]=mat[i][m+<span class="number">1</span>]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;=m+<span class="number">1</span>; ++j)  mat[<span class="number">0</span>][j]=mat[n+<span class="number">1</span>][j]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        int ans=<span class="number">0</span>;</span><br><span class="line">        <span class="title function_">memset</span>(vis,<span class="number">0</span>,<span class="title function_">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=m; ++j)</span><br><span class="line">                <span class="keyword">if</span>(<span class="title function_">isBad</span>(i,j)) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> ans+=<span class="title function_">dfs</span>(i,j);</span><br><span class="line">            <span class="keyword">if</span> (j&lt;=m) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i&lt;=n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;Bad placement.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;There are %d ships.\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<p>Sea Battle</p>
<p>Description<br>During the Summit, the armed forces will be highly active. The police will monitor Prague streets, the army will guard buildings, the Czech air space will be full of American F-16s. Moreover, the ships and battle cruisers will be sent to guard the banks of the Vltava river. Unfortunately, in the case of any incident, the Czech Admiralty have only a few captains able to control over the large sea battle. Therefore, it was decided to educate new admirals. As an excellent preparation, the game of “Sea Battle” was chosen to help with their study program.<br>In this well-known game, a predefined number of ships of predefined shapes are placed on the square board in such a way that they cannot contact one another even with their corners. In this task, we will consider rectangular shaped ships only. The unknown number of rectangular ships of unknown sizes are placed on a rectangular board. All the ships are full rectangles built of hash characters. Write a program that counts the total number of ships present in the field.</p>
<p>Input</p>
<p>The input consists of more scenarios. The description of each scenario begins with two integer numbers R and C separated with a single space, 1 &lt;&#x3D; R,C &lt;&#x3D; 1000. These numbers give the number of rows and columns in the game field.<br>After these two numbers, there are R lines, each of them containing C characters. Each character is either hash (“&#x2F;#”) or dot (“.”). Hashes denote ships, dots water.<br>Then, the next scenario description begins. At the end of the input, there will be a line containing two zeros instead of the field size.</p>
<p>Output</p>
<p>Output a single line for every scenario. If the ships were placed correctly (i.e., there are only rectangles that do not touch each other even with a corner), print the sentence “There are S ships.” where S is the number of ships.<br>Otherwise, print the sentence “Bad placement.”.</p>
<p>Sample Input</p>
<p>6 6 …..&#x2F;# &#x2F;#&#x2F;#…&#x2F;# &#x2F;#&#x2F;#…&#x2F;# ..&#x2F;#..&#x2F;# …..&#x2F;# &#x2F;#&#x2F;#&#x2F;#&#x2F;#&#x2F;#&#x2F;# 6 8 …..&#x2F;#.&#x2F;# &#x2F;#&#x2F;#…..&#x2F;# &#x2F;#&#x2F;#…..&#x2F;# …….&#x2F;# &#x2F;#……&#x2F;# &#x2F;#..&#x2F;#…&#x2F;# 0 0</p>
<p>Sample Output</p>
<p>Bad placement. There are 5 ships.</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Search</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3126 Prime Path(BFS 数字处理)</title>
    <url>/posts/oj/search/POJ%203126%20Prime%20Path(BFS%20%E6%95%B0%E5%AD%97%E5%A4%84%E7%90%86)/</url>
    <content><![CDATA[<p>题意 给你两个4位素数a, b 你每次可以改变a的一位数但要求改变后仍为素数 求a至少改变多少次才能变成b</p>
<p>基础的bfs 注意数的处理就行了 出队一个数 然后入队所有可以由这个素数经过一次改变而来的素数 知道得到b</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">10000</span>;</span><br><span class="line">int p[N], v[N], d[N], q[N], a, b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">initPrime</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">memset</span>(v, <span class="number">0</span> , <span class="title function_">sizeof</span>(v));</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">2</span>; i * i &lt; N; ++i)</span><br><span class="line">        <span class="keyword">if</span>(!v[i]) <span class="keyword">for</span>(int j = i; i * j &lt; N; ++j)  v[i * j] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">2</span>; i &lt; N ; ++i) p[i] = !v[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">bfs</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int c, t, le = <span class="number">0</span>, ri = <span class="number">0</span>;</span><br><span class="line">    <span class="title function_">memset</span>(v, <span class="number">0</span>, <span class="title function_">sizeof</span>(v));</span><br><span class="line">    q[ri++] = a, v[a] = <span class="number">1</span>, d[a] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(le &lt; ri)</span><br><span class="line">    &#123;</span><br><span class="line">        c = q[le++];</span><br><span class="line">        <span class="keyword">if</span>( c == b) <span class="keyword">return</span> d[c];</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; N; i *= <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j)   <span class="comment">//把c第i数量级的数改为j</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">1000</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                t = c / (i * <span class="number">10</span>) * i * <span class="number">10</span> + i * j + c % i;</span><br><span class="line">                <span class="keyword">if</span>(p[t] &amp;&amp; !v[t])</span><br><span class="line">                    v[t] = <span class="number">1</span>, d[t] = d[c] + <span class="number">1</span>, q[ri++] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="title function_">initPrime</span>();</span><br><span class="line">    <span class="keyword">while</span>(cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span>((a = <span class="title function_">bfs</span>()) != -<span class="number">1</span>) <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">        <span class="keyword">else</span> <span class="title function_">puts</span>(<span class="string">&quot;Impossible&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Prime Path</p>
<p>Description<br><img src="/../images/es-3126_1.jpg.png"> The ministers of the cabinet were quite upset by the message from the Chief of Security stating that they would all have to change the four-digit room numbers on their offices.<br>— It is a matter of security to change such things every now and then, to keep the enemy in the dark.<br>— But look, I have chosen my number 1033 for good reasons. I am the Prime minister, you know!<br>— I know, so therefore your new number 8179 is also a prime. You will just have to paste four new digits over the four old ones on your office door.<br>— No, it’s not that simple. Suppose that I change the first digit to an 8, then the number will read 8033 which is not a prime!<br>— I see, being the prime minister you cannot stand having a non-prime number on your door even for a few seconds.<br>— Correct! So I must invent a scheme for going from 1033 to 8179 by a path of prime numbers where only one digit is changed from one prime to the next prime.<br>Now, the minister of finance, who had been eavesdropping, intervened.<br>— No unnecessary expenditure, please! I happen to know that the price of a digit is one pound.<br>— Hmm, in that case I need a computer program to minimize the cost. You don’t know some very cheap software gurus, do you?<br>— In fact, I do. You see, there is this programming contest going on… Help the prime minister to find the cheapest prime path between any two given four-digit primes! The first digit must be nonzero, of course. Here is a solution in the case above.<br> 1033<br>1733<br>3733<br>3739<br>3779<br>8779<br>8179 The cost of this solution is 6 pounds. Note that the digit 1 which got pasted over in step 2 can not be reused in the last step – a new 1 must be purchased.</p>
<p>Input</p>
<p>One line with a positive number: the number of test cases (at most 100). Then for each test case, one line with two numbers separated by a blank. Both numbers are four-digit primes (without leading zeros).</p>
<p>Output</p>
<p>One line for each case, either with a number stating the minimal cost or containing the word Impossible.</p>
<p>Sample Input</p>
<p>3 1033 8179 1373 8017 1033 1033</p>
<p>Sample Output</p>
<p>6 7 0</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Search</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3279 Fliptile(状压搜索)</title>
    <url>/posts/oj/search/POJ%203279%20Fliptile(%E7%8A%B6%E5%8E%8B%E6%90%9C%E7%B4%A2)/</url>
    <content><![CDATA[<p>题意 把一个n&#x2F;*m矩阵中的1全部变成0所需的最少步数 改变某个格子时其相邻的4个格子也一起改变</p>
<p>只要知道第一行改变了哪些后面的就都确定了 因为上一行对应位置是1的位置必须改变 上一行是0的一定不能改变</p>
<p>所以可以根据第一行的状态推出后面所有行的状态 直到最后一行结束 如果最后一行不是全0的话 这种状态就是不可行的</p>
<p>那么我们只用枚举第一行的所有状态就够了 m&lt;&#x3D;16 用二进制可以比较方便的枚举 对应位是1就表示改变状态 0就不改变 最后打印改变状态次数最少的可行结果就行了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">16</span>;</span><br><span class="line">int g[N][N], t[N][N], f[N][N];</span><br><span class="line">int cnt, n, m;</span><br><span class="line">int x[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">int y[<span class="number">4</span>] = &#123; -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">flip</span>(<span class="params">int i, int j</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ++cnt, f[i][j] = <span class="number">1</span>;</span><br><span class="line">    t[i][j] = !t[i][j];</span><br><span class="line">    <span class="keyword">for</span>(int k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)</span><br><span class="line">        <span class="keyword">if</span>(i + x[k] &gt; -<span class="number">1</span> &amp;&amp; j + y[k] &gt; -<span class="number">1</span>)</span><br><span class="line">            t[i + x[k]][j + y[k]] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool <span class="title function_">ok</span>(<span class="params">int k</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="title function_">memcpy</span>(t, g, <span class="title function_">sizeof</span>(t));</span><br><span class="line">    <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">        <span class="keyword">if</span>(k &amp; (<span class="number">1</span> &lt;&lt; (m - <span class="number">1</span> - j))) <span class="title function_">flip</span>(<span class="number">0</span>, j);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">            <span class="keyword">if</span>(t[i - <span class="number">1</span>][j]) <span class="title function_">flip</span>(i, j);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">        <span class="keyword">if</span>(t[n - <span class="number">1</span>][j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int ans, p;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">                <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;g[i][j]);</span><br><span class="line">        ans = n * m + <span class="number">1</span>, p = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; m); ++i)</span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_">ok</span>(i) &amp;&amp; cnt &lt; ans) ans = cnt, p = i;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">memset</span>(f, <span class="number">0</span>, <span class="title function_">sizeof</span>(f));</span><br><span class="line">        <span class="keyword">if</span>(p &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">ok</span>(p);</span><br><span class="line">            <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">                    <span class="title function_">printf</span>(<span class="string">&quot;%d%c&quot;</span>, f[i][j], j &lt; m - <span class="number">1</span> ? <span class="string">&#x27; &#x27;</span> : <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="title function_">puts</span>(<span class="string">&quot;IMPOSSIBLE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Fliptile</p>
<p>Description<br>Farmer John knows that an intellectually satisfied cow is a happy cow who will give more milk. He has arranged a brainy activity for cows in which they manipulate an <em>M</em> × <em>N</em> grid (1 ≤ <em>M</em> ≤ 15; 1 ≤ <em>N</em> ≤ 15) of square tiles, each of which is colored black on one side and white on the other side.</p>
<p>As one would guess, when a single white tile is flipped, it changes to black; when a single black tile is flipped, it changes to white. The cows are rewarded when they flip the tiles so that each tile has the white side face up. However, the cows have rather large hooves and when they try to flip a certain tile, they also flip all the adjacent tiles (tiles that share a full edge with the flipped tile). Since the flips are tiring, the cows want to minimize the number of flips they have to make.</p>
<p>Help the cows determine the minimum number of flips required, and the locations to flip to achieve that minimum. If there are multiple ways to achieve the task with the minimum amount of flips, return the one with the least lexicographical ordering in the output when considered as a string. If the task is impossible, print one line with the word “IMPOSSIBLE”.</p>
<p>Input</p>
<p>Line 1: Two space-separated integers: <em>M</em> and <em>N</em><br>Lines 2..<em>M</em>+1: Line <em>i</em>+1 describes the colors (left to right) of row i of the grid with <em>N</em> space-separated integers which are 1 for black and 0 for white</p>
<p>Output</p>
<p>Lines 1..<em>M</em>: Each line contains <em>N</em> space-separated integers, each specifying how many times to flip that particular location.</p>
<p>Sample Input</p>
<p>4 4 1 0 0 1 0 1 1 0 0 1 1 0 1 0 0 1</p>
<p>Sample Output</p>
<p>0 0 0 0 1 0 0 1 1 0 0 1 0 0 0 0</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Search</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3411 Paid Roads(DFS)</title>
    <url>/posts/oj/search/POJ%203411%20Paid%20Roads(DFS)/</url>
    <content><![CDATA[<p>题意 你要从第1个城市到第N个城市去 有m条路 每条路用a, b, c, p, r 表示 你从第a个城市到第b个城市时 若之前经过或现在位于第c个城市 过路费就是p元 否则就是r元 求你到达第N个城市最少用多少过路费</p>
<p>由于最多只有10个城市 10条路 这个题就变得很简单了 直接暴力dfs就行 可以用状态压缩来存储已经走过了哪些城市 由于最多只有10条路 从某个城市出发要一条 回这个城市也要一条 所以一个城市最多经过5次 这个可以作为dfs的结束条件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">11</span>, <span class="variable constant_">INF</span> = <span class="number">2333333</span>;</span><br><span class="line">int n, m, ans, vis[N];</span><br><span class="line">struct road&#123;</span><br><span class="line">    int a, b, c, p, r;</span><br><span class="line">&#125; rd[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前所在城市, 到过哪些城市, 当前已经用了多少过路费</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span>(<span class="params">int p, int s, int v</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[p] &gt; <span class="number">5</span>) <span class="keyword">return</span>;</span><br><span class="line">    s = s | <span class="number">1</span> &lt;&lt; (p - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == n)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="title function_">min</span>(ans, v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(rd[i].<span class="property">a</span> != p) <span class="keyword">continue</span>;</span><br><span class="line">        ++vis[rd[i].<span class="property">b</span>];</span><br><span class="line">        <span class="keyword">if</span>(s &amp; <span class="number">1</span> &lt;&lt; (rd[i].<span class="property">c</span> - <span class="number">1</span>)) <span class="comment">//到过城市c</span></span><br><span class="line">            <span class="title function_">dfs</span>(rd[i].<span class="property">b</span>, s, v + rd[i].<span class="property">p</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="title function_">dfs</span>(rd[i].<span class="property">b</span>, s, v + rd[i].<span class="property">r</span>);</span><br><span class="line">        --vis[rd[i].<span class="property">b</span>]; <span class="comment">//回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>, &amp;rd[i].<span class="property">a</span>, &amp;rd[i].<span class="property">b</span>, &amp;rd[i].<span class="property">c</span>, &amp;rd[i].<span class="property">p</span>, &amp;rd[i].<span class="property">r</span>);</span><br><span class="line"></span><br><span class="line">        ans = <span class="variable constant_">INF</span>;</span><br><span class="line">        <span class="title function_">memset</span>(vis, <span class="number">0</span>, <span class="title function_">sizeof</span>(vis));</span><br><span class="line">        <span class="title function_">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="variable constant_">INF</span>) <span class="title function_">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> Paid Roads</p>
<p>Description</p>
<p>A network of <strong>m</strong> roads connects <strong>N</strong> cities (numbered from 1 to <strong>N</strong>). There may be more than one road connecting one city with another. Some of the roads are paid. There are two ways to pay for travel on a paid road <strong>i</strong> from city <strong>ai</strong> to city <strong>bi</strong>:</p>
<p>The payment is <strong>Pi</strong> in the first case and <strong>Ri</strong> in the second case.</p>
<p>Write a program to find a minimal-cost route from the city 1 to the city <strong>N</strong>.</p>
<p>Input</p>
<p>The first line of the input contains the values of <strong>N</strong> and <strong>m</strong>. Each of the following <strong>m</strong> lines describes one road by specifying the values of <strong>ai</strong>, <strong>bi</strong>, <strong>ci</strong>, <strong>Pi</strong>, <strong>Ri</strong> (1 ≤ <strong>i</strong>≤ <strong>m</strong>). Adjacent values on the same line are separated by one or more spaces. All values are integers, 1 ≤ <strong>m, N</strong> ≤ 10, 0 ≤ <strong>Pi</strong> , <strong>Ri</strong> ≤ 100, <strong>P</strong>i ≤ <strong>Ri</strong> (1 ≤ <strong>i</strong>≤ <strong>m</strong>).</p>
<p>Output</p>
<p>The first and only line of the file must contain the minimal possible cost of a trip from the city 1 to the city <strong>N</strong>. If the trip is not possible for any reason, the line must contain the word ‘<strong>impossible</strong>’.</p>
<p>Sample Input</p>
<p>4 5 1 2 1 10 10 2 3 1 30 50 3 4 3 80 80 2 1 2 10 10 1 3 2 10 50</p>
<p>Sample Output</p>
<p>110</p>
<p>Source</p>
<p><a href="http://poj.org/searchproblem?field=source&key=Northeastern+Europe+2002">Northeastern Europe 2002</a>, Western Subregion</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Search</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3414 Pots(BFS 倒水)</title>
    <url>/posts/oj/search/POJ%203414%20Pots(BFS%20%E5%80%92%E6%B0%B4)/</url>
    <content><![CDATA[<p>题意 你有两个容积分别为a,b杯子 你每次可以将某个杯子中的水倒满或者倒掉或者倒到另一个杯子 问能否通过这两个杯子量出c容量的水</p>
<p>和上一个倒可乐问题类似 只是这个操作更多了点 将两个杯子中各含有的水作为状态 每出队列一个状态 将所有可能到达的状态入队 直到有一个杯子里面水的体积为c 打印路径直接递归就行了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">105</span>;</span><br><span class="line">int a, b, c, t, le, ri, v[N][N];</span><br><span class="line">int x[N * N], p[N * N], op[N * N], d[N * N];</span><br><span class="line">pair&lt;int, int&gt; q[N * N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">check</span>(<span class="params">int i, int j, int o, int k</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(v[i][j]) <span class="keyword">return</span>;</span><br><span class="line">    v[i][j] = <span class="number">1</span>, p[ri] = le;</span><br><span class="line">    op[ri] = o, x[ri] = k, d[ri] = d[le] + <span class="number">1</span>;</span><br><span class="line">    q[ri++] = <span class="title function_">make_pair</span>(i, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">bfs</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int ca, cb = le = ri = <span class="number">0</span>;</span><br><span class="line">    q[ri++] = <span class="title function_">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="title function_">memset</span>(v, <span class="number">0</span>, <span class="title function_">sizeof</span>(v)), v[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(le &lt; ri)</span><br><span class="line">    &#123;</span><br><span class="line">        ca = q[le].<span class="property">first</span>, cb = q[le].<span class="property">second</span>;</span><br><span class="line">        <span class="keyword">if</span>(ca == c || cb == c) <span class="keyword">return</span> le;</span><br><span class="line">        <span class="title function_">check</span>(a, cb, <span class="number">1</span>, <span class="number">1</span>);                 <span class="comment">//FILL(1);</span></span><br><span class="line">        <span class="title function_">check</span>(ca, b, <span class="number">1</span>, <span class="number">2</span>);                 <span class="comment">//FILL(2);</span></span><br><span class="line">        <span class="title function_">check</span>(<span class="number">0</span>, cb, <span class="number">2</span>, <span class="number">1</span>);                 <span class="comment">//DROP(1);</span></span><br><span class="line">        <span class="title function_">check</span>(ca, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>);                 <span class="comment">//DROP(2);</span></span><br><span class="line">        <span class="keyword">if</span>(ca &gt; b - cb) <span class="title function_">check</span>(ca - b + cb, b, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="title function_">check</span>(<span class="number">0</span>, ca + cb, <span class="number">3</span>, <span class="number">1</span>);       <span class="comment">//POUR(1,2);</span></span><br><span class="line">        <span class="keyword">if</span>(cb &gt; a - ca) <span class="title function_">check</span>(a, cb - a + ca, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="title function_">check</span>(ca + cb, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>);       <span class="comment">//POUR(2,1);</span></span><br><span class="line">        ++le;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span>(<span class="params">int k</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[k] &gt; <span class="number">0</span>) <span class="title function_">print</span>(p[k]);</span><br><span class="line">    <span class="keyword">if</span>(op[k] == <span class="number">1</span>) <span class="title function_">printf</span>(<span class="string">&quot;FILL(%d)\n&quot;</span>, x[k]);</span><br><span class="line">    <span class="keyword">if</span>(op[k] == <span class="number">2</span>) <span class="title function_">printf</span>(<span class="string">&quot;DROP(%d)\n&quot;</span>, x[k]);</span><br><span class="line">    <span class="keyword">if</span>(op[k] == <span class="number">3</span>) <span class="title function_">printf</span>(<span class="string">&quot;POUR(%d,%d)\n&quot;</span>, x[k], <span class="number">3</span> - x[k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int ans;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ans = <span class="title function_">bfs</span>())</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>,d[ans]), <span class="title function_">print</span>(ans);</span><br><span class="line">        <span class="keyword">else</span> <span class="title function_">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Pots</p>
<p>Description<br>You are given two pots, having the volume of <strong>A</strong> and <strong>B</strong> liters respectively. The following operations can be performed:</p>
<p>Write a program to find the shortest possible sequence of these operations that will yield exactly <strong>C</strong> liters of water in one of the pots.</p>
<p>Input</p>
<p>On the first and only line are the numbers <strong>A</strong>, <strong>B</strong>, and <strong>C</strong>. These are all integers in the range from 1 to 100 and <strong>C</strong>≤max(<strong>A</strong>,<strong>B</strong>).</p>
<p>Output</p>
<p>The first line of the output must contain the length of the sequence of operations <strong>K</strong>. The following <strong>K</strong> lines must each describe one operation. If there are several sequences of minimal length, output any one of them. If the desired result can’t be achieved, the first and only line of the file must contain the word ‘<strong>impossible</strong>’.</p>
<p>Sample Input</p>
<p>3 5 4</p>
<p>Sample Output</p>
<p>6 FILL(2) POUR(2,1) DROP(1) POUR(2,1) FILL(2) POUR(2,1)</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Search</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3895 Cycles of Lanes(DFS)</title>
    <url>/posts/oj/search/POJ%203895%20Cycles%20of%20Lanes(DFS)/</url>
    <content><![CDATA[<p>Cycles of Lanes</p>
<p><strong>Time Limit:</strong> 1000MS  <strong>Memory Limit:</strong> 65536K <strong>Total Submissions:</strong> 1062  <strong>Accepted:</strong> 392</p>
<p>Description<br>Each of the M lanes of the Park of Polytechnic University of Bucharest connects two of the N crossroads of the park (labeled from 1 to N). There is no pair of crossroads connected by more than one lane and it is possible to pass from each crossroad to each other crossroad by a path composed of one or more lanes. A cycle of lanes is simple when passes through each of its crossroads exactly once.<br>The administration of the University would like to put on the lanes pictures of the winners of Regional Collegiate Programming Contest in such way that the pictures of winners from the same university to be on the lanes of a same simple cycle. That is why the administration would like to assign the longest simple cycles of lanes to most successful universities. The problem is to find the longest cycles? Fortunately, it happens that each lane of the park is participating in no more than one simple cycle (see the Figure).<br>  <img src="/../images/es-3895_1-.png"></p>
<p>Input</p>
<p>On the first line of the input file the number T of the test cases will be given. Each test case starts with a line with the positive integers N and M, separated by interval (4 &lt;&#x3D; N &lt;&#x3D; 4444). Each of the next M lines of the test case contains the labels of one of the pairs of crossroads connected by a lane.</p>
<p>Output</p>
<p>For each of the test cases, on a single line of the output, print the length of a maximal simple cycle.</p>
<p>Sample Input</p>
<p>1 7 8 3 4 1 4 1 3 7 1 2 7 7 5 5 6 6 2</p>
<p>Sample Output</p>
<p>4</p>
<p>Source</p>
<p><a href="http://poj.org/searchproblem?field=source&key=Southeastern+European+Regional+Programming+Contest+2009">Southeastern European Regional Programming Contest 2009</a></p>
<p>题意 求无向图中的最长环</p>
<p>直接dfs 依次对访问每个点编号 遇到已经访问过的点就是环了 编号相减就是环的长度</p>
<p>用数组存图会超内存 所以要用vector存</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">4500</span>;</span><br><span class="line">vector&lt;int&gt; ma[N];</span><br><span class="line">int vis[N], a, b, cas, n, m, ans;</span><br><span class="line">int dfs (int i, int no)</span><br><span class="line">&#123;</span><br><span class="line">    vis[i] = no;</span><br><span class="line">    <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; ma[i].<span class="title function_">size</span>(); ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[ma[i][j]]) dfs (ma[i][j], no + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> ans = max (ans, no - vis[ma[i][j]] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    scanf (<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span> (cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i) ma[i].<span class="title function_">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            ma[a].<span class="property">push_back</span> (b);</span><br><span class="line">            ma[b].<span class="property">push_back</span> (a);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        memset (vis, <span class="number">0</span>, sizeof (vis));</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (!vis[i]) dfs (i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ans &gt;= <span class="number">3</span>) printf (<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">        <span class="keyword">else</span> printf (<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ</category>
        <category>Search</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 11624 Fire!(BFS 逃离火灾)</title>
    <url>/posts/oj/search/UVa%2011624%20Fire!(BFS%20%E9%80%83%E7%A6%BB%E7%81%AB%E7%81%BE)/</url>
    <content><![CDATA[<p>题意 n&#x2F;*m的迷宫中有一些着火点 每个着火点上下左右相邻的非墙点下一秒也将成为一个着火点 Joe每秒能向相邻的点移动一步 给你所有着火点的位置和Joe的位置 问Joe逃离这个迷宫所需的最小时间</p>
<p>可以先一遍bfs把每个点的最早着火时间存起来 只有Joe到达该点的时间小于这个时间Joe才能走这个点 只需要对Joe所在的点为起点再来一次bfs就行了 需要注意的是开始可能有多个着火点 我开始以为只有一个着火点被坑了好久</p>
<p>v[i][j]第一遍bfs记录点i,j的最早着火时间 第二遍bfs记录Joe到达该点的时间</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1005</span>;</span><br><span class="line">int x[] = &#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">int y[] = &#123; -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">int v[N][N], n, m, ans, le, ri;</span><br><span class="line">pair&lt;int, int&gt; q[N * N];</span><br><span class="line">char g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">bfs</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cr, cc, r, c;</span><br><span class="line">    <span class="keyword">while</span>(le &lt; ri)</span><br><span class="line">    &#123;</span><br><span class="line">        cr = q[le].<span class="property">first</span>, cc = q[le++].<span class="property">second</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            r = cr + x[i], c = cc + y[i];</span><br><span class="line">            <span class="keyword">if</span>(r &lt; <span class="number">0</span> || r &gt;= n || c &lt; <span class="number">0</span> || c &gt;= m)</span><br><span class="line">                ans = ans ? ans : v[cr][cc];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(g[r][c] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; (!v[r][c] || v[cr][cc] + <span class="number">1</span> &lt; v[r][c]))</span><br><span class="line">                v[r][c] = v[cr][cc] + <span class="number">1</span>, q[ri++] = <span class="title function_">make_pair</span>(r, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas, jr, jc;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span>(cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, g[i]);</span><br><span class="line"></span><br><span class="line">        <span class="title function_">memset</span>(v, <span class="number">0</span>, <span class="title function_">sizeof</span>(v));</span><br><span class="line">        le = ri = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">                <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">                    q[ri++] = <span class="title function_">make_pair</span>(i, j), v[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;J&#x27;</span>) jr = i, jc = j;</span><br><span class="line">        <span class="title function_">bfs</span>();</span><br><span class="line">        le = ri = ans = <span class="number">0</span>, v[jr][jc] = <span class="number">1</span>;</span><br><span class="line">        q[ri++] = <span class="title function_">make_pair</span>(jr, jc);</span><br><span class="line">        <span class="title function_">bfs</span>();</span><br><span class="line">        <span class="keyword">if</span>(ans) <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">        <span class="keyword">else</span> <span class="title function_">puts</span>(<span class="string">&quot;IMPOSSIBLE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目链接 <a href="http://uva.onlinejudge.org/external/116/11624.pdf">http://uva.onlinejudge.org/external/116/11624.pdf</a></p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Search</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 140 Bandwidth(DFS 回溯 剪枝)</title>
    <url>/posts/oj/search/UVa%20140%20Bandwidth(DFS%20%E5%9B%9E%E6%BA%AF%20%E5%89%AA%E6%9E%9D)/</url>
    <content><![CDATA[<p>题意 有一个无向图 对于其所有顶点的一个排列 称一顶点与所有与其有边的其它顶点在排列中下标差的最大值为这个顶点的带宽 而所有顶点带宽的最大值为这个排列的带宽 求这个图带宽最小的排列</p>
<p>枚举排列 ans记录当前找到的最小带宽 枚举过程中一旦出现带宽大于ans的也就不用再扩展了 这样枚举完就得到了答案</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">50</span>;</span><br><span class="line">int n, ans, h[N], vis[N], a[N], d[N][N], p[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span>(<span class="params">int cur, int band</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur &gt;= n &amp;&amp; band &lt; ans)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = band;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; cur; ++i)</span><br><span class="line">            p[i] = a[i];<span class="comment">//p数组记录最优解路径</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; cur &lt; n &amp;&amp; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i] || !h[i]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        a[cur] = i , vis[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; cur; ++j)</span><br><span class="line">            <span class="keyword">if</span>(d[i][a[j]] &amp;&amp; band &lt; cur - j) band = cur - j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(band &gt; ans)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">dfs</span>(cur + <span class="number">1</span>, band);</span><br><span class="line">        vis[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    char s[N];</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, s), <span class="title function_">strcmp</span>(s, <span class="string">&quot;#&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">memset</span>(d, <span class="number">0</span>, <span class="title function_">sizeof</span>(d));</span><br><span class="line">        <span class="title function_">memset</span>(h, <span class="number">0</span>, <span class="title function_">sizeof</span>(h));</span><br><span class="line">        <span class="comment">//h数组记录字母&#x27;A&#x27;+i是否在图中出现  n为顶点个数</span></span><br><span class="line">        int i = n = <span class="number">0</span>, u, v;</span><br><span class="line">        <span class="keyword">while</span>(s[i])</span><br><span class="line">        &#123;</span><br><span class="line">            u = s[i] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!h[u]) h[u] = ++n;</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span>(s[i] &amp;&amp; s[i] != <span class="string">&#x27;;&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                v = s[i++] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(!h[v]) h[v] = ++n;</span><br><span class="line">                d[u][v] = d[v][u] =  <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s[i++]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans = N;</span><br><span class="line">        <span class="title function_">memset</span>(vis, <span class="number">0</span>, <span class="title function_">sizeof</span>(vis));</span><br><span class="line">        <span class="title function_">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;%c &quot;</span>, <span class="string">&#x27;A&#x27;</span> + p[i]);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;-&gt; %d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p>Given a graph (V,E) where V is a set of nodes and E is a set of arcs in VxV, and an <em>ordering</em> on the elements in V, then the <em>bandwidth</em> of a node <em>v</em> is defined as the maximum distance in the ordering between <em>v</em> and any node to which it is connected in the graph. The bandwidth of the ordering is then defined as the maximum of the individual bandwidths. For example, consider the following graph:</p>
<p><img src="/../images/dge.org-external-1-140img1.gif.png" alt="picture25"></p>
<p>This can be ordered in many ways, two of which are illustrated below:</p>
<p><img src="/../images/dge.org-external-1-140img2.gif.png" alt="picture47"></p>
<p>For these orderings, the bandwidths of the nodes (in order) are 6, 6, 1, 4, 1, 1, 6, 6 giving an ordering bandwidth of 6, and 5, 3, 1, 4, 3, 5, 1, 4 giving an ordering bandwidth of 5.</p>
<p>Write a program that will find the ordering of a graph that minimises the bandwidth.</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>Input will consist of a series of graphs. Each graph will appear on a line by itself. The entire file will be terminated by a line consisting of a single &#x2F;#. For each graph, the input will consist of a series of records separated by <code>;&#39;. Each record will consist of a node name (a single upper case character in the the range </code>A’ to <code>Z&#39;), followed by a </code>:’ and at least one of its neighbours. The graph will contain no more than 8 nodes.</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>Output will consist of one line for each graph, listing the ordering of the nodes followed by an arrow (-&gt;) and the bandwidth for that ordering. All items must be separated from their neighbours by exactly one space. If more than one ordering produces the same bandwidth, then choose the smallest in lexicographic ordering, that is the one that would appear first in an alphabetic listing.</p>
<h2 id="Sample-input"><a href="#Sample-input" class="headerlink" title="Sample input"></a>Sample input</h2><p>A:FB;B:GC;D:GC;F:AGH;E:HD &#x2F;#</p>
<h2 id="Sample-output"><a href="#Sample-output" class="headerlink" title="Sample output"></a>Sample output</h2><p>A B C F G D H E -&gt; 3</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Search</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 524 Prime Ring Problem（DFS , 回溯）</title>
    <url>/posts/oj/search/UVa%20524%20Prime%20Ring%20Problem%EF%BC%88DFS%20,%20%E5%9B%9E%E6%BA%AF%EF%BC%89/</url>
    <content><![CDATA[<p>题意 把1到n这n个数以1为首位围成一圈 输出所有满足任意相邻两数之和均为素数的所有排列</p>
<p>直接枚举排列看是否符合肯定会超时的 n最大为16 利用回溯法 边生成边判断 就要快很多了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">50</span>;</span><br><span class="line">int p[N], vis[N], a[N], n;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">isPrime</span>(<span class="params">int k</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">2</span>; i * i &lt;= k; ++i)</span><br><span class="line">        <span class="keyword">if</span>(k % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span>(<span class="params">int cur</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur == n &amp;&amp; p[a[n - <span class="number">1</span>] + <span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d&quot;</span>, a[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot; %d&quot;</span>, a[i]);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">2</span>; cur &lt; n &amp;&amp; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i] &amp;&amp; p[a[cur - <span class="number">1</span>] + i])</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i] = a[cur] = i;</span><br><span class="line">            <span class="title function_">dfs</span>(cur + <span class="number">1</span>);</span><br><span class="line">            vis[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas = <span class="number">0</span>;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">2</span>; i &lt; N; ++i)</span><br><span class="line">        p[i] = <span class="title function_">isPrime</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cas) <span class="title function_">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;Case %d:\n&quot;</span>, ++cas);</span><br><span class="line">        <span class="title function_">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p>A ring is composed of n (even number) circles as shown in diagram. Put natural numbers <img src="/../images/dge.org-external-5-524img1.gif.png" alt="$1, 2, \dots, n$">into each circle separately, and the sum of numbers in two adjacent circles should be a prime.</p>
<p><img src="/../images/dge.org-external-5-p524.gif.png"></p>
<p><strong>Note:</strong> the number of first circle should always be 1.</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>n (0 &lt; n &lt;&#x3D; 16)</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>The output format is shown as sample below. Each row represents a series of circle numbers in the ring beginning from 1 clockwisely and anticlockwisely. The order of numbers must satisfy the above requirements.</p>
<p>You are to write a program that completes above process.</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>6 8</p>
<h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><p>Case 1: 1 4 3 2 5 6 1 6 5 2 3 4 Case 2: 1 2 3 8 5 6 7 4 1 2 5 8 3 4 7 6 1 4 7 6 5 8 3 2 1 6 7 4 3 8 5 2</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Search</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 572 Oil Deposits(DFS)</title>
    <url>/posts/oj/search/UVa%20572%20Oil%20Deposits(DFS)/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p>The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil.</p>
<p>A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid.</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>The input file contains one or more grids. Each grid begins with a line containing m and n , the number of rows and columns in the grid, separated by a single space. If m &#x3D; 0 it signals the end of the input; otherwise  <img src="/../images/dge.org-external-5-572img1.gif.png" alt="$1 \le m \le 100$"> and  <img src="/../images/dge.org-external-5-572img2.gif.png" alt="$1 \le n \le 100$"> . Following this are m lines of n characters each (not counting the end-of-line characters). Each character corresponds to one plot, and is either <code>/* &#39;, representing the absence of oil, or</code> @ ‘, representing an oil pocket.</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>For each grid, output the number of distinct oil deposits. Two different pockets are part of the same oil deposit if they are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets.</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>1 1 &#x2F;* 3 5 &#x2F;<em>@&#x2F;</em>@&#x2F;* &#x2F;<em>&#x2F;</em>@&#x2F;<em>&#x2F;</em> &#x2F;<em>@&#x2F;</em>@&#x2F;* 1 8 @@&#x2F;<em>&#x2F;</em>&#x2F;<em>&#x2F;</em>@&#x2F;* 5 5 &#x2F;<em>&#x2F;</em>&#x2F;<em>&#x2F;</em>@ &#x2F;<em>@@&#x2F;</em>@ &#x2F;<em>@&#x2F;</em>&#x2F;<em>@ @@@&#x2F;</em>@ @@&#x2F;<em>&#x2F;</em>@ 0 0</p>
<h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><p>0 1 2 2</p>
<p>题意 计算@连通块的数量 典型的dfs应用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define r i+x[k]</span><br><span class="line">#define c j+y[k]</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">105</span>;</span><br><span class="line">char mat[N][N];</span><br><span class="line">int n, x[<span class="number">8</span>] = &#123; -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">int m, y[<span class="number">8</span>] = &#123; -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">int dfs (int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mat[i][j] == <span class="string">&#x27;*&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    mat[i][j] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (int k = <span class="number">0</span>; k &lt; <span class="number">8</span>; ++k)</span><br><span class="line">        <span class="keyword">if</span> (r &gt; <span class="number">0</span> &amp;&amp; r &lt;= n &amp;&amp; c &gt; <span class="number">0</span> &amp;&amp; c &lt;= m &amp;&amp; mat[r][c] == <span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">            dfs (r, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (scanf (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m), n)</span><br><span class="line">    &#123;</span><br><span class="line">        int ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            scanf (<span class="string">&quot;%s&quot;</span>, mat[i] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">                ans += dfs (i, j);</span><br><span class="line">        printf (<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ</category>
        <category>Search</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>ZOJ 3436 July Number(DFS)</title>
    <url>/posts/oj/search/ZOJ%203436%20July%20Number(DFS)/</url>
    <content><![CDATA[<p>题意 把一个数替换为这个数相邻数字差组成的数 知道这个数只剩一位数 若最后的一位数是7 则称原来的数为 July Number 给你一个区间 求这个区间中July Number的个数</p>
<p>从7开始DFS 位数多的数总能由位数小的数推出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1e6</span>;</span><br><span class="line">int july[N], n;</span><br><span class="line">set&lt;int&gt; ans;</span><br><span class="line"></span><br><span class="line">int pw[] = &#123;<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>, <span class="number">10000</span>, <span class="number">100000</span>, <span class="number">1000000</span>, <span class="number">10000000</span>, <span class="number">100000000</span>&#125;;</span><br><span class="line"><span class="comment">//剩余长度, 当前位要填的数，通过什么数来搜索, 路径</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span>(<span class="params">int len, int d, int bas, int cur</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(d &lt; <span class="number">0</span> || d &gt; <span class="number">9</span>) <span class="keyword">return</span>;  <span class="comment">//要填的数不合法</span></span><br><span class="line">    <span class="keyword">if</span>(!len)</span><br><span class="line">    &#123;</span><br><span class="line">        july[n++] = cur * <span class="number">10</span> + d;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    int k = pw[len - <span class="number">1</span>];</span><br><span class="line">    <span class="title function_">dfs</span>(len - <span class="number">1</span>, d - bas / k, bas % k, cur * <span class="number">10</span> + d);</span><br><span class="line">    <span class="title function_">dfs</span>(len - <span class="number">1</span>, d + bas / k, bas % k, cur * <span class="number">10</span> + d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    ans.<span class="title function_">insert</span>(<span class="number">7</span>);</span><br><span class="line">    set&lt;int&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span>(int l = <span class="number">2</span>; l &lt; <span class="number">10</span>; ++l)</span><br><span class="line">    &#123;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(it = ans.<span class="title function_">begin</span>(); it != ans.<span class="title function_">end</span>(); ++it)</span><br><span class="line">            <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">                <span class="title function_">dfs</span>(l - <span class="number">1</span>, i, *it, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i) ans.<span class="title function_">insert</span>(july[i]);</span><br><span class="line">        <span class="comment">//printf(&quot;%d\n&quot;, ans.size());</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int a, b = n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(it = ans.<span class="title function_">begin</span>(); it != ans.<span class="title function_">end</span>(); ++it) </span><br><span class="line">        july[n++] = *it;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b))</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="title function_">upper_bound</span>(july, july + n, b) - <span class="title function_">lower_bound</span>(july, july + n, a));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  July Number    Time Limit:2 Seconds Memory Limit:65536 KB</p>
<p>The digital difference of a positive number is constituted by the difference between each two neighboring digits (with the leading zeros omitted). For example the digital difference of 1135 is 022 &#x3D; 22. The repeated digital difference, or differential root, can be obtained by caculating the digital difference until a single-digit number is reached. A number whose differential root is 7 is also called July Number. Your job is to tell how many July Numbers are there lying in the given interval [<em>a</em>, <em>b</em>].</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>There are multiple cases. Each case contains two integers <em>a</em> and <em>b</em>. 1 ≤ <em>a</em> ≤ <em>b</em> ≤ 109.</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>One integer <em>k</em>, the number of July Numbers.</p>
<h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h4><p>1 10</p>
<h4 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h4><p>1<br>Author: HE, Ningxu<br>Contest: ZOJ Monthly, November 2010</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Search</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>ZOJ 3761 Easy billiards (DFS性质)</title>
    <url>/posts/oj/search/ZOJ%203761%20Easy%20billiards%20(DFS%E6%80%A7%E8%B4%A8)/</url>
    <content><![CDATA[<p>题意 桌上有n个球 a球撞击b球时 a球停在b球位置 b球保持a球运动 若b球前面再没有球 b球就会掉下桌子 给你n个球的坐标 你可以多次选择某个撞击方向前面还有球的球撞击 问最后桌上至少还剩多少球 并输出你的撞击过程</p>
<p>可以把x坐标或y坐标相同的点当作是连通的 因为可以通过撞击一个球使另一个球掉下桌面</p>
<p>那么容易发现 一个连通块内的m个球总可以经过m-1次撞击后变成只剩一个球 这个球可以是当前连通块中的任意一个 有多少个连通块最后就最少剩下多少球 然后就可以通过一次dfs解决问题 这里利用了dfs的性质 在搜索树中子节点的球总可以通过一次朝父节点撞击使自己位置没有球 撞击方向只用比较坐标就行了 然后从叶子到根输出就行了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">2005</span>;</span><br><span class="line">int x[N], y[N], vis[N];</span><br><span class="line">int dir[N], p[N], n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span>(<span class="params">int i</span>)</span><br><span class="line">&#123;</span><br><span class="line">    vis[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[j] &amp;&amp; (x[j] == x[i] || y[j] == y[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">dfs</span>(j);    <span class="comment">//j和i属于一个连通块且j还没被访问 对j深搜</span></span><br><span class="line">            <span class="keyword">if</span>(x[j] == x[i])  <span class="comment">//记录路径 上下左右分别用0，1，2，3表示</span></span><br><span class="line">                dir[j] = y[j] &lt; y[i] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dir[j] = x[j] &lt; x[i] ? <span class="number">3</span> : <span class="number">2</span>;</span><br><span class="line">            p[m++] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x[i], &amp;y[i]);</span><br><span class="line"></span><br><span class="line">        <span class="title function_">memset</span>(vis, <span class="number">0</span>, <span class="title function_">sizeof</span>(vis));</span><br><span class="line">        int cnt = m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(!vis[i]) ++cnt, <span class="title function_">dfs</span>(i);</span><br><span class="line"></span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);</span><br><span class="line">        char sdir[][<span class="number">10</span>] = &#123;<span class="string">&quot;UP&quot;</span>, <span class="string">&quot;DOWN&quot;</span>, <span class="string">&quot;LEFT&quot;</span>, <span class="string">&quot;RIGHT&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            int j = p[i];</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;(%d, %d) %s\n&quot;</span>, x[j], y[j], sdir[dir[j]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Last modified :   2015-07-10 08:26</span></span><br></pre></td></tr></table></figure>
<p>  Easy billiards    Time Limit:2 Seconds Memory Limit:65536 KB Special Judge</p>
<p>Edward think a game of billiards is too long and boring. So he invented a new game called Easy billiards.</p>
<p>Easy billiards has N balls on a brimless rectangular table in the beginning, and your goal is try to make the number of balls on the table as least as possible by several hit under the following rules:</p>
<p>1: The direction you hit the balls should parallel to the tables border.</p>
<p>2: If ball A crashed into ball B, ball B will moves in the same direction of ball A before the crashing, and ball A will stop in the place of ball B before the crashing.</p>
<p>3: If ball C is moving and there are no balls in front of ball C, it will runs out of the tables border, that means ball C is out of the table.</p>
<p>4: You can choose arbitrary ball on the table to hit, but on a hit, you can’t let the ball you choose to hit runs out of the tables border. In another word, a ball could runs out of the table if and only if it was crashed by another ball in a hitting.</p>
<p>Now, Edward wants to know the least number of balls remained on the table after several hits, and how.</p>
<p>There are multiple test cases. For each test cases, in the first line, there is an integer N, which means the number of the balls on the table. There are following N lines, each line contains two integers Xi and Yi, which means the coordinate of ball I. (0&lt;&#x3D;N&lt;&#x3D;2000, 0&lt;&#x3D;Xi, Yi&lt;&#x3D;10^8)</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>For each test cases, you should output the least number of balls on the first line. And you should output several lines to show the order of hits following the first line, each line should contains the coordinate of the ball you choose to hit and the direction you hit. (LEFT,RIGHT,UP,DOWN).</p>
<h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h4><p>4 0 0 2 0 4 0 2 2 9 1 1 2 1 3 1 1 2 2 2 3 2 1 3 2 3 3 3</p>
<h4 id="Sample-output"><a href="#Sample-output" class="headerlink" title="Sample output"></a>Sample output</h4><p>1 (2, 2) DOWN (4, 0) LEFT (2, 0) LEFT 1 (1, 3) DOWN (1, 2) DOWN (2, 3) DOWN (2, 2) DOWN (3, 3) DOWN (3, 2) DOWN (3, 1) LEFT (2, 1) LEFT</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Search</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>hiho一下·47 拓扑排序·一(判断是否能够Topo排序)</title>
    <url>/posts/oj/search/hiho%E4%B8%80%E4%B8%8B%C2%B747%20%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%C2%B7%E4%B8%80(%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E8%83%BD%E5%A4%9FTopo%E6%8E%92%E5%BA%8F)/</url>
    <content><![CDATA[<p>题意 中文</p>
<p>简单的Topo排序 用vector实现邻接表比较方便</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; e[N];</span><br><span class="line">vector&lt;int&gt;::iterator it;</span><br><span class="line">int n, m, ideg[N];</span><br><span class="line"></span><br><span class="line">bool <span class="title function_">topo</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cur;</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span>(!ideg[i]) q.<span class="title function_">push</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="title function_">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cur = q.<span class="title function_">front</span>();</span><br><span class="line">        q.<span class="title function_">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(it = e[cur].<span class="title function_">begin</span>(); it != e[cur].<span class="title function_">end</span>(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!ideg[*it]) <span class="keyword">continue</span>;</span><br><span class="line">            --ideg[*it];</span><br><span class="line">            <span class="keyword">if</span>(!ideg[*it]) q.<span class="title function_">push</span>(*it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span>(ideg[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas, a, b;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span>(cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">memset</span>(ideg, <span class="number">0</span>, <span class="title function_">sizeof</span>(ideg));</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i) e[i].<span class="title function_">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            e[a].<span class="title function_">push_back</span>(b);</span><br><span class="line">            ++ideg[b];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">puts</span>(<span class="title function_">topo</span>() ? <span class="string">&quot;Correct&quot;</span> : <span class="string">&quot;Wrong&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Last modified :   2015-05-25 09:05</span></span><br></pre></td></tr></table></figure>
<p>时间限制: 10000ms</p>
<p>单点时限: 1000ms<br>内存限制: 256MB</p>
<h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>由于今天上课的老师讲的特别无聊，小Hi和小Ho偷偷地聊了起来。</p>
<p>小Ho：小Hi，你这学期有选什么课么？</p>
<p>小Hi：挺多的，比如XXX1,XXX2还有XXX3。本来想选YYY2的，但是好像没有先选过YYY1，不能选YYY2。</p>
<p>小Ho：先修课程真是个麻烦的东西呢。</p>
<p>小Hi：没错呢。好多课程都有先修课程，每次选课之前都得先查查有没有先修。教务公布的先修课程记录都是好多年前的，不但有重复的信息，好像很多都不正确了。</p>
<p>小Ho：课程太多了，教务也没法整理吧。他们也没法一个一个确认有没有写错。</p>
<p>小Hi：这不正是轮到小Ho你出马的时候了么！</p>
<p>小Ho：哎？？</p>
<p>我们都知道大学的课程是可以自己选择的，每一个学期可以自由选择打算学习的课程。唯一限制我们选课是一些课程之间的顺序关系：有的难度很大的课程可能会有一些前置课程的要求。比如课程A是课程B的前置课程，则要求先学习完A课程，才可以选择B课程。大学的教务收集了所有课程的顺序关系，但由于系统故障，可能有一些信息出现了错误。现在小Ho把信息都告诉你，请你帮小Ho判断一下这些信息是否有误。错误的信息主要是指出现了”课程A是课程B的前置课程，同时课程B也是课程A的前置课程”这样的情况。当然”课程A是课程B的前置课程，课程B是课程C的前置课程，课程C是课程A的前置课程”这类也是错误的。</p>
<p><a href="http://hihocoder.com/contest/hiho47/problem/1#">提示：拓扑排序</a></p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>第1行：1个整数T，表示数据的组数T(1 &lt;&#x3D; T &lt;&#x3D; 5)<br>接下来T组数据按照以下格式：<br>第1行：2个整数，N,M。N表示课程总数量，课程编号为1..N。M表示顺序关系的数量。1 &lt;&#x3D; N &lt;&#x3D; 100,000. 1 &lt;&#x3D; M &lt;&#x3D; 500,000<br>第2..M+1行：每行2个整数，A,B。表示课程A是课程B的前置课程。</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>第1..T行：每行1个字符串，若该组信息无误，输出”Correct”，若该组信息有误，输出”Wrong”。<br>样例输入 2 2 2 1 2 2 1 3 2 1 2 1 3 样例输出 Wrong Correct</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>Search</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>紫书p199 八数码(BFS,hash)</title>
    <url>/posts/oj/search/%E7%B4%AB%E4%B9%A6p199%20%E5%85%AB%E6%95%B0%E7%A0%81(BFS,hash)/</url>
    <content><![CDATA[<p>八数码问题 紫书上的简单搜索 渣渣好久才弄懂</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int M = <span class="number">1000003</span>;</span><br><span class="line">int x[<span class="number">4</span>] = &#123; -<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, y[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">int dis[M], h[M], s[M][<span class="number">9</span>], e[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">int <span class="title function_">aton</span>(<span class="params">int a[]</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line">        t = t * <span class="number">10</span> + a[i];</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">search_hash</span>(<span class="params">int a[]</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int t = <span class="title function_">aton</span>(a), p = t % M;</span><br><span class="line">    <span class="keyword">while</span>(h[p])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(h[p] == t) <span class="keyword">return</span> p;</span><br><span class="line">        ++p;</span><br><span class="line">        <span class="keyword">if</span>(p &gt;= M) p = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">bfs</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">memset</span>(h, <span class="number">0</span>, <span class="title function_">sizeof</span>(h));</span><br><span class="line">    int fro = <span class="number">1</span>, rear = <span class="number">2</span>, r, c, k = <span class="number">0</span>, p;</span><br><span class="line">    int t[<span class="number">9</span>], tmp, cur, nr, nc, nk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fro &lt; rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">memcpy</span>(t, s[fro], <span class="title function_">sizeof</span>(t));</span><br><span class="line">        cur = <span class="title function_">search_hash</span>(t);</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_">memcmp</span>(t, e, <span class="title function_">sizeof</span>(t)) == <span class="number">0</span>) <span class="keyword">return</span> dis[cur];</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; t[k];) ++k;</span><br><span class="line">        r = k / <span class="number">3</span>, c = k % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">memcpy</span>(t, s[fro], <span class="title function_">sizeof</span>(t));</span><br><span class="line">            nr = r + x[i], nc = c + y[i], nk = nr * <span class="number">3</span> + nc;</span><br><span class="line">            <span class="keyword">if</span>(nr &lt; <span class="number">0</span> || nr &gt; <span class="number">2</span> || nc &lt; <span class="number">0</span> || nc &gt; <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">            tmp = t[nk];</span><br><span class="line">            t[nk] = <span class="number">0</span>;</span><br><span class="line">            t[k] = tmp;</span><br><span class="line">            p = <span class="title function_">search_hash</span>(t);</span><br><span class="line">            <span class="keyword">if</span>(h[p] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                h[p] = <span class="title function_">aton</span>(t);</span><br><span class="line">                dis[p] = dis[cur] + <span class="number">1</span>;</span><br><span class="line">                <span class="title function_">memcpy</span>(s[rear], t, <span class="title function_">sizeof</span>(t));</span><br><span class="line">                ++rear;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++fro;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[<span class="number">1</span>][<span class="number">0</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">memset</span>(dis, <span class="number">0</span>, <span class="title function_">sizeof</span>(dis));</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[<span class="number">1</span>][i]);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;e[i]);</span><br><span class="line">        h[<span class="title function_">aton</span>(s[<span class="number">1</span>]) % M] = <span class="title function_">aton</span>(s[<span class="number">1</span>]);</span><br><span class="line">        int ans = <span class="title function_">bfs</span>();</span><br><span class="line">        <span class="keyword">if</span>(ans != -<span class="number">1</span>)</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">        <span class="keyword">else</span>  <span class="title function_">printf</span>(<span class="string">&quot;No solution\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 6 4 1 3 7 0 5 8</span></span><br><span class="line"><span class="comment">8 1 5 7 3 6 4 0 2</span></span><br><span class="line"><span class="comment">2 3 4 1 5 0 7 6 8</span></span><br><span class="line"><span class="comment">1 2 3 4 5 6 7 8 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ</category>
        <category>Search</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>CF 505A Mr. Kitayuta&#39;s Gift(暴力)</title>
    <url>/posts/oj/string/CF%20505A%20Mr.%20Kitayuta&#39;s%20Gift(%E6%9A%B4%E5%8A%9B)/</url>
    <content><![CDATA[<p>题意 在一个字符串中插入一个字母使其变成一个回文串 可以的话输出这个回文串 否则NA</p>
<p>大水题 插入情况最多就26&#x2F;*11种 可以直接暴力</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">20</span>;</span><br><span class="line">char s[N], p[N];</span><br><span class="line">int l;</span><br><span class="line">bool <span class="title function_">ispal</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; (l + <span class="number">1</span>) / <span class="number">2</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span>(p[i] != p[l - i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, k;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    l = <span class="title function_">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(char c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; ++c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt;= l; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            i = j = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; k - <span class="number">1</span>) p[++j] = s[++i];</span><br><span class="line">            p[++j] = c;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; l - <span class="number">1</span>) p[++j] = s[++i];</span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_">ispal</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="title function_">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">printf</span>(<span class="string">&quot;NA\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A. Mr. Kitayuta’s Gift</p>
<p>Mr. Kitayuta has kindly given you a string <em>s</em> consisting of lowercase English letters. You are asked to insert exactly one lowercase English letter into <em>s</em> to make it a palindrome. A palindrome is a string that reads the same forward and backward. For example, “ noon “, “ testset “ and “ a “ are all palindromes, while “ test “ and “ kitayuta “ are not.</p>
<p>You can choose any lowercase English letter, and insert it to any position of <em>s</em>, possibly to the beginning or the end of <em>s</em>. You have to insert a letter even if the given string is already a palindrome.</p>
<p>If it is possible to insert one lowercase English letter into <em>s</em> so that the resulting string will be a palindrome, print the string after the insertion. Otherwise, print “NA” (without quotes, case-sensitive). In case there is more than one palindrome that can be obtained, you are allowed to print any of them.<br>Input</p>
<p>The only line of the input contains a string <em>s</em> (1 ≤ |<em>s</em>| ≤ 10). Each character in <em>s</em> is a lowercase English letter.</p>
<p>Output</p>
<p>If it is possible to turn <em>s</em> into a palindrome by inserting one lowercase English letter, print the resulting string in a single line. Otherwise, print “NA” (without quotes, case-sensitive). In case there is more than one solution, any of them will be accepted.<br>Sample test(s)</p>
<p>input revive</p>
<p>output reviver<br>input ee</p>
<p>output eye<br>input kitayuta</p>
<p>output NA</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>String</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 527B Error Correct System(字符串)</title>
    <url>/posts/oj/string/Codeforces%20527B%20Error%20Correct%20System(%E5%AD%97%E7%AC%A6%E4%B8%B2)/</url>
    <content><![CDATA[<p>题意 两个长度为n的只由小写字母组成的字符串a.b 问能否同时交换两个串两个对应位置的字符 使得两个串相同位置字符不相同的数目最小</p>
<p>因为只能交换一次 所以只可能减少0,1或2个 用p[i][j]记录a串字符i对应位置b串字符为j的位置 不存在的为0 那么有</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">200005</span>, M = <span class="number">26</span>;</span><br><span class="line">char a[N], b[N];</span><br><span class="line">int p[M][M];</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, d, u, v, flag;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">memset</span>(p, <span class="number">0</span>, <span class="title function_">sizeof</span>(p));</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, a, b);</span><br><span class="line">        <span class="keyword">for</span>(int i = d = flag = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(a[i] != b[i]) ++d, p[a[i] - <span class="string">&#x27;a&#x27;</span>][b[i] - <span class="string">&#x27;a&#x27;</span>] = i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; M; ++i)</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; M; ++j)</span><br><span class="line">                <span class="keyword">if</span>((u = p[i][j]) &amp;&amp; (v = p[j][i])) flag = <span class="number">2</span>, i = j = M;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; M; ++i) <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; M; ++j) <span class="keyword">for</span>(int k = <span class="number">0</span>; k &lt; M; ++k)</span><br><span class="line">                      <span class="keyword">if</span>((u = p[i][j]) &amp;&amp; (v = p[j][k])) flag = <span class="number">1</span>, i = j = k = M;</span><br><span class="line">        <span class="keyword">if</span>(!flag) u = v = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n%d %d\n&quot;</span>, d - flag, u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>B. Error Correct System</p>
<p>Ford Prefect got a job as a web developer for a small company that makes towels. His current work task is to create a search engine for the website of the company. During the development process, he needs to write a subroutine for comparing strings <em>S</em> and <em>T</em> of equal length to be “similar”. After a brief search on the Internet, he learned about the Hamming distance between two strings <em>S</em> and <em>T</em> of the same length, which is defined as the number of positions in which <em>S</em> and <em>T</em> have different characters. For example, the Hamming distance between words “permanent” and “pergament” is two, as these words differ in the fourth and sixth letters.</p>
<p>Moreover, as he was searching for information, he also noticed that modern search engines have powerful mechanisms to correct errors in the request to improve the quality of search. Ford doesn’t know much about human beings, so he assumed that the most common mistake in a request is swapping two arbitrary letters of the string (not necessarily adjacent). Now he wants to write a function that determines which two letters should be swapped in string <em>S</em>, so that the Hamming distance between a new string <em>S</em> and string <em>T</em> would be as small as possible, or otherwise, determine that such a replacement cannot reduce the distance between the strings.</p>
<p>Help him do this!<br>Input</p>
<p>The first line contains integer <em>n</em> (1 ≤ <em>n</em> ≤ 200 000) — the length of strings <em>S</em> and <em>T</em>.</p>
<p>The second line contains string <em>S</em>.</p>
<p>The third line contains string <em>T</em>.</p>
<p>Each of the lines only contains lowercase Latin letters.</p>
<p>Output</p>
<p>In the first line, print number <em>x</em> — the minimum possible Hamming distance between strings <em>S</em> and <em>T</em> if you swap at most one pair of letters in <em>S</em>.</p>
<p>In the second line, either print the indexes <em>i</em> and <em>j</em> (1 ≤ <em>i</em>, <em>j</em> ≤ <em>n</em>, <em>i</em> ≠ <em>j</em>), if reaching the minimum possible distance is possible by swapping letters on positions <em>i</em> and <em>j</em>, or print “-1 -1”, if it is not necessary to swap characters.</p>
<p>If there are multiple possible answers, print any of them.<br>Sample test(s)</p>
<p>input 9 pergament permanent</p>
<p>output 1 4 6<br>input 6 wookie cookie</p>
<p>output 1 -1 -1<br>input 4 petr egor</p>
<p>output 2 1 2<br>input 6 double bundle</p>
<p>output 2 4 1</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>String</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1247 Hat’s Words (Trie·指针实现)</title>
    <url>/posts/oj/string/HDU%201247%20Hat%E2%80%99s%20Words%20(Trie%C2%B7%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0)/</url>
    <content><![CDATA[<p>题意 给你一个字典 输出字典中能表示成两个单词连接的所有单词</p>
<p>最基础的字典树应用 先把所有单词加入字典树中 标记每个结点是否为某个单词的结尾 然后查找每个单词 在树上查询过程中遇到单词结尾时 如果剩下的后缀也是一个单词 那当前查询的单词就可以是两个单词的连接了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">50005</span>;</span><br><span class="line">int n;</span><br><span class="line">char ss[N][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">struct <span class="title class_">Trie</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title class_">Trie</span> *chi[<span class="number">26</span>];</span><br><span class="line">    bool isEnd;</span><br><span class="line">    <span class="title class_">Trie</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">        <span class="title function_">memset</span>(chi, <span class="variable constant_">NULL</span>, <span class="title function_">sizeof</span>(chi));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;*root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insertTrie</span>(<span class="params">Trie *r, char s[]</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int i = <span class="number">0</span>, j;</span><br><span class="line">    <span class="keyword">while</span>(s[i])</span><br><span class="line">    &#123;</span><br><span class="line">        j = s[i++] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(r-&gt;chi[j] == <span class="variable constant_">NULL</span>)</span><br><span class="line">            r-&gt;chi[j] = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">        r = r-&gt;chi[j];</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//op标记这次查询是查询后缀还是查询整个</span></span><br><span class="line">bool <span class="title function_">searchTrie</span>(<span class="params">Trie *r, char s[], int op</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int i = <span class="number">0</span>, j;</span><br><span class="line">    <span class="keyword">while</span>(s[i])</span><br><span class="line">    &#123;</span><br><span class="line">        j = s[i++] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(r-&gt;chi[j] == <span class="variable constant_">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        r = r-&gt;chi[j];</span><br><span class="line">        <span class="keyword">if</span>(!op &amp;&amp; r-&gt;isEnd &amp;&amp; s[i])<span class="comment">//前缀是一个单词</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_">searchTrie</span>(root, s + i, <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//查询后缀是否是一个单词</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> op ? r-&gt;isEnd : op;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int m = <span class="number">0</span>;</span><br><span class="line">    root = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, ss[m]))</span><br><span class="line">        <span class="title function_">insertTrie</span>(root, ss[m++]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_">searchTrie</span>(root, ss[i], <span class="number">0</span>)) <span class="title function_">puts</span>(ss[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Hat’s-Words"><a href="#Hat’s-Words" class="headerlink" title="Hat’s Words"></a>Hat’s Words</h1><p>Problem Description</p>
<p>A hat’s word is a word in the dictionary that is the concatenation of exactly two other words in the dictionary.<br>You are to find all the hat’s words in a dictionary.<br>Input</p>
<p>Standard input consists of a number of lowercase words, one per line, in alphabetical order. There will be no more than 50,000 words.<br>Only one case.<br>Output</p>
<p>Your output should contain all the hat’s words, one per line, in alphabetical order.<br>Sample Input</p>
<p>a ahat hat hatword hziee word<br>Sample Output</p>
<p>ahat hatword</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>String</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1671 Phone List (Trie·数组实现)</title>
    <url>/posts/oj/string/HDU%201671%20Phone%20List%20(Trie%C2%B7%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0)/</url>
    <content><![CDATA[<p>题意 给你一组电话号码 判断其中是否有某个电话是另一个电话的前缀</p>
<p>字典树的基础应用 可以先把所有电话存进Trie 标记每个电话的结束字符 然后再查询每个号码 看中途是否有结束标记 有的话就说明有号码是这个号码的前缀了</p>
<p>实际上 插入完成就能知道是否有号码是另一个号码的前缀了 假设A是B的前缀</p>
<p>若A在B之前插入 那么插入B的时候会遇到A的结束标记</p>
<p>弱A在B之后插入 那么A插入完成之后的结点还有非空的孩子结点</p>
<p>这样就只用在每次插入时判断就行了 可以省掉查询这一步</p>
<p>指针和动态内存分配实现字典更容易些 但在有多组样例的时侯不释放内存会导致MLE 释放内存又要多花费不必要的时间 可能导致TLE 所以用数组实现比较好</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">10005</span>;</span><br><span class="line">char tel[N][<span class="number">12</span>];</span><br><span class="line">int trie[N * <span class="number">10</span>][<span class="number">10</span>], L;</span><br><span class="line">bool end[N * <span class="number">10</span>], flag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">initTrie</span>()  <span class="comment">//清空Trie</span></span><br><span class="line">&#123;</span><br><span class="line">    L = <span class="number">1</span>;</span><br><span class="line">    <span class="title function_">memset</span>(trie, <span class="number">0</span>, <span class="title function_">sizeof</span>(trie));</span><br><span class="line">    <span class="title function_">memset</span>(end, <span class="number">0</span>, <span class="title function_">sizeof</span>(end));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insertTrie</span>(char s[])  <span class="comment">//插入</span></span><br><span class="line">&#123;</span><br><span class="line">    int r = <span class="number">0</span>, i = <span class="number">0</span>, j;</span><br><span class="line">    <span class="keyword">while</span>(s[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(end[r]) flag = <span class="literal">false</span>;  <span class="comment">//遇到其它号码的结束标记</span></span><br><span class="line">        j = s[i++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!trie[r][j])</span><br><span class="line">            trie[r][j] = L++;</span><br><span class="line">        r = trie[r][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)  <span class="comment">//插入完成的节点还有孩子节点</span></span><br><span class="line">        <span class="keyword">if</span>(trie[r][i]) flag = <span class="literal">false</span>;</span><br><span class="line">    end[r] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int T, n;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">initTrie</span>();</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, tel[i]);</span><br><span class="line">            <span class="title function_">insertTrie</span>(tel[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">puts</span>(flag ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Last modified :   2015-07-27 19:36</span></span><br></pre></td></tr></table></figure>

<h1 id="Phone-List"><a href="#Phone-List" class="headerlink" title="Phone List"></a>Phone List</h1><p>Problem Description</p>
<p>Given a list of phone numbers, determine if it is consistent in the sense that no number is the prefix of another. Let’s say the phone catalogue listed these numbers:</p>
<ol>
<li>Emergency 911</li>
<li>Alice 97 625 999</li>
<li>Bob 91 12 54 26<br>In this case, it’s not possible to call Bob, because the central would direct your call to the emergency line as soon as you had dialled the first three digits of Bob’s phone number. So this list would not be consistent.<br>Input</li>
</ol>
<p>The first line of input gives a single integer, 1 &lt;&#x3D; t &lt;&#x3D; 40, the number of test cases. Each test case starts with n, the number of phone numbers, on a separate line, 1 &lt;&#x3D; n &lt;&#x3D; 10000. Then follows n lines with one unique phone number on each line. A phone number is a sequence of at most ten digits.<br>Output</p>
<p>For each test case, output “YES” if the list is consistent, or “NO” otherwise.<br>Sample Input</p>
<p>2 3 911 97625999 91125426 5 113 12340 123440 12345 98346<br>Sample Output</p>
<p>NO YES</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>String</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 2328 Corporate Identity（Trie·最长公共子串）</title>
    <url>/posts/oj/string/HDU%202328%20Corporate%20Identity%EF%BC%88Trie%C2%B7%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%EF%BC%89/</url>
    <content><![CDATA[<p>题意 输出n个串的字典序最小的最长公共子串</p>
<p>可以枚举第一个串的所有子串 然后对每个串kmp匹配 比较复杂 而且慢 发现和HDU2846（求模式串在n个串中出现的次数）有类似之处 都可以用Trie来处理 一个串的子串肯定是其某个后缀的前缀 我们把第一个串的所有后缀都插入到Trie中 最长公共子串肯定是在这个Trie里面的 因为它肯定是第一个串的子串 在插入后面的串的后缀时 可以发现</p>
<ol>
<li><p>对于在第一个串中没有的节点是可以直接break的 在第一个串中都没有怎么会是公共的呢</p>
</li>
<li><p>当前前缀在前面i个串中出现的次数小于i 那么也可以break了 因为肯定有某些串已经不包含这个前缀了</p>
</li>
</ol>
<p>所以我们后面的插入只用基于第一次插入的Trie就行了 插入最后一个串的后缀时取插入长度最长的串就是答案了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">30005</span>;</span><br><span class="line">int trie[N][<span class="number">26</span>], cnt[N], L;</span><br><span class="line">char s[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">initTrie</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    L = <span class="number">1</span>;</span><br><span class="line">    <span class="title function_">memset</span>(cnt, <span class="number">0</span>, <span class="title function_">sizeof</span>(cnt));</span><br><span class="line">    <span class="title function_">memset</span>(trie, <span class="number">0</span>, <span class="title function_">sizeof</span>(trie));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">insertTrie</span>(<span class="params">char s[], int id</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int r = <span class="number">0</span>, i = <span class="number">0</span>, len = <span class="number">0</span>, j;</span><br><span class="line">    <span class="keyword">while</span>(s[i])</span><br><span class="line">    &#123;</span><br><span class="line">        j = s[i++] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!trie[r][j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(id == <span class="number">1</span>) trie[r][j] = L++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;  <span class="comment">//在第一个串中都没有的就不用管了</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r = trie[r][j];</span><br><span class="line">        <span class="keyword">if</span>(cnt[r] + <span class="number">1</span> &gt;= id) cnt[r] = id;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;  <span class="comment">//当前前缀出现过的次数小于id说明该前缀不是前面某些串的子串 不用再往前看</span></span><br><span class="line">        ++len;   <span class="comment">//当前前缀的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">initTrie</span>(); <span class="comment">//初始化Trie</span></span><br><span class="line">        int len = <span class="number">0</span>;</span><br><span class="line">        char ans[N] = <span class="string">&quot;IDENTITY LOST&quot;</span>, t[N];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">0</span>; s[j]; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                int k = <span class="title function_">insertTrie</span>(s + j, i);</span><br><span class="line">                <span class="keyword">if</span>(!k || i &lt; n) <span class="keyword">continue</span>; <span class="comment">//插入最后一一个串时才需要处理</span></span><br><span class="line"></span><br><span class="line">                <span class="title function_">strncpy</span>(t, s + j, k), t[k] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(k &gt; len || (k == len &amp;&amp; <span class="title function_">strcmp</span>(ans, t) &gt; <span class="number">0</span>))</span><br><span class="line">                    <span class="title function_">strcpy</span>(ans, t), len = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">puts</span>(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Last modified :  2015-10-05 15:50 CST</span></span><br></pre></td></tr></table></figure>

<h1 id="Corporate-Identity"><a href="#Corporate-Identity" class="headerlink" title="Corporate Identity"></a>Corporate Identity</h1><p>Problem Description</p>
<p>Beside other services, ACM helps companies to clearly state their “corporate identity”, which includes company logo but also other signs, like trademarks. One of such companies is Internet Building Masters (IBM), which has recently asked ACM for a help with their new identity. IBM do not want to change their existing logos and trademarks completely, because their customers are used to the old ones. Therefore, ACM will only change existing trademarks instead of creating new ones.<br>After several other proposals, it was decided to take all existing trademarks and find the longest common sequence of letters that is contained in all of them. This sequence will be graphically emphasized to form a new logo. Then, the old trademarks may still be used while showing the new identity.<br>Your task is to find such a sequence.<br>Input</p>
<p>The input contains several tasks. Each task begins with a line containing a positive integer N, the number of trademarks (2 ≤ N ≤ 4000). The number is followed by N lines, each containing one trademark. Trademarks will be composed only from lowercase letters, the length of each trademark will be at least 1 and at most 200 characters.<br>After the last trademark, the next task begins. The last task is followed by a line containing zero.<br>Output</p>
<p>For each task, output a single line containing the longest string contained as a substring in all trademarks. If there are several strings of the same length, print the one that is lexicographically smallest. If there is no such non-empty string, output the words “IDENTITY LOST” instead.<br>Sample Input</p>
<p>3 aabbaabb abbababb bbbbbabb 2 xyz abc 0<br>Sample Output</p>
<p>abb IDENTITY LOST</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>String</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 2846 Repository (Trie·统计子串)</title>
    <url>/posts/oj/string/HDU%202846%20Repository%20(Trie%C2%B7%E7%BB%9F%E8%AE%A1%E5%AD%90%E4%B8%B2)/</url>
    <content><![CDATA[<p>题意 给你p个商品名称 然后输入q个字符串查询 对每个查询输出含有查询串为子串的商品个数</p>
<p>Trie能很快的求出字典中以某个串为前缀的串的个数 但现在要查的是以某个串为子串的串的个数 可以发现</p>
<p>一个串的任何子串肯定是这个串某个后缀的前缀如”ri”是“Trie” 的子串 是后缀 “rie” 的前缀</p>
<p>那么我们在向Trie中插入时可以把这个串的所有后缀都插入 插入时要注意来自同一个串的后缀的相同前缀只能统计一次 如 “abab” 这个串 “ab” 既是后缀 “abab” 的前缀 也是后缀 “ab” 的前缀 但是只能统计一次 这用一个id数组标记就行了</p>
<p>这样最后Trie中以查询串为前缀的串的个数就是原始串中以查询串为子串的串的的个数了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line">int trie[N][<span class="number">26</span>], cnt[N], id[N], L;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insertTrie</span>(<span class="params">char s[], int iid</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int r = <span class="number">0</span>, i = <span class="number">0</span>, j;</span><br><span class="line">    <span class="keyword">while</span>(s[i])</span><br><span class="line">    &#123;</span><br><span class="line">        j = s[i++] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!trie[r][j])</span><br><span class="line">            trie[r][j] = L++;</span><br><span class="line">        r = trie[r][j];</span><br><span class="line">        <span class="keyword">if</span>(id[r] != iid) ++cnt[r];</span><br><span class="line">        id[r] = iid;<span class="comment">//标记当前前缀id 保证来自相同串的只自增一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">searchTrie</span>(<span class="params">char s[]</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int r = <span class="number">0</span>, i = <span class="number">0</span>, j;</span><br><span class="line">    <span class="keyword">while</span>(s[i])</span><br><span class="line">    &#123;</span><br><span class="line">        j = s[i++] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!trie[r][j])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        r = trie[r][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[r];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    L = <span class="number">1</span>;<span class="comment">//初始化Trie</span></span><br><span class="line">    char s[<span class="number">30</span>];</span><br><span class="line">    int p, q;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p);</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= p; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, s); <span class="comment">//插入s的所有后缀</span></span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">0</span>; s[j]; ++j)</span><br><span class="line">            <span class="title function_">insertTrie</span>(s + j, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="title function_">searchTrie</span>(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Last modified :   2015-07-28 08:33</span></span><br></pre></td></tr></table></figure>

<h1 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h1><p>Problem Description</p>
<p>When you go shopping, you can search in repository for avalible merchandises by the computers and internet. First you give the search system a name about something, then the system responds with the results. Now you are given a lot merchandise names in repository and some queries, and required to simulate the process.<br>Input</p>
<p>There is only one case. First there is an integer P (1&lt;&#x3D;P&lt;&#x3D;10000)representing the number of the merchanidse names in the repository. The next P lines each contain a string (it’s length isn’t beyond 20,and all the letters are lowercase).Then there is an integer Q(1&lt;&#x3D;Q&lt;&#x3D;100000) representing the number of the queries. The next Q lines each contains a string(the same limitation as foregoing descriptions) as the searching condition.<br>Output</p>
<p>For each query, you just output the number of the merchandises, whose names contain the search string as their substrings.<br>Sample Input</p>
<p>20 ad ae af ag ah ai aj ak al ads add ade adf adg adh adi adj adk adl aes 5 b a d ad s<br>Sample Output</p>
<p>0 20 11 11 2</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>String</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 3374 String Problem（最小表示法·KMP）</title>
    <url>/posts/oj/string/HDU%203374%20String%20Problem%EF%BC%88%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95%C2%B7KMP%EF%BC%89/</url>
    <content><![CDATA[<p>题意 给你一个环形串 输出其最小表示法的首字母位置 最大表示法的首字母位置 以及和对应位置等价位置的个数</p>
<p>最小表示法指一个循环串以某一位开始时对应的串的字典序最小 这个串就是该循环串的最小表示法</p>
<p>先看一下求字符串最小表示法的过程 可以看2003年国家集训队论文集中周源的论文</p>
<p>令 p 表示字符串 s 的最小表示法的下标, l &#x3D; strlen(s) s &#x3D; s + s</p>
<p>当<strong>i &lt;&#x3D; p &amp;&amp; j &lt;&#x3D; p &amp;&amp; i ！&#x3D; j</strong>时 令 k (0 &lt;&#x3D; k &lt; l) 为最小使得 s[i + k] !&#x3D; s[j + k] 的整数</p>
<p>k 存在时 若 s[i + k] &gt; s[j + k]</p>
<p>那么对于任意的**x (i &lt;&#x3D; x &lt;&#x3D; i + k)**都是不可能等于p的因为对于这些 x 都有对应的 y (j &lt;&#x3D; y &lt;&#x3D; j + k) 使得**s[x, i + k) &#x3D;&#x3D; s[y, j + k) &amp;&amp; s[i + k] &gt; s[j + k]**那么以 y 为起始位置的串肯定是小于以 x 为起始位置的串的 那么就可以令 i &#x3D; i + k + 1继续这个过程了 s[i + k] &lt; s[j + k] 时同理可令 j &#x3D; j + k + 1 注意若前进后i &#x3D;&#x3D; j 需要令 j &#x3D; j + 1 因为要保证i !&#x3D; j</p>
<p>重复上面的过程直到 i &gt;&#x3D; l || j &gt;&#x3D; l || k不存在 此时 i, j 中小的那个数就是答案了 因为小的那个数前后所有都已经被确定不可能为 p</p>
<p>开始时不妨令i &#x3D; 0, j &#x3D; 1 p &gt; 0 时是符合上面的条件的 p &#x3D;&#x3D; 0 时可以发现 i 会保持0不变 j 一直前进直到 j &gt; l 或 k 不存在</p>
<p>那么令 i &#x3D; 0, j &#x3D; 1 然后通过上面的过程就能得到最小表示法对应的位置了 同理也可以得到最大表示法对应的位置</p>
<p>至于求等价位置的个数 只要知道这个串是某个串循环了多少次就行了 通过kmp的l - next[l]表示最小循环节的长度就可以求出来</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">2000005</span>;</span><br><span class="line">int nex[N], l;</span><br><span class="line">char s[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">getNext</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int i = <span class="number">0</span>, j = nex[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; l)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == -<span class="number">1</span> || s[i] == s[j])</span><br><span class="line">            nex[++i] = ++j;</span><br><span class="line">        <span class="keyword">else</span> j = nex[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">getPos</span>(bool op) <span class="comment">//op = 0最小表示法  op = 1 最大表示法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">strncpy</span>(s + l, s, l);</span><br><span class="line">    int i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; l &amp;&amp; j &lt; l)</span><br><span class="line">    &#123;</span><br><span class="line">        int k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &lt; l &amp;&amp; s[i + k] == s[j + k]) ++k;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= l) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>((s[i + k] &gt; s[j + k]) ^ op) i += k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> j += k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == j) ++j;  <span class="comment">//保证i != j</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i &lt; j ? i : j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, s))</span><br><span class="line">    &#123;</span><br><span class="line">        l = <span class="title function_">strlen</span>(s);</span><br><span class="line">        <span class="title function_">getNext</span>();</span><br><span class="line">        int rl = l - nex[l], t = l % rl ? <span class="number">1</span> : l / rl;</span><br><span class="line">        int p0 = <span class="title function_">getPos</span>(<span class="number">0</span>) + <span class="number">1</span>, p1 = <span class="title function_">getPos</span>(<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, p0, t, p1, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Last modified :  2015-10-06 09:30 CST</span></span><br></pre></td></tr></table></figure>

<h1 id="String-Problem"><a href="#String-Problem" class="headerlink" title="String Problem"></a>String Problem</h1><p>Problem Description</p>
<p>Give you a string with length N, you can generate N strings by left shifts. For example let consider the string “SKYLONG”, we can generate seven strings:<br>String Rank<br>SKYLONG 1<br>KYLONGS 2<br>YLONGSK 3<br>LONGSKY 4<br>ONGSKYL 5<br>NGSKYLO 6<br>GSKYLON 7<br>and lexicographically first of them is GSKYLON, lexicographically last is YLONGSK, both of them appear only once.<br>Your task is easy, calculate the lexicographically fisrt string’s Rank (if there are multiple answers, choose the smallest one), its times, lexicographically last string’s Rank (if there are multiple answers, choose the smallest one), and its times also.<br>Input</p>
<p>Each line contains one line the string S with length N (N &lt;&#x3D; 1000000) formed by lower case letters.<br>Output</p>
<p>Output four integers separated by one space, lexicographically fisrt string’s Rank (if there are multiple answers, choose the smallest one), the string’s times in the N generated strings, lexicographically last string’s Rank (if there are multiple answers, choose the smallest one), and its times also.<br>Sample Input</p>
<p>abcder aaaaaa ababab<br>Sample Output</p>
<p>1 1 6 1 1 6 1 6 1 3 2 3<br>Author</p>
<p>WhereIsHeroFrom</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>String</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2250 Compromise (DP,最长公共子序列)</title>
    <url>/posts/oj/string/POJ%202250%20Compromise%20(DP,%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97)/</url>
    <content><![CDATA[<p>Compromise</p>
<p><strong>Time Limit:</strong> 1000MS  <strong>Memory Limit:</strong> 65536K <strong>Total Submissions:</strong> 6440  <strong>Accepted:</strong> 2882  Special Judge</p>
<p>Description<br>In a few months the European Currency Union will become a reality. However, to join the club, the Maastricht criteria must be fulfilled, and this is not a trivial task for the countries (maybe except for Luxembourg). To enforce that Germany will fulfill the criteria, our government has so many wonderful options (raise taxes, sell stocks, revalue the gold reserves,…) that it is really hard to choose what to do.<br>Therefore the German government requires a program for the following task:<br>Two politicians each enter their proposal of what to do. The computer then outputs the longest common subsequence of words that occurs in both proposals. As you can see, this is a totally fair compromise (after all, a common sequence of words is something what both people have in mind).<br>Your country needs this program, so your job is to write it for us.</p>
<p>Input</p>
<p>The input will contain several test cases.<br>Each test case consists of two texts. Each text is given as a sequence of lower-case words, separated by whitespace, but with no punctuation. Words will be less than 30 characters long. Both texts will contain less than 100 words and will be terminated by a line containing a single ‘&#x2F;#’.<br>Input is terminated by end of file.</p>
<p>Output</p>
<p>For each test case, print the longest common subsequence of words occuring in the two texts. If there is more than one such sequence, any one is acceptable. Separate the words by one blank. After the last word, output a newline character.</p>
<p>Sample Input</p>
<p>die einkommen der landwirte sind fuer die abgeordneten ein buch mit sieben siegeln um dem abzuhelfen muessen dringend alle subventionsgesetze verbessert werden &#x2F;# die steuern auf vermoegen und einkommen sollten nach meinung der abgeordneten nachdruecklich erhoben werden dazu muessen die kontrollbefugnisse der finanzbehoerden dringend verbessert werden &#x2F;#</p>
<p>Sample Output</p>
<p>die einkommen der abgeordneten muessen dringend verbessert werden</p>
<p>题意 求两端文本的最长公共子单词序列 直接lcs增量法可以得出 打印路劲也是直接递归就行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">105</span>, L = <span class="number">35</span>;</span><br><span class="line">char a[N][L], b[N][L];</span><br><span class="line">int pre[N][N], d[N][N], n, m, la, lb, flag;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lcs</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    memset (d, <span class="number">0</span>, sizeof (d)); memset (pre, <span class="number">0</span>, sizeof (pre));</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt; la; ++i)</span><br><span class="line">        <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt; lb; ++j)</span><br><span class="line">            <span class="keyword">if</span> (!strcmp (a[i], b[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                d[i][j] = d[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                pre[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (d[i - <span class="number">1</span>][j] &gt; d[i][j - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                d[i][j] = d[i - <span class="number">1</span>][j];</span><br><span class="line">                pre[i][j] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                d[i][j] = d[i][j - <span class="number">1</span>];</span><br><span class="line">                pre[i][j] = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> print (int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pre[i][j] == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print (i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (flag) flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> printf (<span class="string">&quot; &quot;</span>);</span><br><span class="line">        printf (<span class="string">&quot;%s&quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pre[i][j] == <span class="number">2</span>)</span><br><span class="line">        print (i - <span class="number">1</span>, j);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pre[i][j] == <span class="number">3</span>)</span><br><span class="line">        print (i, j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (scanf (<span class="string">&quot;%s&quot;</span>, a[<span class="number">1</span>]) != <span class="variable constant_">EOF</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        la = <span class="number">1</span>; lb = <span class="number">0</span>; flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (scanf (<span class="string">&quot;%s&quot;</span>, a[++la]), a[la][<span class="number">0</span>] != <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">        <span class="keyword">while</span> (scanf (<span class="string">&quot;%s&quot;</span>, b[++lb]), b[lb][<span class="number">0</span>] != <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">        <span class="title function_">lcs</span>();</span><br><span class="line">        print (la - <span class="number">1</span>, lb - <span class="number">1</span>);</span><br><span class="line">        printf (<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ</category>
        <category>String</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3080 Blue Jeans(KMP 最长公共子串)</title>
    <url>/posts/oj/string/POJ%203080%20Blue%20Jeans(KMP%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2)/</url>
    <content><![CDATA[<p>Blue Jeans</p>
<p>Description<br>The Genographic Project is a research partnership between IBM and The National Geographic Society that is analyzing DNA from hundreds of thousands of contributors to map how the Earth was populated.<br>As an IBM researcher, you have been tasked with writing a program that will find commonalities amongst given snippets of DNA that can be correlated with individual survey information to identify new genetic markers.<br>A DNA base sequence is noted by listing the nitrogen bases in the order in which they are found in the molecule. There are four bases: adenine (A), thymine (T), guanine (G), and cytosine (C). A 6-base DNA sequence could be represented as TAGACC.<br>Given a set of DNA base sequences, determine the longest series of bases that occurs in all of the sequences.</p>
<p>Input</p>
<p>Input to this problem will begin with a line containing a single integer n indicating the number of datasets. Each dataset consists of the following components:</p>
<p>Output</p>
<p>For each dataset in the input, output the longest base subsequence common to all of the given base sequences. If the longest common subsequence is less than three bases in length, display the string “no significant commonalities” instead. If multiple subsequences of the same longest length exist, output only the subsequence that comes first in alphabetical order.</p>
<p>Sample Input</p>
<p>3 2 GATACCAGATACCAGATACCAGATACCAGATACCAGATACCAGATACCAGATACCAGATA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 3 GATACCAGATACCAGATACCAGATACCAGATACCAGATACCAGATACCAGATACCAGATA GATACTAGATACTAGATACTAGATACTAAAGGAAAGGGAAAAGGGGAAAAAGGGGGAAAA GATACCAGATACCAGATACCAGATACCAAAGGAAAGGGAAAAGGGGAAAAAGGGGGAAAA 3 CATCATCATCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC ACATCATCATAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AACATCATCATTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT</p>
<p>Sample Output</p>
<p>no significant commonalities AGATAC CATCATCAT</p>
<p>题意 给你n个DNA串 求它们的长度最大的公共子串 如果有多个 输出字典序最小的 长度小于3的不算</p>
<p>每个DNA串的长度都是60 可以从子串长度为60依次递减 并枚举所有该长度子串 当某个长度的子串也为其它n-1个串的子串时 就是我们要的答案了</p>
<p>判断是否为其它DNA串的子串直接kmp就行了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">15</span>, M = <span class="number">65</span>, L = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">bool kmp (char s[], char p[])</span><br><span class="line">&#123;</span><br><span class="line">    int next[M];</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>, next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    int plen = strlen (p), i = <span class="number">0</span>, j,slen = strlen (s);</span><br><span class="line">    <span class="keyword">while</span> (++i &lt; plen - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        j = next[i];</span><br><span class="line">        <span class="keyword">while</span> (j != -<span class="number">1</span> &amp;&amp; p[i] != p[j])</span><br><span class="line">            j = next[j];</span><br><span class="line">        next[i + <span class="number">1</span>] = j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i = j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; slen &amp;&amp; j &lt; plen)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == -<span class="number">1</span> || s[i] == p[j]) ++i, ++j;</span><br><span class="line">        <span class="keyword">else</span> j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j == plen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas, n, flag;</span><br><span class="line">    char s[N][M], tans[M],ans[M];</span><br><span class="line">    scanf (<span class="string">&quot;%d&quot;</span>, &amp;cas);</span><br><span class="line">    <span class="keyword">while</span> (cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (int i = flag = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            scanf (<span class="string">&quot;%s&quot;</span>, s[i]);</span><br><span class="line">        <span class="keyword">for</span> (int lans = L; lans &gt; <span class="number">2</span> &amp;&amp; flag == <span class="number">0</span>; --lans)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">strcpy</span>(ans,<span class="string">&quot;ZZ&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (int i = <span class="number">0</span>, j, k; i + lans &lt;= L; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; lans; ++j)</span><br><span class="line">                    tans[j] = s[<span class="number">0</span>][i + j];</span><br><span class="line">                tans[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt; n; ++k)</span><br><span class="line">                    <span class="keyword">if</span> (!kmp (s[k], tans)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == n)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="title function_">strcmp</span>(ans,tans)&gt;<span class="number">0</span>) <span class="title function_">strcpy</span>(ans,tans);</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) printf (<span class="string">&quot;%s\n&quot;</span>, ans);</span><br><span class="line">        <span class="keyword">else</span> printf (<span class="string">&quot;no significant commonalities\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ</category>
        <category>String</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3461 Oulipo (KMP字符串匹配·统计p在s中出现次数)</title>
    <url>/posts/oj/string/POJ%203461%20Oulipo%20(KMP%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%C2%B7%E7%BB%9F%E8%AE%A1p%E5%9C%A8s%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0)/</url>
    <content><![CDATA[<p>题意 给你两个字符串p和s 求p在s中出现的次数 很裸的kmp</p>
<p>因为不止匹配一次 每次找到后还要循环j&#x3D;next[j]的过程 知道到达s的终点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">10005</span>, M = <span class="number">1000005</span>;</span><br><span class="line">int next[N], ans, n;</span><br><span class="line">char p[N], s[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> kmp ()</span><br><span class="line">&#123;</span><br><span class="line">    int lp = strlen (p), ls = strlen (s);</span><br><span class="line">    int i, j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求next数组</span></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    j = next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; lp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == -<span class="number">1</span> || p[i] == p[j])</span><br><span class="line">            next[++i] = ++j;</span><br><span class="line">        <span class="keyword">else</span> j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//kmp匹配</span></span><br><span class="line">    i = j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; ls)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == -<span class="number">1</span> || s[i] == p[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i, ++j;</span><br><span class="line">            <span class="keyword">if</span> (j == lp) ++ans, j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    scanf (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        scanf (<span class="string">&quot;%s%s&quot;</span>, p, s);</span><br><span class="line">        kmp ();</span><br><span class="line">        printf (<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Oulipo</p>
<p>Description<br>The French author Georges Perec (1936–1982) once wrote a book, La disparition, without the letter ‘e’. He was a member of the Oulipo group. A quote from the book:<br>Tout avait Pair normal, mais tout s’affirmait faux. Tout avait Fair normal, d’abord, puis surgissait l’inhumain, l’affolant. Il aurait voulu savoir où s’articulait l’association qui l’unissait au roman : stir son tapis, assaillant à tout instant son imagination, l’intuition d’un tabou, la vision d’un mal obscur, d’un quoi vacant, d’un non-dit : la vision, l’avision d’un oubli commandant tout, où s’abolissait la raison : tout avait l’air normal mais…</p>
<p>Perec would probably have scored high (or rather, low) in the following contest. People are asked to write a perhaps even meaningful text on some subject with as few occurrences of a given “word” as possible. Our task is to provide the jury with a program that counts these occurrences, in order to obtain a ranking of the competitors. These competitors often write very long texts with nonsense meaning; a sequence of 500,000 consecutive ‘T’s is not unusual. And they never use spaces.</p>
<p>So we want to quickly find out how often a word, i.e., a given string, occurs in a text. More formally: given the alphabet {‘A’, ‘B’, ‘C’, …, ‘Z’} and two finite strings over that alphabet, a word <em>W</em> and a text <em>T</em>, count the number of occurrences of <em>W</em> in <em>T</em>. All the consecutive characters of W must exactly match consecutive characters of <em>T</em>. Occurrences may overlap.</p>
<p>Input</p>
<p>The first line of the input file contains a single number: the number of test cases to follow. Each test case has the following format:</p>
<p>Output</p>
<p>For every test case in the input file, the output should contain a single number, on a single line: the number of occurrences of the word <em>W</em> in the text <em>T</em>.</p>
<p>Sample Input</p>
<p>3 BAPC BAPC AZA AZAZAZA VERDI AVERDXIVYERDIAN</p>
<p>Sample Output</p>
<p>1 3 0</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>String</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 10391 Compound Words(复合词)</title>
    <url>/posts/oj/string/UVa%2010391%20Compound%20Words(%E5%A4%8D%E5%90%88%E8%AF%8D)/</url>
    <content><![CDATA[<p>题意 输出所有输入单词中可以由另两个单词的组成的词</p>
<p>STL set的应用 枚举每个单词的所有可能拆分情况 看拆开的两个单词是否都存在 都存在的就可以输出了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string a, b;</span><br><span class="line">set&lt;string&gt; s;</span><br><span class="line">set&lt;string&gt;::iterator i;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int l;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; a) s.<span class="title function_">insert</span>(a);</span><br><span class="line">    <span class="keyword">for</span>(i = s.<span class="title function_">begin</span>(); i != s.<span class="title function_">end</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        l = i-&gt;<span class="title function_">length</span>();</span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt; l - <span class="number">1</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            a = i-&gt;<span class="title function_">substr</span>(<span class="number">0</span>, j);</span><br><span class="line">            b = i-&gt;<span class="title function_">substr</span>(j);</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="title function_">count</span>(a) &amp;&amp; s.<span class="title function_">count</span>(b))</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; (*i) &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Compound-Words"><a href="#Compound-Words" class="headerlink" title="Compound Words"></a>Compound Words</h1><p>You are to find all the two-word compound words in a dictionary. A two-word compound word is a word in the dictionary that is the concatenation of exactly two other words in the dictionary.</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>Standard input consists of a number of lowercase words, one per line, in alphabetical order. There will be no more than 120,000 words.</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>Your output should contain all the compound words, one per line, in alphabetical order.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>a alien born less lien never nevertheless new newborn the zebra</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>alien newborn</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>String</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 12504 Updating a Dictionary(更新字典)</title>
    <url>/posts/oj/string/UVa%2012504%20Updating%20a%20Dictionary(%E6%9B%B4%E6%96%B0%E5%AD%97%E5%85%B8)/</url>
    <content><![CDATA[<p>题意 比较两个字典 按字典序输出所有添加 删除 修改的项 如果没有任何更新 输出 No changes</p>
<p>STL map的应用 对比两个字典 注意开始字符串的处理和字典可以为空</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">map&lt;string, string&gt; d[<span class="number">2</span>];</span><br><span class="line">map&lt;string, string&gt;::iterator it;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">105</span>;</span><br><span class="line">string s, a, b, t[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span>(<span class="params">char c, int n</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">sort</span>(t, t + n), cout &lt;&lt; c &lt;&lt; t[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; n; ++i) cout &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; t[i];</span><br><span class="line">    <span class="title function_">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int cas, n, c1, c2, c3;</span><br><span class="line">    cin &gt;&gt; cas;</span><br><span class="line">    <span class="keyword">while</span>(cas--)</span><br><span class="line">    &#123;</span><br><span class="line">        d[<span class="number">0</span>].<span class="title function_">clear</span>(), d[<span class="number">1</span>].<span class="title function_">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; s;</span><br><span class="line">            int j = <span class="number">1</span>, l = s.<span class="title function_">size</span>();</span><br><span class="line">            <span class="keyword">while</span>(l &gt; <span class="number">2</span> &amp;&amp; j &lt; l)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(s[j] != <span class="string">&#x27;:&#x27;</span>) a += s[j++]; ++j;</span><br><span class="line">                <span class="keyword">while</span>(s[j] != <span class="string">&#x27;,&#x27;</span> &amp;&amp; s[j] != <span class="string">&#x27;&#125;&#x27;</span>) b += s[j++]; ++j;</span><br><span class="line">                d[i][a] = b, a = b = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; a &lt;&lt; &quot; : &quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        c1 = c2 = c3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(it = d[<span class="number">1</span>].<span class="title function_">begin</span>(); it != d[<span class="number">1</span>].<span class="title function_">end</span>(); ++it)</span><br><span class="line">            <span class="keyword">if</span>(!d[<span class="number">0</span>].<span class="title function_">count</span>(it-&gt;first)) t[c1++] = it-&gt;first;</span><br><span class="line">        <span class="keyword">if</span>(c1) <span class="title function_">print</span>(<span class="string">&#x27;+&#x27;</span>, c1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(it = d[<span class="number">0</span>].<span class="title function_">begin</span>(); it != d[<span class="number">0</span>].<span class="title function_">end</span>(); ++it)</span><br><span class="line">            <span class="keyword">if</span>(!d[<span class="number">1</span>].<span class="title function_">count</span>(it-&gt;first)) t[c2++] = it-&gt;first;</span><br><span class="line">        <span class="keyword">if</span>(c2) <span class="title function_">print</span>(<span class="string">&#x27;-&#x27;</span>, c2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(it = d[<span class="number">1</span>].<span class="title function_">begin</span>(); it != d[<span class="number">1</span>].<span class="title function_">end</span>(); ++it)</span><br><span class="line">            <span class="keyword">if</span>(d[<span class="number">0</span>].<span class="title function_">count</span>(it-&gt;first) &amp;&amp; d[<span class="number">0</span>][it-&gt;first] != it-&gt;second) t[c3++] = it-&gt;first;</span><br><span class="line">        <span class="keyword">if</span>(c3) <span class="title function_">print</span>(<span class="string">&#x27;*&#x27;</span>, c3);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!(c1 || c2 || c3)) <span class="title function_">puts</span>(<span class="string">&quot;No changes&quot;</span>);</span><br><span class="line">        <span class="title function_">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p>In this problem, a dictionary is collection of key-value pairs, where keys are lower-case letters, and values are non-negative integers. Given an old dictionary and a new dictionary, find out what were changed.</p>
<p>Each dictionary is formatting as follows:</p>
<p>{<em>key</em>:<em>value</em>,<em>key</em>:<em>value</em>,…,<em>key</em>:<em>value</em>}</p>
<p>Each key is a string of lower-case letters, and each value is a non-negative integer without leading zeros or prefix &#96;+’. (i.e. -4, 03 and +77 are illegal). Each key will appear at most once, but keys can appear in any order.</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>The first line contains the number of test cases <em>T</em> (  <em>T</em><img src="/../images/dge.org-external-125-12504img1-.png" alt="$ \le$">1000 ). Each test case contains two lines. The first line contains the old dictionary, and the second line contains the new dictionary. Each line will contain at most 100 characters and will not contain any whitespace characters. Both dictionaries could be empty.</p>
<p>WARNING: there are no restrictions on the lengths of each key and value in the dictionary. That means keys could be really long and values could be really large.</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>For each test case, print the changes, formatted as follows:</p>
<p>If the two dictionaries are identical, print &#96;No changes’ (without quotes) instead.</p>
<p>Print a blank line after each test case.</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>3 {a:3,b:4,c:10,f:6} {a:3,c:5,d:10,ee:4} {x:1,xyz:123456789123456789123456789} {xyz:123456789123456789123456789,x:1} {first:1,second:2,third:3} {third:3,second:2}</p>
<h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><p>+d,ee -b,f &#x2F;*c No changes -first</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>String</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 1339 Ancient Cipher</title>
    <url>/posts/oj/string/UVa%201339%20Ancient%20Cipher/</url>
    <content><![CDATA[<p>Ancient Cipher</p>
<p>Ancient Roman empire had a strong government system with various departments, including a secret service department. Important documents were sent between provinces and the capital in encrypted form to prevent eavesdropping. The most popular ciphers in those times were so calledsubstitution cipherandpermutation cipher. Substitution cipher changes all occurrences of each letter to some other letter. Substitutes for all letters must be different. For some letters substitute letter may coincide with the original letter. For example, applying substitution cipher that changes all letters from <code>A&#39; to </code>Y’ to the next ones in the alphabet, and changes <code>Z&#39; to </code>A’, to the message <code>VICTORIOUS&#39;&#39; one gets the message </code>WJDUPSJPVT’’. Permutation cipher applies some permutation to the letters of the message. For example, applying the permutation<img src="/../images/dge.org-external-13-3213img1-.png" alt="$ \langle$">2, 1, 5, 4, 3, 7, 6, 10, 9, 8<img src="/../images/dge.org-external-13-3213img2-.png" alt="$ \rangle$">to the message <code>VICTORIOUS&#39;&#39; one gets the message </code>IVOTCIRSUO’’. It was quickly noticed that being applied separately, both substitution cipher and permutation cipher were rather weak. But when being combined, they were strong enough for those times. Thus, the most important messages were first encrypted using substitution cipher, and then the result was encrypted using permutation cipher. Encrypting the message <code>VICTORIOUS&#39;&#39; with the combination of the ciphers described above one gets the message </code>JWPUDJSTVP’’. Archeologists have recently found the message engraved on a stone plate. At the first glance it seemed completely meaningless, so it was suggested that the message was encrypted with some substitution and permutation ciphers. They have conjectured the possible text of the original message that was encrypted, and now they want to check their conjecture. They need a computer program to do it, so you have to write one.</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>Input file contains several test cases. Each of them consists of two lines. The first line contains the message engraved on the plate. Before encrypting, all spaces and punctuation marks were removed, so the encrypted message contains only capital letters of the English alphabet. The second line contains the original message that is conjectured to be encrypted in the message on the first line. It also contains only capital letters of the English alphabet. The lengths of both lines of the input file are equal and do not exceed 100.</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>For each test case, print one output line. Output <code>YES &#39; if the message on the first line of the input file could be the result of encrypting the message on the second line, or</code> NO ‘ in the other case.</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>JWPUDJSTVP VICTORIOUS MAMA ROME HAHA HEHE AAA AAA NEERCISTHEBEST SECRETMESSAGES</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>YES NO YES YES NO</p>
<p>题意 给两个字符串a，b 能否把b重排后再把每个字母映射到另一个字母得到a 由于可以重排 出现的顺序就不用考虑了 只要分别把ab中每个字母出现的次数存在数组中 再对数组排序 要是得到的两个数组完全相同b就能转换为a了；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">105</span>;</span><br><span class="line">char a[N], b[N];</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (scanf (<span class="string">&quot;%s%s&quot;</span>, a, b) != <span class="variable constant_">EOF</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        int ca[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;, cb[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;, l = strlen (a), i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; l; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ++ca[a[i] - <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">            ++cb[b[i] - <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        sort (ca, ca + <span class="number">26</span>);</span><br><span class="line">        sort (cb, cb + <span class="number">26</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">            <span class="keyword">if</span> (ca[i] != cb[i]) <span class="keyword">break</span>;</span><br><span class="line">        printf (i == <span class="number">26</span> ? <span class="string">&quot;YES\n&quot;</span> : <span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ</category>
        <category>String</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 1584 Circular Sequence(环形串最小字典序)</title>
    <url>/posts/oj/string/UVa%201584%20Circular%20Sequence(%E7%8E%AF%E5%BD%A2%E4%B8%B2%E6%9C%80%E5%B0%8F%E5%AD%97%E5%85%B8%E5%BA%8F)/</url>
    <content><![CDATA[<p>题意 给你一个环形串 输出它以某一位为起点顺时针得到串的最小字典序</p>
<p>直接模拟 每次后移一位比较字典序即可 注意不能用strcpy(s+1,s)这样后移 strcpy复制地址不能有重叠部分</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;  </span><br><span class="line">#include&lt;cstring&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">150</span>;  </span><br><span class="line">char s[N], ans[N], c;  </span><br><span class="line">int t, l;  </span><br><span class="line">  </span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    scanf (<span class="string">&quot;%d&quot;</span>, &amp;t);  </span><br><span class="line">    <span class="keyword">while</span> (t--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        scanf (<span class="string">&quot;%s&quot;</span>, s);  </span><br><span class="line">        l = strlen (s);  </span><br><span class="line">        strcpy (ans, s);  </span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; l; ++i)  </span><br><span class="line">        &#123;  </span><br><span class="line">            c = s[l - <span class="number">1</span>];  </span><br><span class="line">            <span class="keyword">for</span> (int j = l - <span class="number">1</span>; j &gt;= <span class="number">1</span> ; --j)  </span><br><span class="line">                s[j] = s[j - <span class="number">1</span>];  </span><br><span class="line">            s[<span class="number">0</span>] = c;  </span><br><span class="line">            <span class="keyword">if</span> (strcmp (s, ans) &lt; <span class="number">0</span>)  </span><br><span class="line">                strcpy (ans, s);  </span><br><span class="line">        &#125;  </span><br><span class="line">        printf (<span class="string">&quot;%s\n&quot;</span>, ans);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Some DNA sequences exist in circular forms as in the following figure, which shows a circular sequence <code>CGAGTCAGCT&quot;, that is, the last symbol </code>T” in <code>CGAGTCAGCT&quot; is connected to the first symbol </code>C”. We always read a circular sequence in the clockwise direction.</p>
<p><img src="/../images/dge.org-external-15-p3225.jpg.png" alt="\epsfbox{p3225.eps}"></p>
<p>Since it is not easy to store a circular sequence in a computer as it is, we decided to store it as a linear sequence. However, there can be many linear sequences that are obtained from a circular sequence by cutting any place of the circular sequence. Hence, we also decided to store the linear sequence that is lexicographically smallest among all linear sequences that can be obtained from a circular sequence.</p>
<p>Your task is to find the lexicographically smallest sequence from a given circular sequence. For the example in the figure, the lexicographically smallest sequence is &#96;&#96;AGCTCGAGTC”. If there are two or more linear sequences that are lexicographically smallest, you are to find any one of them (in fact, they are the same).</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>The input consists of <em>T</em> test cases. The number of test cases <em>T</em> is given on the first line of the input file. Each test case takes one line containing a circular sequence that is written as an arbitrary linear sequence. Since the circular sequences are DNA sequences, only four symbols, A,C, G and T, are allowed. Each sequence has length at least 2 and at most 100.</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>Print exactly one line for each test case. The line is to contain the lexicographically smallest sequence for the test case.</p>
<p>The following shows sample input and output for two test cases.</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>2 CGAGTCAGCT CTCC</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>AGCTCGAGTC CCCT</p>
<p>﻿﻿</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>String</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 1593 Alignment of Code(字符串)</title>
    <url>/posts/oj/string/UVa%201593%20Alignment%20of%20Code(%E5%AD%97%E7%AC%A6%E4%B8%B2)/</url>
    <content><![CDATA[<p>题意 按要求对齐代码</p>
<p>字符串流的应用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1005</span>, M = <span class="number">200</span>;</span><br><span class="line">string s[N][M], line;</span><br><span class="line">int cw[M], cn[N];</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int r = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_">getline</span>(cin, line))</span><br><span class="line">    &#123;</span><br><span class="line">        stringstream <span class="title function_">ss</span>(line);</span><br><span class="line">        <span class="keyword">while</span>(ss &gt;&gt; s[r][c])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[r][c].<span class="title function_">length</span>() &gt; cw[c])</span><br><span class="line">                cw[c] = s[r][c].<span class="title function_">length</span>();</span><br><span class="line">            ++c;</span><br><span class="line">        &#125;</span><br><span class="line">        cn[r++] = c;</span><br><span class="line">        c = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; r; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; cn[i] - <span class="number">1</span>; ++j)</span><br><span class="line">            cout &lt;&lt; left &lt;&lt; <span class="title function_">setw</span>(cw[j] + <span class="number">1</span>) &lt;&lt; s[i][j];</span><br><span class="line">        cout &lt;&lt; s[i][cn[i] - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You are working in a team that writes Incredibly Customizable Programming Codewriter (ICPC) which is basically a text editor with bells and whistles. You are working on a module that takes a piece of code containing some definitions or other tabular information and aligns each column on a fixed vertical position, while keeping the resulting code as short as possible, making sure that only whitespaces that are absolutely required stay in the code. So, that the first words on each line are printed at position <em>p</em>1 &#x3D; 1; the second words on each line are printed at the minimal possible position <em>p</em>2, such that all first words end at or before position <em>p</em>2 - 2; the third words on each line are printed at the minimal possible position <em>p</em>3, such that all second words end at or before position <em>p</em>3 - 2, etc.</p>
<p>For the purpose of this problem, the code consists of multiple lines. Each line consists of one or more words separated by spaces. Each word can contain uppercase and lowercase Latin letters, all ASCII punctuation marks, separators, and other non-whitespace ASCII characters (ASCII codes 33 to 126 inclusive). Whitespace consists of space characters (ASCII code 32).</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>The input file contains one or more lines of the code up to the end of file. All lines (including the last one) are terminated by a standard end-of-line sequence in the file. Each line contains at least one word, each word is 1 to 80 characters long (inclusive). Words are separated by one or more spaces. Lines of the code can have both leading and trailing spaces. Each line in the input file is at most 180 characters long. There are at most 1000 lines in the input file.</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>Write to the output file the reformatted, aligned code that consists of the same number of lines, with the same words in the same order, without trailing and leading spaces, separated by one or more spaces such that <em>i</em>-th word on each line starts at the same position <em>p</em>i.</p>
<p>Note for the Sample:</p>
<p>The &#96;<img src="/../images/dge.org-external-15-4983img1-.png" alt="$ \sqcup$">‘ character in the example below denotes a space character in the actual files (ASCII code 32).</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>start: integer; &#x2F;&#x2F; begins here stop: integer; &#x2F;&#x2F; ends here s: string; c: char; &#x2F;&#x2F; temp</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>start: integer; &#x2F;&#x2F; begins here stop: integer; &#x2F;&#x2F; ends here s: string; c: char; &#x2F;&#x2F; temp</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>String</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 213 Message Decoding(World Finals1991，字符串)</title>
    <url>/posts/oj/string/UVa%20213%20Message%20Decoding(World%20Finals1991%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2)/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p>Some message encoding schemes require that an encoded message be sent in two parts. The first part, called the header, contains the characters of the message. The second part contains a pattern that represents the message. You must write a program that can decode messages under such a scheme.</p>
<p>The heart of the encoding scheme for your program is a sequence of &#96;&#96;key” strings of 0’s and 1’s as follows:</p>
<p><img src="/../images/dge.org-external-2-213img1.gif.png" alt="displaymath26"></p>
<p>The first key in the sequence is of length 1, the next 3 are of length 2, the next 7 of length 3, the next 15 of length 4, etc. If two adjacent keys have the same length, the second can be obtained from the first by adding 1 (base 2). Notice that there are no keys in the sequence that consist only of 1’s.</p>
<p>The keys are mapped to the characters in the header in order. That is, the first key (0) is mapped to the first character in the header, the second key (00) to the second character in the header, the <em>k</em>th key is mapped to the <em>k</em>th character in the header. For example, suppose the header is:</p>
<p>AB&#x2F;#TANCnrtXc</p>
<p>Then 0 is mapped to A, 00 to B, 01 to &#x2F;#, 10 to T, 000 to A, …, 110 to X, and 0000 to c.</p>
<p>The encoded message contains only 0’s and 1’s and possibly carriage returns, which are to be ignored. The message is divided into segments. The first 3 digits of a segment give the binary representation of the length of the keys in the segment. For example, if the first 3 digits are 010, then the remainder of the segment consists of keys of length 2 (00, 01, or 10). The end of the segment is a string of 1’s which is the same length as the length of the keys in the segment. So a segment of keys of length 2 is terminated by 11. The entire encoded message is terminated by 000 (which would signify a segment in which the keys have length 0). The message is decoded by translating the keys in the segments one-at-a-time into the header characters to which they have been mapped.</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>The input file contains several data sets. Each data set consists of a header, which is on a single line by itself, and a message, which may extend over several lines. The length of the header is limited only by the fact that key strings have a maximum length of 7 (111 in binary). If there are multiple copies of a character in a header, then several keys will map to that character. The encoded message contains only 0’s and 1’s, and it is a legitimate encoding according to the described scheme. That is, the message segments begin with the 3-digit length sequence and end with the appropriate sequence of 1’s. The keys in any given segment are all of the same length, and they all correspond to characters in the header. The message is terminated by 000.</p>
<p>Carriage returns may appear anywhere within the message part. They are <em>not</em> to be considered as part of the message.</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each data set, your program must write its decoded message on a separate line. There should not be blank lines between messages.</p>
<h2 id="Sample-input"><a href="#Sample-input" class="headerlink" title="Sample input"></a>Sample input</h2><p>TNM AEIOU 0010101100011 1010001001110110011 11000 $&#x2F;#&#x2F;*&#x2F;*\ 0100000101101100011100101000</p>
<h2 id="Sample-output"><a href="#Sample-output" class="headerlink" title="Sample output"></a>Sample output</h2><p>TAN ME &#x2F;#&#x2F;#&#x2F;*$</p>
<p>题意 编写一个解码程序 对数字串进行解码</p>
<p>输入第一行是一个解码key key从左到右每个字符分别对应0,00,01,10,000,001,011,100,101,110,0000,0001,…,1101,1110,00000,…….</p>
<p>长度为len的字符编码有2^n-1个 而且恰好以二进制方式从0到2^n-2递增 而且字符编码的最大长度为7 可以有2^7-1&#x3D;127个字符</p>
<p>我们只需开一个key[len][val]数组 里面存的是长度为len的第val+1个字符编码 然后解码时对应输出每个字符就行</p>
<p>如样例2 解码key为”S&#x2F;#&#x2F;*&#x2F;*&quot;</p>
<p>key[1][0]对应编码’0’存的字符为’$’ key[2][0]对应编码’00’存的字符为’&#x2F;#’</p>
<p>key[2][1]对应编码’01’存的字符为’&#x2F;<em>‘ key[2][2]对应编码’10’存的字符为’&#x2F;</em>‘</p>
<p>key[3][0]对应编码’000’存的字符为’&#39;</p>
<p>需要解码的文本由多个小节组成 每个小节的前三个数字代表小节中每个编码的长度（用二进制表示，例如010表示2） 然后是该长度的不定个字符编码 以全1结束 如长度为2时 ‘11’就表示结束 长度为000时表示需要编码的文本结束；</p>
<p>此题是算法竞赛入门经典第二版中的例题 第83页 里面有详细的讲解；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1000</span>;</span><br><span class="line">char s[N], key[<span class="number">8</span>][<span class="number">1</span> &lt;&lt; <span class="number">8</span>], c;</span><br><span class="line">int val, len, l;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">read</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    len = <span class="number">1</span>; l = strlen (s);</span><br><span class="line">    <span class="keyword">for</span> (int i = val = <span class="number">0</span>; i &lt; l; ++i)</span><br><span class="line">        <span class="keyword">if</span> (val &lt; ( (<span class="number">1</span> &lt;&lt; len) - <span class="number">1</span>)) </span><br><span class="line">            key[len][val++] = s[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            val = <span class="number">0</span>;</span><br><span class="line">            key[++len][val++] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> print ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = val = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> scanf (<span class="string">&quot;%c&quot;</span>, &amp;c); <span class="keyword">while</span> (!isdigit (c));</span><br><span class="line">        val = val * <span class="number">2</span> + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (val &gt;= ( (<span class="number">1</span> &lt;&lt; len) - <span class="number">1</span>))  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        printf (<span class="string">&quot;%c&quot;</span>, key[len][val]);</span><br><span class="line">        <span class="title function_">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int l1, l2, l3;</span><br><span class="line">    <span class="keyword">while</span> (gets (s) != <span class="variable constant_">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!s[<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        memset (key, <span class="number">0</span>, sizeof (key));</span><br><span class="line">        <span class="title function_">read</span>();</span><br><span class="line">        <span class="keyword">while</span> (scanf (<span class="string">&quot;%1d%1d%1d&quot;</span>, &amp;l1, &amp;l2, &amp;l3), len = <span class="number">4</span> * l1 + <span class="number">2</span> * l2 + l3)</span><br><span class="line">            print ();</span><br><span class="line">        printf (<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ</category>
        <category>String</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 340 Master-Mind Hints</title>
    <url>/posts/oj/string/UVa%20340%20Master-Mind%20Hints/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p>MasterMind is a game for two players. One of them, <em>Designer</em>, selects a secret code. The other,<em>Breaker</em>, tries to break it. A code is no more than a row of colored dots. At the beginning of a game, the players agree upon the length <em>N</em> that a code must have and upon the colors that may occur in a code.</p>
<p>In order to break the code, Breaker makes a number of guesses, each guess itself being a code. After each guess Designer gives a hint, stating to what extent the guess matches his secret code.</p>
<p>In this problem you will be given a secret code <img src="/../images/dge.org-external-3-340img1.gif.png" alt="tex2html_wrap_inline35"> and a guess <img src="/../images/dge.org-external-3-340img2.gif.png" alt="tex2html_wrap_inline37"> , and are to determine the hint. A hint consists of a pair of numbers determined as follows.</p>
<p>A <em>match</em> is a pair (<em>i</em>,<em>j</em>), <img src="/../images/dge.org-external-3-340img3.gif.png" alt="tex2html_wrap_inline41"> and <img src="/../images/dge.org-external-3-340img4.gif.png" alt="tex2html_wrap_inline43"> , such that <img src="/../images/dge.org-external-3-340img5.gif.png" alt="tex2html_wrap_inline45"> . Match (<em>i</em>,<em>j</em>) is called <em>strong</em>when <em>i</em> &#x3D; <em>j</em>, and is called <em>weak</em> otherwise. Two matches (<em>i</em>,<em>j</em>) and (<em>p</em>,<em>q</em>) are called <em>independent</em> when<em>i</em> &#x3D; <em>p</em> if and only if <em>j</em> &#x3D; <em>q</em>. A set of matches is called <em>independent</em> when all of its members are pairwise independent.</p>
<p>Designer chooses an independent set <em>M</em> of matches for which the total number of matches and the number of strong matches are both maximal. The hint then consists of the number of strong followed by the number of weak matches in <em>M</em>. Note that these numbers are uniquely determined by the secret code and the guess. If the hint turns out to be (<em>n</em>,0), then the guess is identical to the secret code.</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>The input will consist of data for a number of games. The input for each game begins with an integer specifying <em>N</em> (the length of the code). Following these will be the secret code, represented as <em>N</em> integers, which we will limit to the range 1 to 9. There will then follow an arbitrary number of guesses, each also represented as <em>N</em> integers, each in the range 1 to 9. Following the last guess in each game will be <em>N</em> zeroes; these zeroes are not to be considered as a guess.</p>
<p>Following the data for the first game will appear data for the second game (if any) beginning with a new value for <em>N</em>. The last game in the input will be followed by a single zero (when a value for<em>N</em> would normally be specified). The maximum value for <em>N</em> will be 1000.</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>The output for each game should list the hints that would be generated for each guess, in order, one hint per line. Each hint should be represented as a pair of integers enclosed in parentheses and separated by a comma. The entire list of hints for each game should be prefixed by a heading indicating the game number; games are numbered sequentially starting with 1. Look at the samples below for the <em>exact</em> format.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>4 1 3 5 5 1 1 2 3 4 3 3 5 6 5 5 1 6 1 3 5 1 3 5 5 0 0 0 0 10 1 2 2 2 4 5 6 6 6 9 1 2 3 4 5 6 7 8 9 1 1 1 2 2 3 3 4 4 5 5 1 2 1 3 1 5 1 6 1 9 1 2 2 5 5 5 6 6 6 7 0 0 0 0 0 0 0 0 0 0 0</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>Game 1: (1,1) (2,0) (1,2) (1,2) (4,0) Game 2: (2,4) (3,2) (5,0) (7,0)</p>
<p>猜数字游戏的提示 统计猜的数字有多少个数字位置正确 有多少个数字在答案中出现但是位置不正确 每个字符只能匹配一次</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1005</span>;</span><br><span class="line">int  a[N], b[N], c, d;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    int n, cas = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (scanf (<span class="string">&quot;%d&quot;</span>, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        map&lt;int, int&gt; aa;</span><br><span class="line">        printf (<span class="string">&quot;Game %d:\n&quot;</span>, ++cas);</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf (<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">            ++aa[a[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            map&lt;int, int&gt; bb;</span><br><span class="line">            <span class="keyword">for</span> (int i = c = d = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                scanf (<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">                ++bb[b[i]];</span><br><span class="line">                <span class="keyword">if</span> (a[i] == b[i]) c++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!b[<span class="number">0</span>]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++i)</span><br><span class="line">                d += min (aa[i], bb[i]);</span><br><span class="line">            printf (<span class="string">&quot;    (%d,%d)\n&quot;</span>, c, d - c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ</category>
        <category>String</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 401 Palindromes(镜像回文字符串)</title>
    <url>/posts/oj/string/UVa%20401%20Palindromes(%E9%95%9C%E5%83%8F%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2)/</url>
    <content><![CDATA[<p>﻿﻿</p>
<p>题意 给一个字符串 判定其是否为回文串和镜像串 回文串很好判断 镜像串对于每一个字符用数组保存它的镜像字符就行了 没有的就是空格</p>
<p>注意若字符串长度为奇数 中间那个字母必须是对称的才是镜像串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">35</span>;</span><br><span class="line">int l;</span><br><span class="line">char s[N], mc[] = <span class="string">&quot;A   3  HIL JM O   2TUVWXY5&quot;</span>, mn[] = <span class="string">&quot;1SE Z  8 &quot;</span>;</span><br><span class="line"></span><br><span class="line">bool <span class="title function_">isRegular</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= l / <span class="number">2</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (s[i] != s[l - i + <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool <span class="title function_">isMirrored</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= (l + <span class="number">1</span>) / <span class="number">2</span> ; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isalpha (s[i]) &amp;&amp; s[l - i + <span class="number">1</span>] != mc[s[i] - <span class="string">&#x27;A&#x27;</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isdigit (s[i]) &amp;&amp; s[l - i + <span class="number">1</span>] != mn[s[i] - <span class="string">&#x27;1&#x27;</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (scanf (<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>) != <span class="variable constant_">EOF</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        l = strlen (s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isMirrored</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">isRegular</span>()) printf (<span class="string">&quot;%s -- is a mirrored palindrome.\n\n&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> printf (<span class="string">&quot;%s -- is a mirrored string.\n\n&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isRegular</span>()) printf (<span class="string">&quot;%s -- is a regular palindrome.\n\n&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> printf (<span class="string">&quot;%s -- is not a palindrome.\n\n&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p>A regular palindrome is a string of numbers or letters that is the same forward as backward. For example, the string “ABCDEDCBA” is a palindrome because it is the same when the string is read from left to right as when the string is read from right to left.</p>
<p>A mirrored string is a string for which when each of the elements of the string is changed to its reverse (if it has a reverse) and the string is read backwards the result is the same as the original string. For example, the string “3AIAE” is a mirrored string because “A” and “I” are their own reverses, and “3” and “E” are each others’ reverses.</p>
<p>A mirrored palindrome is a string that meets the criteria of a regular palindrome and the criteria of a mirrored string. The string “ATOYOTA” is a mirrored palindrome because if the string is read backwards, the string is the same as the original and because if each of the characters is replaced by its reverse and the result is read backwards, the result is the same as the original string. Of course, “A”, “T”, “O”, and “Y” are all their own reverses.</p>
<p>A list of all valid characters and their reverses is as follows.</p>
<p>Character Reverse Character Reverse Character Reverse A A M M Y Y B  N  Z 5 C  O O 1 1 D  P  2 S E 3 Q  3 E F  R  4 G  S 2 5 Z H H T T 6 I I U U 7 J L V V 8 8 K  W W 9 L J X X</p>
<p><strong>Note</strong> that O (zero) and 0 (the letter) are considered the same character and therefore <strong>ONLY</strong> the letter “0” is a valid character.</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>Input consists of strings (one per line) each of which will consist of one to twenty valid characters. There will be no invalid characters in any of the strings. Your program should read to the end of file.</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><p>For each input string, you should print the string starting in column 1 immediately followed by exactly one of the following strings.</p>
<p>STRING CRITERIA “ – is not a palindrome.” if the string is not a palindrome and is not a mirrored string “ – is a regular palindrome.” if the string is a palindrome and is not a mirrored string “ – is a mirrored string.” if the string is not a palindrome and is a mirrored string “ – is a mirrored palindrome.” if the string is a palindrome and is a mirrored string</p>
<p><strong>Note</strong> that the output line is to include the -‘s and spacing exactly as shown in the table above and demonstrated in the Sample Output below.</p>
<p>In addition, after each output line, you must print an empty line.</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><p>NOTAPALINDROME ISAPALINILAPASI 2A3MEAS ATOYOTA</p>
<h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><p>NOTAPALINDROME – is not a palindrome. ISAPALINILAPASI – is a regular palindrome. 2A3MEAS – is a mirrored string. ATOYOTA – is a mirrored palindrome.</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>String</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 489 Hangman Judge(字符串)</title>
    <url>/posts/oj/string/UVa%20489%20Hangman%20Judge(%E5%AD%97%E7%AC%A6%E4%B8%B2)/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<p>In &#96;&#96;Hangman Judge,’’ you are to write a program that judges a series of Hangman games. For each game, the answer to the puzzle is given as well as the guesses. Rules are the same as the classic game of hangman, and are given as follows:</p>
<p>Your task as the &#96;&#96;Hangman Judge’’ is to determine, for each game, whether the contestant wins, loses, or fails to finish a game.</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>Your program will be given a series of inputs regarding the status of a game. All input will be in lower case. The first line of each section will contain a number to indicate which round of the game is being played; the next line will be the solution to the puzzle; the last line is a sequence of the guesses made by the contestant. A round number of -1 would indicate the end of all games (and input).</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>The output of your program is to indicate which round of the game the contestant is currently playing as well as the result of the game. There are three possible results:</p>
<p>You win. You lose. You chickened out.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>1 cheese chese 2 cheese abcdefg 3 cheese abcdefgij -1</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>Round 1 You win. Round 2 You chickened out. Round 3 You lose.</p>
<p>一个字符串的游戏 有一个你不知道的字符串 你开始有7条命 然后你每次猜一个字母 若你猜的字母在原字符串中 原字符串就去掉所有那个字母 否则你失去一条命 如果你在命耗完之前原字符串中所有的字母都被猜出 则你赢 如果你在命耗完了原字符串中还有字母没被猜出 则你输 如果你在命没耗完原字符串中也还有字母没被猜出 视为你放弃</p>
<p>给你另一个字符串作为你猜的顺序 判断你是否能赢：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UVa489 Hangman</span></span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1000</span>;</span><br><span class="line">char a[N], b[N];</span><br><span class="line">int cas, la, lb, i, j;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (scanf (<span class="string">&quot;%d&quot;</span>, &amp;cas), cas + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf (<span class="string">&quot;%s %s&quot;</span>, a, b);</span><br><span class="line">        la = strlen (a);</span><br><span class="line">        lb = strlen (b);</span><br><span class="line">        int ca[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;, left = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; la; ++i)</span><br><span class="line">            ++ca[a[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; lb; ++i)</span><br><span class="line">            <span class="keyword">if</span> (ca[b[i] - <span class="string">&#x27;a&#x27;</span>] != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ca[b[i] - <span class="string">&#x27;a&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)</span><br><span class="line">                    <span class="keyword">if</span> (ca[j] != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">26</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    printf (<span class="string">&quot;Round %d\nYou win.\n&quot;</span>, cas);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (--left == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                printf (<span class="string">&quot;Round %d\nYou lose.\n&quot;</span>, cas);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == lb) printf (<span class="string">&quot;Round %d\nYou chickened out.\n&quot;</span>, cas);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OJ</category>
        <category>String</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>hihoCoder 1014 Trie树(基础字典树)</title>
    <url>/posts/oj/string/hihoCoder%201014%20Trie%E6%A0%91(%E5%9F%BA%E7%A1%80%E5%AD%97%E5%85%B8%E6%A0%91)/</url>
    <content><![CDATA[<p>题意 中文</p>
<p>最基础的字典树应用噢噢噢噢</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct trie</span><br><span class="line">&#123;</span><br><span class="line">    trie *chi[<span class="number">26</span>];</span><br><span class="line">    int num;</span><br><span class="line">    <span class="title function_">trie</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">            chi[i] = <span class="variable constant_">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;*root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insertTrie</span>(<span class="params">char s[]</span>)</span><br><span class="line">&#123;</span><br><span class="line">    trie *p = root;</span><br><span class="line">    p-&gt;num++;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; s[i]; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        int j = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;chi[j] == <span class="variable constant_">NULL</span>)</span><br><span class="line">            p-&gt;chi[j] = <span class="keyword">new</span> trie;</span><br><span class="line">        p = p-&gt;chi[j];</span><br><span class="line">        p-&gt;num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">searchTrie</span>(<span class="params">char s[]</span>)</span><br><span class="line">&#123;</span><br><span class="line">    trie *p = root;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; p &amp;&amp; s[i]; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        int j = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        p = p-&gt;chi[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> p-&gt;num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    char s[<span class="number">12</span>];</span><br><span class="line">    int n, m;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        root = <span class="keyword">new</span> trie;</span><br><span class="line">        <span class="keyword">while</span>(n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">            <span class="title function_">insertTrie</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">            <span class="title function_">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="title function_">searchTrie</span>(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间限制: 10000ms</p>
<p>单点时限: 1000ms<br>内存限制: 256MB</p>
<p>小Hi和小Ho是一对好朋友，出生在信息化社会的他们对编程产生了莫大的兴趣，他们约定好互相帮助，在编程的学习道路上一同前进。</p>
<p>这一天，他们遇到了一本词典，于是小Hi就向小Ho提出了那个经典的问题：“小Ho，你能不能对于每一个我给出的字符串，都在这个词典里面找到以这个字符串开头的所有单词呢？”</p>
<p>身经百战的小Ho答道：“怎么会不能呢！你每给我一个字符串，我就依次遍历词典里的所有单词，检查你给我的字符串是不是这个单词的前缀不就是了？”</p>
<p>小Hi笑道：“你啊，还是太年轻了！~假设这本词典里有10万个单词，我询问你一万次，你得要算到哪年哪月去？”</p>
<p>小Ho低头算了一算，看着那一堆堆的0，顿时感觉自己这辈子都要花在上面了…</p>
<p>小Hi看着小Ho的囧样，也是继续笑道：“让我来提高一下你的知识水平吧~你知道树这样一种数据结构么？”</p>
<p>小Ho想了想，说道：“知道~它是一种基础的数据结构，就像<a href="http://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)">这里</a>说的一样！”</p>
<p>小Hi满意的点了点头，说道：“那你知道我怎么样用一棵树来表示整个词典么？”</p>
<p>小Ho摇摇头表示自己不清楚。</p>
<p><a href="http://hihocoder.com/problemset/problem/1014#">提示一：Trie树的建立</a></p>
<p>“你看，我们现在得到了这样一棵树，那么你看，如果我给你一个字符串ap，你要怎么找到所有以ap开头的单词呢？”小Hi又开始考校小Ho。</p>
<p>“唔…一个个遍历所有的单词？”小Ho还是不忘自己最开始提出来的算法。</p>
<p>“笨！这棵树难道就白构建了！”小Hi教训完小Ho，继续道：“看好了！”</p>
<p><a href="http://hihocoder.com/problemset/problem/1014#">提示二：如何使用Trie树</a></p>
<p><a href="http://hihocoder.com/problemset/problem/1014#">提示三：在建立Trie树时同时进行统计！</a></p>
<p>“那么现在！赶紧去用代码实现吧！”小Hi如是说道</p>
<p>输入的第一行为一个正整数n，表示词典的大小，其后n行，每一行一个单词（不保证是英文单词，也有可能是火星文单词哦），单词由不超过10个的小写英文字母组成，可能存在相同的单词，此时应将其视作不同的单词。接下来的一行为一个正整数m，表示小Hi询问的次数，其后m行，每一行一个字符串，该字符串由不超过10个的小写英文字母组成，表示小Hi的一个询问。</p>
<p>在20%的数据中n, m&lt;&#x3D;10，词典的字母表大小&lt;&#x3D;2.</p>
<p>在60%的数据中n, m&lt;&#x3D;1000，词典的字母表大小&lt;&#x3D;5.</p>
<p>在100%的数据中n, m&lt;&#x3D;100000，词典的字母表大小&lt;&#x3D;26.</p>
<p>本题按通过的数据量排名哦～</p>
<p>对于小Hi的每一个询问，输出一个整数Ans,表示词典中以小Hi给出的字符串为前缀的单词的个数。<br>样例输入 5 babaab babbbaaaa abba aaaaabaa babaababb 5 babb baabaaa bab bb bbabbaab 样例输出 1 0 3 0 0</p>
]]></content>
      <categories>
        <category>OJ</category>
        <category>String</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
</search>
